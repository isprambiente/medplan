var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/adapters.js
var adapters_default;
var init_adapters = __esm(() => {
  adapters_default = {
    logger: typeof console !== "undefined" ? console : undefined,
    WebSocket: typeof WebSocket !== "undefined" ? WebSocket : undefined
  };
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/logger.js
var logger_default;
var init_logger = __esm(() => {
  init_adapters();
  logger_default = {
    log(...messages) {
      if (this.enabled) {
        messages.push(Date.now());
        adapters_default.logger.log("[ActionCable]", ...messages);
      }
    }
  };
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection_monitor.js
class ConnectionMonitor {
  constructor(connection) {
    this.visibilityDidChange = this.visibilityDidChange.bind(this);
    this.connection = connection;
    this.reconnectAttempts = 0;
  }
  start() {
    if (!this.isRunning()) {
      this.startedAt = now();
      delete this.stoppedAt;
      this.startPolling();
      addEventListener("visibilitychange", this.visibilityDidChange);
      logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
    }
  }
  stop() {
    if (this.isRunning()) {
      this.stoppedAt = now();
      this.stopPolling();
      removeEventListener("visibilitychange", this.visibilityDidChange);
      logger_default.log("ConnectionMonitor stopped");
    }
  }
  isRunning() {
    return this.startedAt && !this.stoppedAt;
  }
  recordMessage() {
    this.pingedAt = now();
  }
  recordConnect() {
    this.reconnectAttempts = 0;
    delete this.disconnectedAt;
    logger_default.log("ConnectionMonitor recorded connect");
  }
  recordDisconnect() {
    this.disconnectedAt = now();
    logger_default.log("ConnectionMonitor recorded disconnect");
  }
  startPolling() {
    this.stopPolling();
    this.poll();
  }
  stopPolling() {
    clearTimeout(this.pollTimeout);
  }
  poll() {
    this.pollTimeout = setTimeout(() => {
      this.reconnectIfStale();
      this.poll();
    }, this.getPollInterval());
  }
  getPollInterval() {
    const { staleThreshold, reconnectionBackoffRate } = this.constructor;
    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
    const jitter = jitterMax * Math.random();
    return staleThreshold * 1000 * backoff * (1 + jitter);
  }
  reconnectIfStale() {
    if (this.connectionIsStale()) {
      logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
      this.reconnectAttempts++;
      if (this.disconnectedRecently()) {
        logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
      } else {
        logger_default.log("ConnectionMonitor reopening");
        this.connection.reopen();
      }
    }
  }
  get refreshedAt() {
    return this.pingedAt ? this.pingedAt : this.startedAt;
  }
  connectionIsStale() {
    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
  }
  disconnectedRecently() {
    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
  }
  visibilityDidChange() {
    if (document.visibilityState === "visible") {
      setTimeout(() => {
        if (this.connectionIsStale() || !this.connection.isOpen()) {
          logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
          this.connection.reopen();
        }
      }, 200);
    }
  }
}
var now = () => new Date().getTime(), secondsSince = (time) => (now() - time) / 1000, connection_monitor_default;
var init_connection_monitor = __esm(() => {
  init_logger();
  ConnectionMonitor.staleThreshold = 6;
  ConnectionMonitor.reconnectionBackoffRate = 0.15;
  connection_monitor_default = ConnectionMonitor;
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/internal.js
var internal_default;
var init_internal = __esm(() => {
  internal_default = {
    message_types: {
      welcome: "welcome",
      disconnect: "disconnect",
      ping: "ping",
      confirmation: "confirm_subscription",
      rejection: "reject_subscription"
    },
    disconnect_reasons: {
      unauthorized: "unauthorized",
      invalid_request: "invalid_request",
      server_restart: "server_restart",
      remote: "remote"
    },
    default_mount_path: "/cable",
    protocols: [
      "actioncable-v1-json",
      "actioncable-unsupported"
    ]
  };
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/connection.js
class Connection {
  constructor(consumer) {
    this.open = this.open.bind(this);
    this.consumer = consumer;
    this.subscriptions = this.consumer.subscriptions;
    this.monitor = new connection_monitor_default(this);
    this.disconnected = true;
  }
  send(data) {
    if (this.isOpen()) {
      this.webSocket.send(JSON.stringify(data));
      return true;
    } else {
      return false;
    }
  }
  open() {
    if (this.isActive()) {
      logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
      return false;
    } else {
      const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
      logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
      if (this.webSocket) {
        this.uninstallEventHandlers();
      }
      this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
      this.installEventHandlers();
      this.monitor.start();
      return true;
    }
  }
  close({ allowReconnect } = { allowReconnect: true }) {
    if (!allowReconnect) {
      this.monitor.stop();
    }
    if (this.isOpen()) {
      return this.webSocket.close();
    }
  }
  reopen() {
    logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
    if (this.isActive()) {
      try {
        return this.close();
      } catch (error) {
        logger_default.log("Failed to reopen WebSocket", error);
      } finally {
        logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
        setTimeout(this.open, this.constructor.reopenDelay);
      }
    } else {
      return this.open();
    }
  }
  getProtocol() {
    if (this.webSocket) {
      return this.webSocket.protocol;
    }
  }
  isOpen() {
    return this.isState("open");
  }
  isActive() {
    return this.isState("open", "connecting");
  }
  triedToReconnect() {
    return this.monitor.reconnectAttempts > 0;
  }
  isProtocolSupported() {
    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
  }
  isState(...states) {
    return indexOf.call(states, this.getState()) >= 0;
  }
  getState() {
    if (this.webSocket) {
      for (let state in adapters_default.WebSocket) {
        if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
          return state.toLowerCase();
        }
      }
    }
    return null;
  }
  installEventHandlers() {
    for (let eventName in this.events) {
      const handler = this.events[eventName].bind(this);
      this.webSocket[`on${eventName}`] = handler;
    }
  }
  uninstallEventHandlers() {
    for (let eventName in this.events) {
      this.webSocket[`on${eventName}`] = function() {};
    }
  }
}
var message_types, protocols, supportedProtocols, indexOf, connection_default;
var init_connection = __esm(() => {
  init_adapters();
  init_connection_monitor();
  init_internal();
  init_logger();
  ({ message_types, protocols } = internal_default);
  supportedProtocols = protocols.slice(0, protocols.length - 1);
  indexOf = [].indexOf;
  Connection.reopenDelay = 500;
  Connection.prototype.events = {
    message(event) {
      if (!this.isProtocolSupported()) {
        return;
      }
      const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
      this.monitor.recordMessage();
      switch (type) {
        case message_types.welcome:
          if (this.triedToReconnect()) {
            this.reconnectAttempted = true;
          }
          this.monitor.recordConnect();
          return this.subscriptions.reload();
        case message_types.disconnect:
          logger_default.log(`Disconnecting. Reason: ${reason}`);
          return this.close({ allowReconnect: reconnect });
        case message_types.ping:
          return null;
        case message_types.confirmation:
          this.subscriptions.confirmSubscription(identifier);
          if (this.reconnectAttempted) {
            this.reconnectAttempted = false;
            return this.subscriptions.notify(identifier, "connected", { reconnected: true });
          } else {
            return this.subscriptions.notify(identifier, "connected", { reconnected: false });
          }
        case message_types.rejection:
          return this.subscriptions.reject(identifier);
        default:
          return this.subscriptions.notify(identifier, "received", message);
      }
    },
    open() {
      logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
      this.disconnected = false;
      if (!this.isProtocolSupported()) {
        logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
        return this.close({ allowReconnect: false });
      }
    },
    close(event) {
      logger_default.log("WebSocket onclose event");
      if (this.disconnected) {
        return;
      }
      this.disconnected = true;
      this.monitor.recordDisconnect();
      return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
    },
    error() {
      logger_default.log("WebSocket onerror event");
    }
  };
  connection_default = Connection;
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscription.js
class Subscription {
  constructor(consumer, params = {}, mixin) {
    this.consumer = consumer;
    this.identifier = JSON.stringify(params);
    extend(this, mixin);
  }
  perform(action, data = {}) {
    data.action = action;
    return this.send(data);
  }
  send(data) {
    return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
  }
  unsubscribe() {
    return this.consumer.subscriptions.remove(this);
  }
}
var extend = function(object, properties) {
  if (properties != null) {
    for (let key in properties) {
      const value = properties[key];
      object[key] = value;
    }
  }
  return object;
};

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscription_guarantor.js
class SubscriptionGuarantor {
  constructor(subscriptions) {
    this.subscriptions = subscriptions;
    this.pendingSubscriptions = [];
  }
  guarantee(subscription) {
    if (this.pendingSubscriptions.indexOf(subscription) == -1) {
      logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
      this.pendingSubscriptions.push(subscription);
    } else {
      logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
    }
    this.startGuaranteeing();
  }
  forget(subscription) {
    logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
    this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
  }
  startGuaranteeing() {
    this.stopGuaranteeing();
    this.retrySubscribing();
  }
  stopGuaranteeing() {
    clearTimeout(this.retryTimeout);
  }
  retrySubscribing() {
    this.retryTimeout = setTimeout(() => {
      if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
        this.pendingSubscriptions.map((subscription) => {
          logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
          this.subscriptions.subscribe(subscription);
        });
      }
    }, 500);
  }
}
var subscription_guarantor_default;
var init_subscription_guarantor = __esm(() => {
  init_logger();
  subscription_guarantor_default = SubscriptionGuarantor;
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/subscriptions.js
class Subscriptions {
  constructor(consumer) {
    this.consumer = consumer;
    this.guarantor = new subscription_guarantor_default(this);
    this.subscriptions = [];
  }
  create(channelName, mixin) {
    const channel = channelName;
    const params = typeof channel === "object" ? channel : { channel };
    const subscription = new Subscription(this.consumer, params, mixin);
    return this.add(subscription);
  }
  add(subscription) {
    this.subscriptions.push(subscription);
    this.consumer.ensureActiveConnection();
    this.notify(subscription, "initialized");
    this.subscribe(subscription);
    return subscription;
  }
  remove(subscription) {
    this.forget(subscription);
    if (!this.findAll(subscription.identifier).length) {
      this.sendCommand(subscription, "unsubscribe");
    }
    return subscription;
  }
  reject(identifier) {
    return this.findAll(identifier).map((subscription) => {
      this.forget(subscription);
      this.notify(subscription, "rejected");
      return subscription;
    });
  }
  forget(subscription) {
    this.guarantor.forget(subscription);
    this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
    return subscription;
  }
  findAll(identifier) {
    return this.subscriptions.filter((s) => s.identifier === identifier);
  }
  reload() {
    return this.subscriptions.map((subscription) => this.subscribe(subscription));
  }
  notifyAll(callbackName, ...args) {
    return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
  }
  notify(subscription, callbackName, ...args) {
    let subscriptions;
    if (typeof subscription === "string") {
      subscriptions = this.findAll(subscription);
    } else {
      subscriptions = [subscription];
    }
    return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : undefined);
  }
  subscribe(subscription) {
    if (this.sendCommand(subscription, "subscribe")) {
      this.guarantor.guarantee(subscription);
    }
  }
  confirmSubscription(identifier) {
    logger_default.log(`Subscription confirmed ${identifier}`);
    this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
  }
  sendCommand(subscription, command) {
    const { identifier } = subscription;
    return this.consumer.send({ command, identifier });
  }
}
var init_subscriptions = __esm(() => {
  init_subscription_guarantor();
  init_logger();
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/consumer.js
class Consumer {
  constructor(url) {
    this._url = url;
    this.subscriptions = new Subscriptions(this);
    this.connection = new connection_default(this);
    this.subprotocols = [];
  }
  get url() {
    return createWebSocketURL(this._url);
  }
  send(data) {
    return this.connection.send(data);
  }
  connect() {
    return this.connection.open();
  }
  disconnect() {
    return this.connection.close({ allowReconnect: false });
  }
  ensureActiveConnection() {
    if (!this.connection.isActive()) {
      return this.connection.open();
    }
  }
  addSubProtocol(subprotocol) {
    this.subprotocols = [...this.subprotocols, subprotocol];
  }
}
function createWebSocketURL(url) {
  if (typeof url === "function") {
    url = url();
  }
  if (url && !/^wss?:/i.test(url)) {
    const a = document.createElement("a");
    a.href = url;
    a.href = a.href;
    a.protocol = a.protocol.replace("http", "ws");
    return a.href;
  } else {
    return url;
  }
}
var init_consumer = __esm(() => {
  init_connection();
  init_subscriptions();
});

// node_modules/@hotwired/turbo-rails/node_modules/@rails/actioncable/src/index.js
var exports_src = {};
__export(exports_src, {
  logger: () => logger_default,
  getConfig: () => getConfig,
  createWebSocketURL: () => createWebSocketURL,
  createConsumer: () => createConsumer,
  adapters: () => adapters_default,
  Subscriptions: () => Subscriptions,
  SubscriptionGuarantor: () => subscription_guarantor_default,
  Subscription: () => Subscription,
  INTERNAL: () => internal_default,
  Consumer: () => Consumer,
  ConnectionMonitor: () => connection_monitor_default,
  Connection: () => connection_default
});
function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
  return new Consumer(url);
}
function getConfig(name) {
  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
  if (element) {
    return element.getAttribute("content");
  }
}
var init_src = __esm(() => {
  init_connection();
  init_connection_monitor();
  init_consumer();
  init_internal();
  init_subscriptions();
  init_subscription_guarantor();
  init_adapters();
  init_logger();
});

// node_modules/sweetalert2/dist/sweetalert2.all.js
var require_sweetalert2_all = __commonJS((exports, module) => {
  /*!
  * sweetalert2 v11.23.0
  * Released under the MIT License.
  */
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.Sweetalert2 = factory());
  })(exports, function() {
    function _assertClassBrand(e, t, n) {
      if (typeof e == "function" ? e === t : e.has(t))
        return arguments.length < 3 ? t : n;
      throw new TypeError("Private element is not present on this object");
    }
    function _checkPrivateRedeclaration(e, t) {
      if (t.has(e))
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
    function _classPrivateFieldGet2(s, a) {
      return s.get(_assertClassBrand(s, a));
    }
    function _classPrivateFieldInitSpec(e, t, a) {
      _checkPrivateRedeclaration(e, t), t.set(e, a);
    }
    function _classPrivateFieldSet2(s, a, r) {
      return s.set(_assertClassBrand(s, a), r), r;
    }
    const RESTORE_FOCUS_TIMEOUT = 100;
    const globalState = {};
    const focusPreviousActiveElement = () => {
      if (globalState.previousActiveElement instanceof HTMLElement) {
        globalState.previousActiveElement.focus();
        globalState.previousActiveElement = null;
      } else if (document.body) {
        document.body.focus();
      }
    };
    const restoreActiveElement = (returnFocus) => {
      return new Promise((resolve) => {
        if (!returnFocus) {
          return resolve();
        }
        const x = window.scrollX;
        const y = window.scrollY;
        globalState.restoreFocusTimeout = setTimeout(() => {
          focusPreviousActiveElement();
          resolve();
        }, RESTORE_FOCUS_TIMEOUT);
        window.scrollTo(x, y);
      });
    };
    const swalPrefix = "swal2-";
    const classNames = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error", "draggable", "dragging"];
    const swalClasses = classNames.reduce((acc, className) => {
      acc[className] = swalPrefix + className;
      return acc;
    }, {});
    const icons = ["success", "warning", "info", "question", "error"];
    const iconTypes = icons.reduce((acc, icon) => {
      acc[icon] = swalPrefix + icon;
      return acc;
    }, {});
    const consolePrefix = "SweetAlert2:";
    const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
    const warn2 = (message) => {
      console.warn(`${consolePrefix} ${typeof message === "object" ? message.join(" ") : message}`);
    };
    const error2 = (message) => {
      console.error(`${consolePrefix} ${message}`);
    };
    const previousWarnOnceMessages = [];
    const warnOnce = (message) => {
      if (!previousWarnOnceMessages.includes(message)) {
        previousWarnOnceMessages.push(message);
        warn2(message);
      }
    };
    const warnAboutDeprecation = (deprecatedParam, useInstead = null) => {
      warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ""}`);
    };
    const callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
    const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === "function";
    const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
    const isPromise = (arg) => arg && Promise.resolve(arg) === arg;
    const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);
    const elementBySelector = (selectorString) => {
      const container = getContainer();
      return container ? container.querySelector(selectorString) : null;
    };
    const elementByClass = (className) => {
      return elementBySelector(`.${className}`);
    };
    const getPopup = () => elementByClass(swalClasses.popup);
    const getIcon = () => elementByClass(swalClasses.icon);
    const getIconContent = () => elementByClass(swalClasses["icon-content"]);
    const getTitle = () => elementByClass(swalClasses.title);
    const getHtmlContainer = () => elementByClass(swalClasses["html-container"]);
    const getImage = () => elementByClass(swalClasses.image);
    const getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
    const getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
    const getConfirmButton = () => elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);
    const getCancelButton = () => elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);
    const getDenyButton = () => elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);
    const getInputLabel = () => elementByClass(swalClasses["input-label"]);
    const getLoader = () => elementBySelector(`.${swalClasses.loader}`);
    const getActions = () => elementByClass(swalClasses.actions);
    const getFooter = () => elementByClass(swalClasses.footer);
    const getTimerProgressBar = () => elementByClass(swalClasses["timer-progress-bar"]);
    const getCloseButton = () => elementByClass(swalClasses.close);
    const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
    const getFocusableElements = () => {
      const popup = getPopup();
      if (!popup) {
        return [];
      }
      const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
      const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex).sort((a, b) => {
        const tabindexA = parseInt(a.getAttribute("tabindex") || "0");
        const tabindexB = parseInt(b.getAttribute("tabindex") || "0");
        if (tabindexA > tabindexB) {
          return 1;
        } else if (tabindexA < tabindexB) {
          return -1;
        }
        return 0;
      });
      const otherFocusableElements = popup.querySelectorAll(focusable);
      const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el) => el.getAttribute("tabindex") !== "-1");
      return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter((el) => isVisible$1(el));
    };
    const isModal = () => {
      return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
    };
    const isToast = () => {
      const popup = getPopup();
      if (!popup) {
        return false;
      }
      return hasClass(popup, swalClasses.toast);
    };
    const isLoading = () => {
      const popup = getPopup();
      if (!popup) {
        return false;
      }
      return popup.hasAttribute("data-loading");
    };
    const setInnerHtml = (elem, html) => {
      elem.textContent = "";
      if (html) {
        const parser = new DOMParser;
        const parsed = parser.parseFromString(html, `text/html`);
        const head = parsed.querySelector("head");
        if (head) {
          Array.from(head.childNodes).forEach((child) => {
            elem.appendChild(child);
          });
        }
        const body = parsed.querySelector("body");
        if (body) {
          Array.from(body.childNodes).forEach((child) => {
            if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
              elem.appendChild(child.cloneNode(true));
            } else {
              elem.appendChild(child);
            }
          });
        }
      }
    };
    const hasClass = (elem, className) => {
      if (!className) {
        return false;
      }
      const classList = className.split(/\s+/);
      for (let i = 0;i < classList.length; i++) {
        if (!elem.classList.contains(classList[i])) {
          return false;
        }
      }
      return true;
    };
    const removeCustomClasses = (elem, params) => {
      Array.from(elem.classList).forEach((className) => {
        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
          elem.classList.remove(className);
        }
      });
    };
    const applyCustomClass = (elem, params, className) => {
      removeCustomClasses(elem, params);
      if (!params.customClass) {
        return;
      }
      const customClass = params.customClass[className];
      if (!customClass) {
        return;
      }
      if (typeof customClass !== "string" && !customClass.forEach) {
        warn2(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
        return;
      }
      addClass(elem, customClass);
    };
    const getInput$1 = (popup, inputClass) => {
      if (!inputClass) {
        return null;
      }
      switch (inputClass) {
        case "select":
        case "textarea":
        case "file":
          return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
        case "checkbox":
          return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
        case "radio":
          return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
        case "range":
          return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
        default:
          return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
      }
    };
    const focusInput = (input) => {
      input.focus();
      if (input.type !== "file") {
        const val = input.value;
        input.value = "";
        input.value = val;
      }
    };
    const toggleClass = (target, classList, condition) => {
      if (!target || !classList) {
        return;
      }
      if (typeof classList === "string") {
        classList = classList.split(/\s+/).filter(Boolean);
      }
      classList.forEach((className) => {
        if (Array.isArray(target)) {
          target.forEach((elem) => {
            if (condition) {
              elem.classList.add(className);
            } else {
              elem.classList.remove(className);
            }
          });
        } else {
          if (condition) {
            target.classList.add(className);
          } else {
            target.classList.remove(className);
          }
        }
      });
    };
    const addClass = (target, classList) => {
      toggleClass(target, classList, true);
    };
    const removeClass = (target, classList) => {
      toggleClass(target, classList, false);
    };
    const getDirectChildByClass = (elem, className) => {
      const children = Array.from(elem.children);
      for (let i = 0;i < children.length; i++) {
        const child = children[i];
        if (child instanceof HTMLElement && hasClass(child, className)) {
          return child;
        }
      }
    };
    const applyNumericalStyle = (elem, property, value) => {
      if (value === `${parseInt(value)}`) {
        value = parseInt(value);
      }
      if (value || parseInt(value) === 0) {
        elem.style.setProperty(property, typeof value === "number" ? `${value}px` : value);
      } else {
        elem.style.removeProperty(property);
      }
    };
    const show = (elem, display = "flex") => {
      if (!elem) {
        return;
      }
      elem.style.display = display;
    };
    const hide = (elem) => {
      if (!elem) {
        return;
      }
      elem.style.display = "none";
    };
    const showWhenInnerHtmlPresent = (elem, display = "block") => {
      if (!elem) {
        return;
      }
      new MutationObserver(() => {
        toggle(elem, elem.innerHTML, display);
      }).observe(elem, {
        childList: true,
        subtree: true
      });
    };
    const setStyle = (parent, selector, property, value) => {
      const el = parent.querySelector(selector);
      if (el) {
        el.style.setProperty(property, value);
      }
    };
    const toggle = (elem, condition, display = "flex") => {
      if (condition) {
        show(elem, display);
      } else {
        hide(elem);
      }
    };
    const isVisible$1 = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
    const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
    const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
    const selfOrParentIsScrollable = (element, stopElement) => {
      let parent = element;
      while (parent && parent !== stopElement) {
        if (isScrollable(parent)) {
          return true;
        }
        parent = parent.parentElement;
      }
      return false;
    };
    const hasCssAnimation = (elem) => {
      const style = window.getComputedStyle(elem);
      const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
      const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
      return animDuration > 0 || transDuration > 0;
    };
    const animateTimerProgressBar = (timer, reset = false) => {
      const timerProgressBar = getTimerProgressBar();
      if (!timerProgressBar) {
        return;
      }
      if (isVisible$1(timerProgressBar)) {
        if (reset) {
          timerProgressBar.style.transition = "none";
          timerProgressBar.style.width = "100%";
        }
        setTimeout(() => {
          timerProgressBar.style.transition = `width ${timer / 1000}s linear`;
          timerProgressBar.style.width = "0%";
        }, 10);
      }
    };
    const stopTimerProgressBar = () => {
      const timerProgressBar = getTimerProgressBar();
      if (!timerProgressBar) {
        return;
      }
      const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
      timerProgressBar.style.removeProperty("transition");
      timerProgressBar.style.width = "100%";
      const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
      const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
      timerProgressBar.style.width = `${timerProgressBarPercent}%`;
    };
    const isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";
    const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses["html-container"]}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses["progress-steps"]}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses["html-container"]}" id="${swalClasses["html-container"]}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses["validation-message"]}" id="${swalClasses["validation-message"]}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses["timer-progress-bar-container"]}">
     <div class="${swalClasses["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, "");
    const resetOldContainer = () => {
      const oldContainer = getContainer();
      if (!oldContainer) {
        return false;
      }
      oldContainer.remove();
      removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
      return true;
    };
    const resetValidationMessage$1 = () => {
      globalState.currentInstance.resetValidationMessage();
    };
    const addInputChangeListeners = () => {
      const popup = getPopup();
      const input = getDirectChildByClass(popup, swalClasses.input);
      const file = getDirectChildByClass(popup, swalClasses.file);
      const range = popup.querySelector(`.${swalClasses.range} input`);
      const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
      const select = getDirectChildByClass(popup, swalClasses.select);
      const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
      const textarea = getDirectChildByClass(popup, swalClasses.textarea);
      input.oninput = resetValidationMessage$1;
      file.onchange = resetValidationMessage$1;
      select.onchange = resetValidationMessage$1;
      checkbox.onchange = resetValidationMessage$1;
      textarea.oninput = resetValidationMessage$1;
      range.oninput = () => {
        resetValidationMessage$1();
        rangeOutput.value = range.value;
      };
      range.onchange = () => {
        resetValidationMessage$1();
        rangeOutput.value = range.value;
      };
    };
    const getTarget = (target) => typeof target === "string" ? document.querySelector(target) : target;
    const setupAccessibility = (params) => {
      const popup = getPopup();
      popup.setAttribute("role", params.toast ? "alert" : "dialog");
      popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
      if (!params.toast) {
        popup.setAttribute("aria-modal", "true");
      }
    };
    const setupRTL = (targetElement) => {
      if (window.getComputedStyle(targetElement).direction === "rtl") {
        addClass(getContainer(), swalClasses.rtl);
      }
    };
    const init = (params) => {
      const oldContainerExisted = resetOldContainer();
      if (isNodeEnv()) {
        error2("SweetAlert2 requires document to initialize");
        return;
      }
      const container = document.createElement("div");
      container.className = swalClasses.container;
      if (oldContainerExisted) {
        addClass(container, swalClasses["no-transition"]);
      }
      setInnerHtml(container, sweetHTML);
      container.dataset["swal2Theme"] = params.theme;
      const targetElement = getTarget(params.target);
      targetElement.appendChild(container);
      if (params.topLayer) {
        container.setAttribute("popover", "");
        container.showPopover();
      }
      setupAccessibility(params);
      setupRTL(targetElement);
      addInputChangeListeners();
    };
    const parseHtmlToContainer = (param, target) => {
      if (param instanceof HTMLElement) {
        target.appendChild(param);
      } else if (typeof param === "object") {
        handleObject(param, target);
      } else if (param) {
        setInnerHtml(target, param);
      }
    };
    const handleObject = (param, target) => {
      if (param.jquery) {
        handleJqueryElem(target, param);
      } else {
        setInnerHtml(target, param.toString());
      }
    };
    const handleJqueryElem = (target, elem) => {
      target.textContent = "";
      if (0 in elem) {
        for (let i = 0;i in elem; i++) {
          target.appendChild(elem[i].cloneNode(true));
        }
      } else {
        target.appendChild(elem.cloneNode(true));
      }
    };
    const renderActions = (instance, params) => {
      const actions = getActions();
      const loader = getLoader();
      if (!actions || !loader) {
        return;
      }
      if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
        hide(actions);
      } else {
        show(actions);
      }
      applyCustomClass(actions, params, "actions");
      renderButtons(actions, loader, params);
      setInnerHtml(loader, params.loaderHtml || "");
      applyCustomClass(loader, params, "loader");
    };
    function renderButtons(actions, loader, params) {
      const confirmButton = getConfirmButton();
      const denyButton = getDenyButton();
      const cancelButton = getCancelButton();
      if (!confirmButton || !denyButton || !cancelButton) {
        return;
      }
      renderButton(confirmButton, "confirm", params);
      renderButton(denyButton, "deny", params);
      renderButton(cancelButton, "cancel", params);
      handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
      if (params.reverseButtons) {
        if (params.toast) {
          actions.insertBefore(cancelButton, confirmButton);
          actions.insertBefore(denyButton, confirmButton);
        } else {
          actions.insertBefore(cancelButton, loader);
          actions.insertBefore(denyButton, loader);
          actions.insertBefore(confirmButton, loader);
        }
      }
    }
    function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
      if (!params.buttonsStyling) {
        removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
        return;
      }
      addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
      if (params.confirmButtonColor) {
        confirmButton.style.setProperty("--swal2-confirm-button-background-color", params.confirmButtonColor);
      }
      if (params.denyButtonColor) {
        denyButton.style.setProperty("--swal2-deny-button-background-color", params.denyButtonColor);
      }
      if (params.cancelButtonColor) {
        cancelButton.style.setProperty("--swal2-cancel-button-background-color", params.cancelButtonColor);
      }
      applyOutlineColor(confirmButton);
      applyOutlineColor(denyButton);
      applyOutlineColor(cancelButton);
    }
    function applyOutlineColor(button) {
      const buttonStyle = window.getComputedStyle(button);
      if (buttonStyle.getPropertyValue("--swal2-action-button-focus-box-shadow")) {
        return;
      }
      const outlineColor = buttonStyle.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, "rgba($1, $2, $3, 0.5)");
      button.style.setProperty("--swal2-action-button-focus-box-shadow", buttonStyle.getPropertyValue("--swal2-outline").replace(/ rgba\(.*/, ` ${outlineColor}`));
    }
    function renderButton(button, buttonType, params) {
      const buttonName = capitalizeFirstLetter(buttonType);
      toggle(button, params[`show${buttonName}Button`], "inline-block");
      setInnerHtml(button, params[`${buttonType}ButtonText`] || "");
      button.setAttribute("aria-label", params[`${buttonType}ButtonAriaLabel`] || "");
      button.className = swalClasses[buttonType];
      applyCustomClass(button, params, `${buttonType}Button`);
    }
    const renderCloseButton = (instance, params) => {
      const closeButton = getCloseButton();
      if (!closeButton) {
        return;
      }
      setInnerHtml(closeButton, params.closeButtonHtml || "");
      applyCustomClass(closeButton, params, "closeButton");
      toggle(closeButton, params.showCloseButton);
      closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
    };
    const renderContainer = (instance, params) => {
      const container = getContainer();
      if (!container) {
        return;
      }
      handleBackdropParam(container, params.backdrop);
      handlePositionParam(container, params.position);
      handleGrowParam(container, params.grow);
      applyCustomClass(container, params, "container");
    };
    function handleBackdropParam(container, backdrop) {
      if (typeof backdrop === "string") {
        container.style.background = backdrop;
      } else if (!backdrop) {
        addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
      }
    }
    function handlePositionParam(container, position) {
      if (!position) {
        return;
      }
      if (position in swalClasses) {
        addClass(container, swalClasses[position]);
      } else {
        warn2('The "position" parameter is not valid, defaulting to "center"');
        addClass(container, swalClasses.center);
      }
    }
    function handleGrowParam(container, grow) {
      if (!grow) {
        return;
      }
      addClass(container, swalClasses[`grow-${grow}`]);
    }
    var privateProps = {
      innerParams: new WeakMap,
      domCache: new WeakMap
    };
    const inputClasses = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
    const renderInput = (instance, params) => {
      const popup = getPopup();
      if (!popup) {
        return;
      }
      const innerParams = privateProps.innerParams.get(instance);
      const rerender = !innerParams || params.input !== innerParams.input;
      inputClasses.forEach((inputClass) => {
        const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
        if (!inputContainer) {
          return;
        }
        setAttributes(inputClass, params.inputAttributes);
        inputContainer.className = swalClasses[inputClass];
        if (rerender) {
          hide(inputContainer);
        }
      });
      if (params.input) {
        if (rerender) {
          showInput(params);
        }
        setCustomClass(params);
      }
    };
    const showInput = (params) => {
      if (!params.input) {
        return;
      }
      if (!renderInputType[params.input]) {
        error2(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(" | ")}, got "${params.input}"`);
        return;
      }
      const inputContainer = getInputContainer(params.input);
      if (!inputContainer) {
        return;
      }
      const input = renderInputType[params.input](inputContainer, params);
      show(inputContainer);
      if (params.inputAutoFocus) {
        setTimeout(() => {
          focusInput(input);
        });
      }
    };
    const removeAttributes = (input) => {
      for (let i = 0;i < input.attributes.length; i++) {
        const attrName = input.attributes[i].name;
        if (!["id", "type", "value", "style"].includes(attrName)) {
          input.removeAttribute(attrName);
        }
      }
    };
    const setAttributes = (inputClass, inputAttributes) => {
      const popup = getPopup();
      if (!popup) {
        return;
      }
      const input = getInput$1(popup, inputClass);
      if (!input) {
        return;
      }
      removeAttributes(input);
      for (const attr in inputAttributes) {
        input.setAttribute(attr, inputAttributes[attr]);
      }
    };
    const setCustomClass = (params) => {
      if (!params.input) {
        return;
      }
      const inputContainer = getInputContainer(params.input);
      if (inputContainer) {
        applyCustomClass(inputContainer, params, "input");
      }
    };
    const setInputPlaceholder = (input, params) => {
      if (!input.placeholder && params.inputPlaceholder) {
        input.placeholder = params.inputPlaceholder;
      }
    };
    const setInputLabel = (input, prependTo, params) => {
      if (params.inputLabel) {
        const label = document.createElement("label");
        const labelClass = swalClasses["input-label"];
        label.setAttribute("for", input.id);
        label.className = labelClass;
        if (typeof params.customClass === "object") {
          addClass(label, params.customClass.inputLabel);
        }
        label.innerText = params.inputLabel;
        prependTo.insertAdjacentElement("beforebegin", label);
      }
    };
    const getInputContainer = (inputType) => {
      const popup = getPopup();
      if (!popup) {
        return;
      }
      return getDirectChildByClass(popup, swalClasses[inputType] || swalClasses.input);
    };
    const checkAndSetInputValue = (input, inputValue) => {
      if (["string", "number"].includes(typeof inputValue)) {
        input.value = `${inputValue}`;
      } else if (!isPromise(inputValue)) {
        warn2(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
      }
    };
    const renderInputType = {};
    renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = (input, params) => {
      checkAndSetInputValue(input, params.inputValue);
      setInputLabel(input, input, params);
      setInputPlaceholder(input, params);
      input.type = params.input;
      return input;
    };
    renderInputType.file = (input, params) => {
      setInputLabel(input, input, params);
      setInputPlaceholder(input, params);
      return input;
    };
    renderInputType.range = (range, params) => {
      const rangeInput = range.querySelector("input");
      const rangeOutput = range.querySelector("output");
      checkAndSetInputValue(rangeInput, params.inputValue);
      rangeInput.type = params.input;
      checkAndSetInputValue(rangeOutput, params.inputValue);
      setInputLabel(rangeInput, range, params);
      return range;
    };
    renderInputType.select = (select, params) => {
      select.textContent = "";
      if (params.inputPlaceholder) {
        const placeholder = document.createElement("option");
        setInnerHtml(placeholder, params.inputPlaceholder);
        placeholder.value = "";
        placeholder.disabled = true;
        placeholder.selected = true;
        select.appendChild(placeholder);
      }
      setInputLabel(select, select, params);
      return select;
    };
    renderInputType.radio = (radio) => {
      radio.textContent = "";
      return radio;
    };
    renderInputType.checkbox = (checkboxContainer, params) => {
      const checkbox = getInput$1(getPopup(), "checkbox");
      checkbox.value = "1";
      checkbox.checked = Boolean(params.inputValue);
      const label = checkboxContainer.querySelector("span");
      setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
      return checkbox;
    };
    renderInputType.textarea = (textarea, params) => {
      checkAndSetInputValue(textarea, params.inputValue);
      setInputPlaceholder(textarea, params);
      setInputLabel(textarea, textarea, params);
      const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
      setTimeout(() => {
        if ("MutationObserver" in window) {
          const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
          const textareaResizeHandler = () => {
            if (!document.body.contains(textarea)) {
              return;
            }
            const textareaWidth = textarea.offsetWidth + getMargin(textarea);
            if (textareaWidth > initialPopupWidth) {
              getPopup().style.width = `${textareaWidth}px`;
            } else {
              applyNumericalStyle(getPopup(), "width", params.width);
            }
          };
          new MutationObserver(textareaResizeHandler).observe(textarea, {
            attributes: true,
            attributeFilter: ["style"]
          });
        }
      });
      return textarea;
    };
    const renderContent = (instance, params) => {
      const htmlContainer = getHtmlContainer();
      if (!htmlContainer) {
        return;
      }
      showWhenInnerHtmlPresent(htmlContainer);
      applyCustomClass(htmlContainer, params, "htmlContainer");
      if (params.html) {
        parseHtmlToContainer(params.html, htmlContainer);
        show(htmlContainer, "block");
      } else if (params.text) {
        htmlContainer.textContent = params.text;
        show(htmlContainer, "block");
      } else {
        hide(htmlContainer);
      }
      renderInput(instance, params);
    };
    const renderFooter = (instance, params) => {
      const footer = getFooter();
      if (!footer) {
        return;
      }
      showWhenInnerHtmlPresent(footer);
      toggle(footer, params.footer, "block");
      if (params.footer) {
        parseHtmlToContainer(params.footer, footer);
      }
      applyCustomClass(footer, params, "footer");
    };
    const renderIcon = (instance, params) => {
      const innerParams = privateProps.innerParams.get(instance);
      const icon = getIcon();
      if (!icon) {
        return;
      }
      if (innerParams && params.icon === innerParams.icon) {
        setContent(icon, params);
        applyStyles(icon, params);
        return;
      }
      if (!params.icon && !params.iconHtml) {
        hide(icon);
        return;
      }
      if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
        error2(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
        hide(icon);
        return;
      }
      show(icon);
      setContent(icon, params);
      applyStyles(icon, params);
      addClass(icon, params.showClass && params.showClass.icon);
      const colorSchemeQueryList = window.matchMedia("(prefers-color-scheme: dark)");
      colorSchemeQueryList.addEventListener("change", adjustSuccessIconBackgroundColor);
    };
    const applyStyles = (icon, params) => {
      for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
        if (params.icon !== iconType) {
          removeClass(icon, iconClassName);
        }
      }
      addClass(icon, params.icon && iconTypes[params.icon]);
      setColor(icon, params);
      adjustSuccessIconBackgroundColor();
      applyCustomClass(icon, params, "icon");
    };
    const adjustSuccessIconBackgroundColor = () => {
      const popup = getPopup();
      if (!popup) {
        return;
      }
      const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
      const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
      for (let i = 0;i < successIconParts.length; i++) {
        successIconParts[i].style.backgroundColor = popupBackgroundColor;
      }
    };
    const successIconHtml = (params) => `
  ${params.animation ? '<div class="swal2-success-circular-line-left"></div>' : ""}
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div>
  ${params.animation ? '<div class="swal2-success-fix"></div>' : ""}
  ${params.animation ? '<div class="swal2-success-circular-line-right"></div>' : ""}
`;
    const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;
    const setContent = (icon, params) => {
      if (!params.icon && !params.iconHtml) {
        return;
      }
      let oldContent = icon.innerHTML;
      let newContent = "";
      if (params.iconHtml) {
        newContent = iconContent(params.iconHtml);
      } else if (params.icon === "success") {
        newContent = successIconHtml(params);
        oldContent = oldContent.replace(/ style=".*?"/g, "");
      } else if (params.icon === "error") {
        newContent = errorIconHtml;
      } else if (params.icon) {
        const defaultIconHtml = {
          question: "?",
          warning: "!",
          info: "i"
        };
        newContent = iconContent(defaultIconHtml[params.icon]);
      }
      if (oldContent.trim() !== newContent.trim()) {
        setInnerHtml(icon, newContent);
      }
    };
    const setColor = (icon, params) => {
      if (!params.iconColor) {
        return;
      }
      icon.style.color = params.iconColor;
      icon.style.borderColor = params.iconColor;
      for (const sel of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) {
        setStyle(icon, sel, "background-color", params.iconColor);
      }
      setStyle(icon, ".swal2-success-ring", "border-color", params.iconColor);
    };
    const iconContent = (content) => `<div class="${swalClasses["icon-content"]}">${content}</div>`;
    const renderImage = (instance, params) => {
      const image = getImage();
      if (!image) {
        return;
      }
      if (!params.imageUrl) {
        hide(image);
        return;
      }
      show(image, "");
      image.setAttribute("src", params.imageUrl);
      image.setAttribute("alt", params.imageAlt || "");
      applyNumericalStyle(image, "width", params.imageWidth);
      applyNumericalStyle(image, "height", params.imageHeight);
      image.className = swalClasses.image;
      applyCustomClass(image, params, "image");
    };
    let dragging = false;
    let mousedownX = 0;
    let mousedownY = 0;
    let initialX = 0;
    let initialY = 0;
    const addDraggableListeners = (popup) => {
      popup.addEventListener("mousedown", down);
      document.body.addEventListener("mousemove", move);
      popup.addEventListener("mouseup", up);
      popup.addEventListener("touchstart", down);
      document.body.addEventListener("touchmove", move);
      popup.addEventListener("touchend", up);
    };
    const removeDraggableListeners = (popup) => {
      popup.removeEventListener("mousedown", down);
      document.body.removeEventListener("mousemove", move);
      popup.removeEventListener("mouseup", up);
      popup.removeEventListener("touchstart", down);
      document.body.removeEventListener("touchmove", move);
      popup.removeEventListener("touchend", up);
    };
    const down = (event) => {
      const popup = getPopup();
      if (event.target === popup || getIcon().contains(event.target)) {
        dragging = true;
        const clientXY = getClientXY(event);
        mousedownX = clientXY.clientX;
        mousedownY = clientXY.clientY;
        initialX = parseInt(popup.style.insetInlineStart) || 0;
        initialY = parseInt(popup.style.insetBlockStart) || 0;
        addClass(popup, "swal2-dragging");
      }
    };
    const move = (event) => {
      const popup = getPopup();
      if (dragging) {
        let {
          clientX,
          clientY
        } = getClientXY(event);
        popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;
        popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
      }
    };
    const up = () => {
      const popup = getPopup();
      dragging = false;
      removeClass(popup, "swal2-dragging");
    };
    const getClientXY = (event) => {
      let clientX = 0, clientY = 0;
      if (event.type.startsWith("mouse")) {
        clientX = event.clientX;
        clientY = event.clientY;
      } else if (event.type.startsWith("touch")) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      }
      return {
        clientX,
        clientY
      };
    };
    const renderPopup = (instance, params) => {
      const container = getContainer();
      const popup = getPopup();
      if (!container || !popup) {
        return;
      }
      if (params.toast) {
        applyNumericalStyle(container, "width", params.width);
        popup.style.width = "100%";
        const loader = getLoader();
        if (loader) {
          popup.insertBefore(loader, getIcon());
        }
      } else {
        applyNumericalStyle(popup, "width", params.width);
      }
      applyNumericalStyle(popup, "padding", params.padding);
      if (params.color) {
        popup.style.color = params.color;
      }
      if (params.background) {
        popup.style.background = params.background;
      }
      hide(getValidationMessage());
      addClasses$1(popup, params);
      if (params.draggable && !params.toast) {
        addClass(popup, swalClasses.draggable);
        addDraggableListeners(popup);
      } else {
        removeClass(popup, swalClasses.draggable);
        removeDraggableListeners(popup);
      }
    };
    const addClasses$1 = (popup, params) => {
      const showClass = params.showClass || {};
      popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ""}`;
      if (params.toast) {
        addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
        addClass(popup, swalClasses.toast);
      } else {
        addClass(popup, swalClasses.modal);
      }
      applyCustomClass(popup, params, "popup");
      if (typeof params.customClass === "string") {
        addClass(popup, params.customClass);
      }
      if (params.icon) {
        addClass(popup, swalClasses[`icon-${params.icon}`]);
      }
    };
    const renderProgressSteps = (instance, params) => {
      const progressStepsContainer = getProgressSteps();
      if (!progressStepsContainer) {
        return;
      }
      const {
        progressSteps,
        currentProgressStep
      } = params;
      if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {
        hide(progressStepsContainer);
        return;
      }
      show(progressStepsContainer);
      progressStepsContainer.textContent = "";
      if (currentProgressStep >= progressSteps.length) {
        warn2("Invalid currentProgressStep parameter, it should be less than progressSteps.length " + "(currentProgressStep like JS arrays starts from 0)");
      }
      progressSteps.forEach((step, index) => {
        const stepEl = createStepElement(step);
        progressStepsContainer.appendChild(stepEl);
        if (index === currentProgressStep) {
          addClass(stepEl, swalClasses["active-progress-step"]);
        }
        if (index !== progressSteps.length - 1) {
          const lineEl = createLineElement(params);
          progressStepsContainer.appendChild(lineEl);
        }
      });
    };
    const createStepElement = (step) => {
      const stepEl = document.createElement("li");
      addClass(stepEl, swalClasses["progress-step"]);
      setInnerHtml(stepEl, step);
      return stepEl;
    };
    const createLineElement = (params) => {
      const lineEl = document.createElement("li");
      addClass(lineEl, swalClasses["progress-step-line"]);
      if (params.progressStepsDistance) {
        applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
      }
      return lineEl;
    };
    const renderTitle = (instance, params) => {
      const title = getTitle();
      if (!title) {
        return;
      }
      showWhenInnerHtmlPresent(title);
      toggle(title, params.title || params.titleText, "block");
      if (params.title) {
        parseHtmlToContainer(params.title, title);
      }
      if (params.titleText) {
        title.innerText = params.titleText;
      }
      applyCustomClass(title, params, "title");
    };
    const render = (instance, params) => {
      renderPopup(instance, params);
      renderContainer(instance, params);
      renderProgressSteps(instance, params);
      renderIcon(instance, params);
      renderImage(instance, params);
      renderTitle(instance, params);
      renderCloseButton(instance, params);
      renderContent(instance, params);
      renderActions(instance, params);
      renderFooter(instance, params);
      const popup = getPopup();
      if (typeof params.didRender === "function" && popup) {
        params.didRender(popup);
      }
      globalState.eventEmitter.emit("didRender", popup);
    };
    const isVisible = () => {
      return isVisible$1(getPopup());
    };
    const clickConfirm = () => {
      var _dom$getConfirmButton;
      return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === undefined ? undefined : _dom$getConfirmButton.click();
    };
    const clickDeny = () => {
      var _dom$getDenyButton;
      return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === undefined ? undefined : _dom$getDenyButton.click();
    };
    const clickCancel = () => {
      var _dom$getCancelButton;
      return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === undefined ? undefined : _dom$getCancelButton.click();
    };
    const DismissReason = Object.freeze({
      cancel: "cancel",
      backdrop: "backdrop",
      close: "close",
      esc: "esc",
      timer: "timer"
    });
    const removeKeydownHandler = (globalState2) => {
      if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
        globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
          capture: globalState2.keydownListenerCapture
        });
        globalState2.keydownHandlerAdded = false;
      }
    };
    const addKeydownHandler = (globalState2, innerParams, dismissWith) => {
      removeKeydownHandler(globalState2);
      if (!innerParams.toast) {
        globalState2.keydownHandler = (e) => keydownHandler(innerParams, e, dismissWith);
        globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
        globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
        globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
          capture: globalState2.keydownListenerCapture
        });
        globalState2.keydownHandlerAdded = true;
      }
    };
    const setFocus = (index, increment) => {
      var _dom$getPopup;
      const focusableElements = getFocusableElements();
      if (focusableElements.length) {
        index = index + increment;
        if (index === -2) {
          index = focusableElements.length - 1;
        }
        if (index === focusableElements.length) {
          index = 0;
        } else if (index === -1) {
          index = focusableElements.length - 1;
        }
        focusableElements[index].focus();
        return;
      }
      (_dom$getPopup = getPopup()) === null || _dom$getPopup === undefined || _dom$getPopup.focus();
    };
    const arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
    const arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
    const keydownHandler = (innerParams, event, dismissWith) => {
      if (!innerParams) {
        return;
      }
      if (event.isComposing || event.keyCode === 229) {
        return;
      }
      if (innerParams.stopKeydownPropagation) {
        event.stopPropagation();
      }
      if (event.key === "Enter") {
        handleEnter(event, innerParams);
      } else if (event.key === "Tab") {
        handleTab(event);
      } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
        handleArrows(event.key);
      } else if (event.key === "Escape") {
        handleEsc(event, innerParams, dismissWith);
      }
    };
    const handleEnter = (event, innerParams) => {
      if (!callIfFunction(innerParams.allowEnterKey)) {
        return;
      }
      const input = getInput$1(getPopup(), innerParams.input);
      if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
        if (["textarea", "file"].includes(innerParams.input)) {
          return;
        }
        clickConfirm();
        event.preventDefault();
      }
    };
    const handleTab = (event) => {
      const targetElement = event.target;
      const focusableElements = getFocusableElements();
      let btnIndex = -1;
      for (let i = 0;i < focusableElements.length; i++) {
        if (targetElement === focusableElements[i]) {
          btnIndex = i;
          break;
        }
      }
      if (!event.shiftKey) {
        setFocus(btnIndex, 1);
      } else {
        setFocus(btnIndex, -1);
      }
      event.stopPropagation();
      event.preventDefault();
    };
    const handleArrows = (key) => {
      const actions = getActions();
      const confirmButton = getConfirmButton();
      const denyButton = getDenyButton();
      const cancelButton = getCancelButton();
      if (!actions || !confirmButton || !denyButton || !cancelButton) {
        return;
      }
      const buttons = [confirmButton, denyButton, cancelButton];
      if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
        return;
      }
      const sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
      let buttonToFocus = document.activeElement;
      if (!buttonToFocus) {
        return;
      }
      for (let i = 0;i < actions.children.length; i++) {
        buttonToFocus = buttonToFocus[sibling];
        if (!buttonToFocus) {
          return;
        }
        if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
          break;
        }
      }
      if (buttonToFocus instanceof HTMLButtonElement) {
        buttonToFocus.focus();
      }
    };
    const handleEsc = (event, innerParams, dismissWith) => {
      event.preventDefault();
      if (callIfFunction(innerParams.allowEscapeKey)) {
        dismissWith(DismissReason.esc);
      }
    };
    var privateMethods = {
      swalPromiseResolve: new WeakMap,
      swalPromiseReject: new WeakMap
    };
    const setAriaHidden = () => {
      const container = getContainer();
      const bodyChildren = Array.from(document.body.children);
      bodyChildren.forEach((el) => {
        if (el.contains(container)) {
          return;
        }
        if (el.hasAttribute("aria-hidden")) {
          el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
        }
        el.setAttribute("aria-hidden", "true");
      });
    };
    const unsetAriaHidden = () => {
      const bodyChildren = Array.from(document.body.children);
      bodyChildren.forEach((el) => {
        if (el.hasAttribute("data-previous-aria-hidden")) {
          el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
          el.removeAttribute("data-previous-aria-hidden");
        } else {
          el.removeAttribute("aria-hidden");
        }
      });
    };
    const isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent;
    const iOSfix = () => {
      if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
        const offset2 = document.body.scrollTop;
        document.body.style.top = `${offset2 * -1}px`;
        addClass(document.body, swalClasses.iosfix);
        lockBodyScroll();
      }
    };
    const lockBodyScroll = () => {
      const container = getContainer();
      if (!container) {
        return;
      }
      let preventTouchMove;
      container.ontouchstart = (event) => {
        preventTouchMove = shouldPreventTouchMove(event);
      };
      container.ontouchmove = (event) => {
        if (preventTouchMove) {
          event.preventDefault();
          event.stopPropagation();
        }
      };
    };
    const shouldPreventTouchMove = (event) => {
      const target = event.target;
      const container = getContainer();
      const htmlContainer = getHtmlContainer();
      if (!container || !htmlContainer) {
        return false;
      }
      if (isStylus(event) || isZoom(event)) {
        return false;
      }
      if (target === container) {
        return true;
      }
      if (!isScrollable(container) && target instanceof HTMLElement && !selfOrParentIsScrollable(target, htmlContainer) && target.tagName !== "INPUT" && target.tagName !== "TEXTAREA" && !(isScrollable(htmlContainer) && htmlContainer.contains(target))) {
        return true;
      }
      return false;
    };
    const isStylus = (event) => {
      return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
    };
    const isZoom = (event) => {
      return event.touches && event.touches.length > 1;
    };
    const undoIOSfix = () => {
      if (hasClass(document.body, swalClasses.iosfix)) {
        const offset2 = parseInt(document.body.style.top, 10);
        removeClass(document.body, swalClasses.iosfix);
        document.body.style.top = "";
        document.body.scrollTop = offset2 * -1;
      }
    };
    const measureScrollbar = () => {
      const scrollDiv = document.createElement("div");
      scrollDiv.className = swalClasses["scrollbar-measure"];
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    };
    let previousBodyPadding = null;
    const replaceScrollbarWithPadding = (initialBodyOverflow) => {
      if (previousBodyPadding !== null) {
        return;
      }
      if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll") {
        previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
        document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
      }
    };
    const undoReplaceScrollbarWithPadding = () => {
      if (previousBodyPadding !== null) {
        document.body.style.paddingRight = `${previousBodyPadding}px`;
        previousBodyPadding = null;
      }
    };
    function removePopupAndResetState(instance, container, returnFocus, didClose) {
      if (isToast()) {
        triggerDidCloseAndDispose(instance, didClose);
      } else {
        restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
        removeKeydownHandler(globalState);
      }
      if (isSafariOrIOS) {
        container.setAttribute("style", "display:none !important");
        container.removeAttribute("class");
        container.innerHTML = "";
      } else {
        container.remove();
      }
      if (isModal()) {
        undoReplaceScrollbarWithPadding();
        undoIOSfix();
        unsetAriaHidden();
      }
      removeBodyClasses();
    }
    function removeBodyClasses() {
      removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
    }
    function close(resolveValue) {
      resolveValue = prepareResolveValue(resolveValue);
      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
      const didClose = triggerClosePopup(this);
      if (this.isAwaitingPromise) {
        if (!resolveValue.isDismissed) {
          handleAwaitingPromise(this);
          swalPromiseResolve(resolveValue);
        }
      } else if (didClose) {
        swalPromiseResolve(resolveValue);
      }
    }
    const triggerClosePopup = (instance) => {
      const popup = getPopup();
      if (!popup) {
        return false;
      }
      const innerParams = privateProps.innerParams.get(instance);
      if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
        return false;
      }
      removeClass(popup, innerParams.showClass.popup);
      addClass(popup, innerParams.hideClass.popup);
      const backdrop = getContainer();
      removeClass(backdrop, innerParams.showClass.backdrop);
      addClass(backdrop, innerParams.hideClass.backdrop);
      handlePopupAnimation(instance, popup, innerParams);
      return true;
    };
    function rejectPromise(error3) {
      const rejectPromise2 = privateMethods.swalPromiseReject.get(this);
      handleAwaitingPromise(this);
      if (rejectPromise2) {
        rejectPromise2(error3);
      }
    }
    const handleAwaitingPromise = (instance) => {
      if (instance.isAwaitingPromise) {
        delete instance.isAwaitingPromise;
        if (!privateProps.innerParams.get(instance)) {
          instance._destroy();
        }
      }
    };
    const prepareResolveValue = (resolveValue) => {
      if (typeof resolveValue === "undefined") {
        return {
          isConfirmed: false,
          isDenied: false,
          isDismissed: true
        };
      }
      return Object.assign({
        isConfirmed: false,
        isDenied: false,
        isDismissed: false
      }, resolveValue);
    };
    const handlePopupAnimation = (instance, popup, innerParams) => {
      var _globalState$eventEmi;
      const container = getContainer();
      const animationIsSupported = hasCssAnimation(popup);
      if (typeof innerParams.willClose === "function") {
        innerParams.willClose(popup);
      }
      (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === undefined || _globalState$eventEmi.emit("willClose", popup);
      if (animationIsSupported) {
        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
      } else {
        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
      }
    };
    const animatePopup = (instance, popup, container, returnFocus, didClose) => {
      globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
      const swalCloseAnimationFinished = function(e) {
        if (e.target === popup) {
          var _globalState$swalClos;
          (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === undefined || _globalState$swalClos.call(globalState);
          delete globalState.swalCloseEventFinishedCallback;
          popup.removeEventListener("animationend", swalCloseAnimationFinished);
          popup.removeEventListener("transitionend", swalCloseAnimationFinished);
        }
      };
      popup.addEventListener("animationend", swalCloseAnimationFinished);
      popup.addEventListener("transitionend", swalCloseAnimationFinished);
    };
    const triggerDidCloseAndDispose = (instance, didClose) => {
      setTimeout(() => {
        var _globalState$eventEmi2;
        if (typeof didClose === "function") {
          didClose.bind(instance.params)();
        }
        (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === undefined || _globalState$eventEmi2.emit("didClose");
        if (instance._destroy) {
          instance._destroy();
        }
      });
    };
    const showLoading = (buttonToReplace) => {
      let popup = getPopup();
      if (!popup) {
        new Swal;
      }
      popup = getPopup();
      if (!popup) {
        return;
      }
      const loader = getLoader();
      if (isToast()) {
        hide(getIcon());
      } else {
        replaceButton(popup, buttonToReplace);
      }
      show(loader);
      popup.setAttribute("data-loading", "true");
      popup.setAttribute("aria-busy", "true");
      popup.focus();
    };
    const replaceButton = (popup, buttonToReplace) => {
      const actions = getActions();
      const loader = getLoader();
      if (!actions || !loader) {
        return;
      }
      if (!buttonToReplace && isVisible$1(getConfirmButton())) {
        buttonToReplace = getConfirmButton();
      }
      show(actions);
      if (buttonToReplace) {
        hide(buttonToReplace);
        loader.setAttribute("data-button-to-replace", buttonToReplace.className);
        actions.insertBefore(loader, buttonToReplace);
      }
      addClass([popup, actions], swalClasses.loading);
    };
    const handleInputOptionsAndValue = (instance, params) => {
      if (params.input === "select" || params.input === "radio") {
        handleInputOptions(instance, params);
      } else if (["text", "email", "number", "tel", "textarea"].some((i) => i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
        showLoading(getConfirmButton());
        handleInputValue(instance, params);
      }
    };
    const getInputValue = (instance, innerParams) => {
      const input = instance.getInput();
      if (!input) {
        return null;
      }
      switch (innerParams.input) {
        case "checkbox":
          return getCheckboxValue(input);
        case "radio":
          return getRadioValue(input);
        case "file":
          return getFileValue(input);
        default:
          return innerParams.inputAutoTrim ? input.value.trim() : input.value;
      }
    };
    const getCheckboxValue = (input) => input.checked ? 1 : 0;
    const getRadioValue = (input) => input.checked ? input.value : null;
    const getFileValue = (input) => input.files && input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
    const handleInputOptions = (instance, params) => {
      const popup = getPopup();
      if (!popup) {
        return;
      }
      const processInputOptions = (inputOptions) => {
        if (params.input === "select") {
          populateSelectOptions(popup, formatInputOptions(inputOptions), params);
        } else if (params.input === "radio") {
          populateRadioOptions(popup, formatInputOptions(inputOptions), params);
        }
      };
      if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
        showLoading(getConfirmButton());
        asPromise(params.inputOptions).then((inputOptions) => {
          instance.hideLoading();
          processInputOptions(inputOptions);
        });
      } else if (typeof params.inputOptions === "object") {
        processInputOptions(params.inputOptions);
      } else {
        error2(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
      }
    };
    const handleInputValue = (instance, params) => {
      const input = instance.getInput();
      if (!input) {
        return;
      }
      hide(input);
      asPromise(params.inputValue).then((inputValue) => {
        input.value = params.input === "number" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
        show(input);
        input.focus();
        instance.hideLoading();
      }).catch((err) => {
        error2(`Error in inputValue promise: ${err}`);
        input.value = "";
        show(input);
        input.focus();
        instance.hideLoading();
      });
    };
    function populateSelectOptions(popup, inputOptions, params) {
      const select = getDirectChildByClass(popup, swalClasses.select);
      if (!select) {
        return;
      }
      const renderOption = (parent, optionLabel, optionValue) => {
        const option = document.createElement("option");
        option.value = optionValue;
        setInnerHtml(option, optionLabel);
        option.selected = isSelected(optionValue, params.inputValue);
        parent.appendChild(option);
      };
      inputOptions.forEach((inputOption) => {
        const optionValue = inputOption[0];
        const optionLabel = inputOption[1];
        if (Array.isArray(optionLabel)) {
          const optgroup = document.createElement("optgroup");
          optgroup.label = optionValue;
          optgroup.disabled = false;
          select.appendChild(optgroup);
          optionLabel.forEach((o) => renderOption(optgroup, o[1], o[0]));
        } else {
          renderOption(select, optionLabel, optionValue);
        }
      });
      select.focus();
    }
    function populateRadioOptions(popup, inputOptions, params) {
      const radio = getDirectChildByClass(popup, swalClasses.radio);
      if (!radio) {
        return;
      }
      inputOptions.forEach((inputOption) => {
        const radioValue = inputOption[0];
        const radioLabel = inputOption[1];
        const radioInput = document.createElement("input");
        const radioLabelElement = document.createElement("label");
        radioInput.type = "radio";
        radioInput.name = swalClasses.radio;
        radioInput.value = radioValue;
        if (isSelected(radioValue, params.inputValue)) {
          radioInput.checked = true;
        }
        const label = document.createElement("span");
        setInnerHtml(label, radioLabel);
        label.className = swalClasses.label;
        radioLabelElement.appendChild(radioInput);
        radioLabelElement.appendChild(label);
        radio.appendChild(radioLabelElement);
      });
      const radios = radio.querySelectorAll("input");
      if (radios.length) {
        radios[0].focus();
      }
    }
    const formatInputOptions = (inputOptions) => {
      const result = [];
      if (inputOptions instanceof Map) {
        inputOptions.forEach((value, key) => {
          let valueFormatted = value;
          if (typeof valueFormatted === "object") {
            valueFormatted = formatInputOptions(valueFormatted);
          }
          result.push([key, valueFormatted]);
        });
      } else {
        Object.keys(inputOptions).forEach((key) => {
          let valueFormatted = inputOptions[key];
          if (typeof valueFormatted === "object") {
            valueFormatted = formatInputOptions(valueFormatted);
          }
          result.push([key, valueFormatted]);
        });
      }
      return result;
    };
    const isSelected = (optionValue, inputValue) => {
      return !!inputValue && inputValue.toString() === optionValue.toString();
    };
    const handleConfirmButtonClick = (instance) => {
      const innerParams = privateProps.innerParams.get(instance);
      instance.disableButtons();
      if (innerParams.input) {
        handleConfirmOrDenyWithInput(instance, "confirm");
      } else {
        confirm2(instance, true);
      }
    };
    const handleDenyButtonClick = (instance) => {
      const innerParams = privateProps.innerParams.get(instance);
      instance.disableButtons();
      if (innerParams.returnInputValueOnDeny) {
        handleConfirmOrDenyWithInput(instance, "deny");
      } else {
        deny(instance, false);
      }
    };
    const handleCancelButtonClick = (instance, dismissWith) => {
      instance.disableButtons();
      dismissWith(DismissReason.cancel);
    };
    const handleConfirmOrDenyWithInput = (instance, type) => {
      const innerParams = privateProps.innerParams.get(instance);
      if (!innerParams.input) {
        error2(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
        return;
      }
      const input = instance.getInput();
      const inputValue = getInputValue(instance, innerParams);
      if (innerParams.inputValidator) {
        handleInputValidator(instance, inputValue, type);
      } else if (input && !input.checkValidity()) {
        instance.enableButtons();
        instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
      } else if (type === "deny") {
        deny(instance, inputValue);
      } else {
        confirm2(instance, inputValue);
      }
    };
    const handleInputValidator = (instance, inputValue, type) => {
      const innerParams = privateProps.innerParams.get(instance);
      instance.disableInput();
      const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
      validationPromise.then((validationMessage) => {
        instance.enableButtons();
        instance.enableInput();
        if (validationMessage) {
          instance.showValidationMessage(validationMessage);
        } else if (type === "deny") {
          deny(instance, inputValue);
        } else {
          confirm2(instance, inputValue);
        }
      });
    };
    const deny = (instance, value) => {
      const innerParams = privateProps.innerParams.get(instance || undefined);
      if (innerParams.showLoaderOnDeny) {
        showLoading(getDenyButton());
      }
      if (innerParams.preDeny) {
        instance.isAwaitingPromise = true;
        const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
        preDenyPromise.then((preDenyValue) => {
          if (preDenyValue === false) {
            instance.hideLoading();
            handleAwaitingPromise(instance);
          } else {
            instance.close({
              isDenied: true,
              value: typeof preDenyValue === "undefined" ? value : preDenyValue
            });
          }
        }).catch((error3) => rejectWith(instance || undefined, error3));
      } else {
        instance.close({
          isDenied: true,
          value
        });
      }
    };
    const succeedWith = (instance, value) => {
      instance.close({
        isConfirmed: true,
        value
      });
    };
    const rejectWith = (instance, error3) => {
      instance.rejectPromise(error3);
    };
    const confirm2 = (instance, value) => {
      const innerParams = privateProps.innerParams.get(instance || undefined);
      if (innerParams.showLoaderOnConfirm) {
        showLoading();
      }
      if (innerParams.preConfirm) {
        instance.resetValidationMessage();
        instance.isAwaitingPromise = true;
        const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
        preConfirmPromise.then((preConfirmValue) => {
          if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
            instance.hideLoading();
            handleAwaitingPromise(instance);
          } else {
            succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
          }
        }).catch((error3) => rejectWith(instance || undefined, error3));
      } else {
        succeedWith(instance, value);
      }
    };
    function hideLoading() {
      const innerParams = privateProps.innerParams.get(this);
      if (!innerParams) {
        return;
      }
      const domCache = privateProps.domCache.get(this);
      hide(domCache.loader);
      if (isToast()) {
        if (innerParams.icon) {
          show(getIcon());
        }
      } else {
        showRelatedButton(domCache);
      }
      removeClass([domCache.popup, domCache.actions], swalClasses.loading);
      domCache.popup.removeAttribute("aria-busy");
      domCache.popup.removeAttribute("data-loading");
      domCache.confirmButton.disabled = false;
      domCache.denyButton.disabled = false;
      domCache.cancelButton.disabled = false;
    }
    const showRelatedButton = (domCache) => {
      const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
      if (buttonToReplace.length) {
        show(buttonToReplace[0], "inline-block");
      } else if (allButtonsAreHidden()) {
        hide(domCache.actions);
      }
    };
    function getInput() {
      const innerParams = privateProps.innerParams.get(this);
      const domCache = privateProps.domCache.get(this);
      if (!domCache) {
        return null;
      }
      return getInput$1(domCache.popup, innerParams.input);
    }
    function setButtonsDisabled(instance, buttons, disabled) {
      const domCache = privateProps.domCache.get(instance);
      buttons.forEach((button) => {
        domCache[button].disabled = disabled;
      });
    }
    function setInputDisabled(input, disabled) {
      const popup = getPopup();
      if (!popup || !input) {
        return;
      }
      if (input.type === "radio") {
        const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
        for (let i = 0;i < radios.length; i++) {
          radios[i].disabled = disabled;
        }
      } else {
        input.disabled = disabled;
      }
    }
    function enableButtons() {
      setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
    }
    function disableButtons() {
      setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
    }
    function enableInput() {
      setInputDisabled(this.getInput(), false);
    }
    function disableInput() {
      setInputDisabled(this.getInput(), true);
    }
    function showValidationMessage(error3) {
      const domCache = privateProps.domCache.get(this);
      const params = privateProps.innerParams.get(this);
      setInnerHtml(domCache.validationMessage, error3);
      domCache.validationMessage.className = swalClasses["validation-message"];
      if (params.customClass && params.customClass.validationMessage) {
        addClass(domCache.validationMessage, params.customClass.validationMessage);
      }
      show(domCache.validationMessage);
      const input = this.getInput();
      if (input) {
        input.setAttribute("aria-invalid", "true");
        input.setAttribute("aria-describedby", swalClasses["validation-message"]);
        focusInput(input);
        addClass(input, swalClasses.inputerror);
      }
    }
    function resetValidationMessage() {
      const domCache = privateProps.domCache.get(this);
      if (domCache.validationMessage) {
        hide(domCache.validationMessage);
      }
      const input = this.getInput();
      if (input) {
        input.removeAttribute("aria-invalid");
        input.removeAttribute("aria-describedby");
        removeClass(input, swalClasses.inputerror);
      }
    }
    const defaultParams = {
      title: "",
      titleText: "",
      text: "",
      html: "",
      footer: "",
      icon: undefined,
      iconColor: undefined,
      iconHtml: undefined,
      template: undefined,
      toast: false,
      draggable: false,
      animation: true,
      theme: "light",
      showClass: {
        popup: "swal2-show",
        backdrop: "swal2-backdrop-show",
        icon: "swal2-icon-show"
      },
      hideClass: {
        popup: "swal2-hide",
        backdrop: "swal2-backdrop-hide",
        icon: "swal2-icon-hide"
      },
      customClass: {},
      target: "body",
      color: undefined,
      backdrop: true,
      heightAuto: true,
      allowOutsideClick: true,
      allowEscapeKey: true,
      allowEnterKey: true,
      stopKeydownPropagation: true,
      keydownListenerCapture: false,
      showConfirmButton: true,
      showDenyButton: false,
      showCancelButton: false,
      preConfirm: undefined,
      preDeny: undefined,
      confirmButtonText: "OK",
      confirmButtonAriaLabel: "",
      confirmButtonColor: undefined,
      denyButtonText: "No",
      denyButtonAriaLabel: "",
      denyButtonColor: undefined,
      cancelButtonText: "Cancel",
      cancelButtonAriaLabel: "",
      cancelButtonColor: undefined,
      buttonsStyling: true,
      reverseButtons: false,
      focusConfirm: true,
      focusDeny: false,
      focusCancel: false,
      returnFocus: true,
      showCloseButton: false,
      closeButtonHtml: "&times;",
      closeButtonAriaLabel: "Close this dialog",
      loaderHtml: "",
      showLoaderOnConfirm: false,
      showLoaderOnDeny: false,
      imageUrl: undefined,
      imageWidth: undefined,
      imageHeight: undefined,
      imageAlt: "",
      timer: undefined,
      timerProgressBar: false,
      width: undefined,
      padding: undefined,
      background: undefined,
      input: undefined,
      inputPlaceholder: "",
      inputLabel: "",
      inputValue: "",
      inputOptions: {},
      inputAutoFocus: true,
      inputAutoTrim: true,
      inputAttributes: {},
      inputValidator: undefined,
      returnInputValueOnDeny: false,
      validationMessage: undefined,
      grow: false,
      position: "center",
      progressSteps: [],
      currentProgressStep: undefined,
      progressStepsDistance: undefined,
      willOpen: undefined,
      didOpen: undefined,
      didRender: undefined,
      willClose: undefined,
      didClose: undefined,
      didDestroy: undefined,
      scrollbarPadding: true,
      topLayer: false
    };
    const updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "draggable", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "theme", "willClose"];
    const deprecatedParams = {
      allowEnterKey: undefined
    };
    const toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "draggable", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
    const isValidParameter = (paramName) => {
      return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
    };
    const isUpdatableParameter = (paramName) => {
      return updatableParams.indexOf(paramName) !== -1;
    };
    const isDeprecatedParameter = (paramName) => {
      return deprecatedParams[paramName];
    };
    const checkIfParamIsValid = (param) => {
      if (!isValidParameter(param)) {
        warn2(`Unknown parameter "${param}"`);
      }
    };
    const checkIfToastParamIsValid = (param) => {
      if (toastIncompatibleParams.includes(param)) {
        warn2(`The parameter "${param}" is incompatible with toasts`);
      }
    };
    const checkIfParamIsDeprecated = (param) => {
      const isDeprecated = isDeprecatedParameter(param);
      if (isDeprecated) {
        warnAboutDeprecation(param, isDeprecated);
      }
    };
    const showWarningsForParams = (params) => {
      if (params.backdrop === false && params.allowOutsideClick) {
        warn2('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
      }
      if (params.theme && !["light", "dark", "auto", "minimal", "borderless", "embed-iframe", "bulma", "bulma-light", "bulma-dark"].includes(params.theme)) {
        warn2(`Invalid theme "${params.theme}"`);
      }
      for (const param in params) {
        checkIfParamIsValid(param);
        if (params.toast) {
          checkIfToastParamIsValid(param);
        }
        checkIfParamIsDeprecated(param);
      }
    };
    function update(params) {
      const container = getContainer();
      const popup = getPopup();
      const innerParams = privateProps.innerParams.get(this);
      if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
        warn2(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
        return;
      }
      const validUpdatableParams = filterValidParams(params);
      const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
      showWarningsForParams(updatedParams);
      container.dataset["swal2Theme"] = updatedParams.theme;
      render(this, updatedParams);
      privateProps.innerParams.set(this, updatedParams);
      Object.defineProperties(this, {
        params: {
          value: Object.assign({}, this.params, params),
          writable: false,
          enumerable: true
        }
      });
    }
    const filterValidParams = (params) => {
      const validUpdatableParams = {};
      Object.keys(params).forEach((param) => {
        if (isUpdatableParameter(param)) {
          validUpdatableParams[param] = params[param];
        } else {
          warn2(`Invalid parameter to update: ${param}`);
        }
      });
      return validUpdatableParams;
    };
    function _destroy() {
      const domCache = privateProps.domCache.get(this);
      const innerParams = privateProps.innerParams.get(this);
      if (!innerParams) {
        disposeWeakMaps(this);
        return;
      }
      if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
        globalState.swalCloseEventFinishedCallback();
        delete globalState.swalCloseEventFinishedCallback;
      }
      if (typeof innerParams.didDestroy === "function") {
        innerParams.didDestroy();
      }
      globalState.eventEmitter.emit("didDestroy");
      disposeSwal(this);
    }
    const disposeSwal = (instance) => {
      disposeWeakMaps(instance);
      delete instance.params;
      delete globalState.keydownHandler;
      delete globalState.keydownTarget;
      delete globalState.currentInstance;
    };
    const disposeWeakMaps = (instance) => {
      if (instance.isAwaitingPromise) {
        unsetWeakMaps(privateProps, instance);
        instance.isAwaitingPromise = true;
      } else {
        unsetWeakMaps(privateMethods, instance);
        unsetWeakMaps(privateProps, instance);
        delete instance.isAwaitingPromise;
        delete instance.disableButtons;
        delete instance.enableButtons;
        delete instance.getInput;
        delete instance.disableInput;
        delete instance.enableInput;
        delete instance.hideLoading;
        delete instance.disableLoading;
        delete instance.showValidationMessage;
        delete instance.resetValidationMessage;
        delete instance.close;
        delete instance.closePopup;
        delete instance.closeModal;
        delete instance.closeToast;
        delete instance.rejectPromise;
        delete instance.update;
        delete instance._destroy;
      }
    };
    const unsetWeakMaps = (obj, instance) => {
      for (const i in obj) {
        obj[i].delete(instance);
      }
    };
    var instanceMethods = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      _destroy,
      close,
      closeModal: close,
      closePopup: close,
      closeToast: close,
      disableButtons,
      disableInput,
      disableLoading: hideLoading,
      enableButtons,
      enableInput,
      getInput,
      handleAwaitingPromise,
      hideLoading,
      rejectPromise,
      resetValidationMessage,
      showValidationMessage,
      update
    });
    const handlePopupClick = (innerParams, domCache, dismissWith) => {
      if (innerParams.toast) {
        handleToastClick(innerParams, domCache, dismissWith);
      } else {
        handleModalMousedown(domCache);
        handleContainerMousedown(domCache);
        handleModalClick(innerParams, domCache, dismissWith);
      }
    };
    const handleToastClick = (innerParams, domCache, dismissWith) => {
      domCache.popup.onclick = () => {
        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
          return;
        }
        dismissWith(DismissReason.close);
      };
    };
    const isAnyButtonShown = (innerParams) => {
      return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
    };
    let ignoreOutsideClick = false;
    const handleModalMousedown = (domCache) => {
      domCache.popup.onmousedown = () => {
        domCache.container.onmouseup = function(e) {
          domCache.container.onmouseup = () => {};
          if (e.target === domCache.container) {
            ignoreOutsideClick = true;
          }
        };
      };
    };
    const handleContainerMousedown = (domCache) => {
      domCache.container.onmousedown = (e) => {
        if (e.target === domCache.container) {
          e.preventDefault();
        }
        domCache.popup.onmouseup = function(e2) {
          domCache.popup.onmouseup = () => {};
          if (e2.target === domCache.popup || e2.target instanceof HTMLElement && domCache.popup.contains(e2.target)) {
            ignoreOutsideClick = true;
          }
        };
      };
    };
    const handleModalClick = (innerParams, domCache, dismissWith) => {
      domCache.container.onclick = (e) => {
        if (ignoreOutsideClick) {
          ignoreOutsideClick = false;
          return;
        }
        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
          dismissWith(DismissReason.backdrop);
        }
      };
    };
    const isJqueryElement = (elem) => typeof elem === "object" && elem.jquery;
    const isElement = (elem) => elem instanceof Element || isJqueryElement(elem);
    const argsToParams = (args) => {
      const params = {};
      if (typeof args[0] === "object" && !isElement(args[0])) {
        Object.assign(params, args[0]);
      } else {
        ["title", "html", "icon"].forEach((name, index) => {
          const arg = args[index];
          if (typeof arg === "string" || isElement(arg)) {
            params[name] = arg;
          } else if (arg !== undefined) {
            error2(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
          }
        });
      }
      return params;
    };
    function fire(...args) {
      return new this(...args);
    }
    function mixin(mixinParams) {

      class MixinSwal extends this {
        _main(params, priorityMixinParams) {
          return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
        }
      }
      return MixinSwal;
    }
    const getTimerLeft = () => {
      return globalState.timeout && globalState.timeout.getTimerLeft();
    };
    const stopTimer = () => {
      if (globalState.timeout) {
        stopTimerProgressBar();
        return globalState.timeout.stop();
      }
    };
    const resumeTimer = () => {
      if (globalState.timeout) {
        const remaining = globalState.timeout.start();
        animateTimerProgressBar(remaining);
        return remaining;
      }
    };
    const toggleTimer = () => {
      const timer = globalState.timeout;
      return timer && (timer.running ? stopTimer() : resumeTimer());
    };
    const increaseTimer = (ms) => {
      if (globalState.timeout) {
        const remaining = globalState.timeout.increase(ms);
        animateTimerProgressBar(remaining, true);
        return remaining;
      }
    };
    const isTimerRunning = () => {
      return !!(globalState.timeout && globalState.timeout.isRunning());
    };
    let bodyClickListenerAdded = false;
    const clickHandlers = {};
    function bindClickHandler(attr = "data-swal-template") {
      clickHandlers[attr] = this;
      if (!bodyClickListenerAdded) {
        document.body.addEventListener("click", bodyClickListener);
        bodyClickListenerAdded = true;
      }
    }
    const bodyClickListener = (event) => {
      for (let el = event.target;el && el !== document; el = el.parentNode) {
        for (const attr in clickHandlers) {
          const template = el.getAttribute(attr);
          if (template) {
            clickHandlers[attr].fire({
              template
            });
            return;
          }
        }
      }
    };

    class EventEmitter {
      constructor() {
        this.events = {};
      }
      _getHandlersByEventName(eventName) {
        if (typeof this.events[eventName] === "undefined") {
          this.events[eventName] = [];
        }
        return this.events[eventName];
      }
      on(eventName, eventHandler) {
        const currentHandlers = this._getHandlersByEventName(eventName);
        if (!currentHandlers.includes(eventHandler)) {
          currentHandlers.push(eventHandler);
        }
      }
      once(eventName, eventHandler) {
        const onceFn = (...args) => {
          this.removeListener(eventName, onceFn);
          eventHandler.apply(this, args);
        };
        this.on(eventName, onceFn);
      }
      emit(eventName, ...args) {
        this._getHandlersByEventName(eventName).forEach((eventHandler) => {
          try {
            eventHandler.apply(this, args);
          } catch (error3) {
            console.error(error3);
          }
        });
      }
      removeListener(eventName, eventHandler) {
        const currentHandlers = this._getHandlersByEventName(eventName);
        const index = currentHandlers.indexOf(eventHandler);
        if (index > -1) {
          currentHandlers.splice(index, 1);
        }
      }
      removeAllListeners(eventName) {
        if (this.events[eventName] !== undefined) {
          this.events[eventName].length = 0;
        }
      }
      reset() {
        this.events = {};
      }
    }
    globalState.eventEmitter = new EventEmitter;
    const on = (eventName, eventHandler) => {
      globalState.eventEmitter.on(eventName, eventHandler);
    };
    const once = (eventName, eventHandler) => {
      globalState.eventEmitter.once(eventName, eventHandler);
    };
    const off = (eventName, eventHandler) => {
      if (!eventName) {
        globalState.eventEmitter.reset();
        return;
      }
      if (eventHandler) {
        globalState.eventEmitter.removeListener(eventName, eventHandler);
      } else {
        globalState.eventEmitter.removeAllListeners(eventName);
      }
    };
    var staticMethods = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      argsToParams,
      bindClickHandler,
      clickCancel,
      clickConfirm,
      clickDeny,
      enableLoading: showLoading,
      fire,
      getActions,
      getCancelButton,
      getCloseButton,
      getConfirmButton,
      getContainer,
      getDenyButton,
      getFocusableElements,
      getFooter,
      getHtmlContainer,
      getIcon,
      getIconContent,
      getImage,
      getInputLabel,
      getLoader,
      getPopup,
      getProgressSteps,
      getTimerLeft,
      getTimerProgressBar,
      getTitle,
      getValidationMessage,
      increaseTimer,
      isDeprecatedParameter,
      isLoading,
      isTimerRunning,
      isUpdatableParameter,
      isValidParameter,
      isVisible,
      mixin,
      off,
      on,
      once,
      resumeTimer,
      showLoading,
      stopTimer,
      toggleTimer
    });

    class Timer {
      constructor(callback, delay) {
        this.callback = callback;
        this.remaining = delay;
        this.running = false;
        this.start();
      }
      start() {
        if (!this.running) {
          this.running = true;
          this.started = new Date;
          this.id = setTimeout(this.callback, this.remaining);
        }
        return this.remaining;
      }
      stop() {
        if (this.started && this.running) {
          this.running = false;
          clearTimeout(this.id);
          this.remaining -= new Date().getTime() - this.started.getTime();
        }
        return this.remaining;
      }
      increase(n) {
        const running = this.running;
        if (running) {
          this.stop();
        }
        this.remaining += n;
        if (running) {
          this.start();
        }
        return this.remaining;
      }
      getTimerLeft() {
        if (this.running) {
          this.stop();
          this.start();
        }
        return this.remaining;
      }
      isRunning() {
        return this.running;
      }
    }
    const swalStringParams = ["swal-title", "swal-html", "swal-footer"];
    const getTemplateParams = (params) => {
      const template = typeof params.template === "string" ? document.querySelector(params.template) : params.template;
      if (!template) {
        return {};
      }
      const templateContent = template.content;
      showWarningsForElements(templateContent);
      const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
      return result;
    };
    const getSwalParams = (templateContent) => {
      const result = {};
      const swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
      swalParams.forEach((param) => {
        showWarningsForAttributes(param, ["name", "value"]);
        const paramName = param.getAttribute("name");
        const value = param.getAttribute("value");
        if (!paramName || !value) {
          return;
        }
        if (typeof defaultParams[paramName] === "boolean") {
          result[paramName] = value !== "false";
        } else if (typeof defaultParams[paramName] === "object") {
          result[paramName] = JSON.parse(value);
        } else {
          result[paramName] = value;
        }
      });
      return result;
    };
    const getSwalFunctionParams = (templateContent) => {
      const result = {};
      const swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
      swalFunctions.forEach((param) => {
        const paramName = param.getAttribute("name");
        const value = param.getAttribute("value");
        if (!paramName || !value) {
          return;
        }
        result[paramName] = new Function(`return ${value}`)();
      });
      return result;
    };
    const getSwalButtons = (templateContent) => {
      const result = {};
      const swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
      swalButtons.forEach((button) => {
        showWarningsForAttributes(button, ["type", "color", "aria-label"]);
        const type = button.getAttribute("type");
        if (!type || !["confirm", "cancel", "deny"].includes(type)) {
          return;
        }
        result[`${type}ButtonText`] = button.innerHTML;
        result[`show${capitalizeFirstLetter(type)}Button`] = true;
        if (button.hasAttribute("color")) {
          result[`${type}ButtonColor`] = button.getAttribute("color");
        }
        if (button.hasAttribute("aria-label")) {
          result[`${type}ButtonAriaLabel`] = button.getAttribute("aria-label");
        }
      });
      return result;
    };
    const getSwalImage = (templateContent) => {
      const result = {};
      const image = templateContent.querySelector("swal-image");
      if (image) {
        showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
        if (image.hasAttribute("src")) {
          result.imageUrl = image.getAttribute("src") || undefined;
        }
        if (image.hasAttribute("width")) {
          result.imageWidth = image.getAttribute("width") || undefined;
        }
        if (image.hasAttribute("height")) {
          result.imageHeight = image.getAttribute("height") || undefined;
        }
        if (image.hasAttribute("alt")) {
          result.imageAlt = image.getAttribute("alt") || undefined;
        }
      }
      return result;
    };
    const getSwalIcon = (templateContent) => {
      const result = {};
      const icon = templateContent.querySelector("swal-icon");
      if (icon) {
        showWarningsForAttributes(icon, ["type", "color"]);
        if (icon.hasAttribute("type")) {
          result.icon = icon.getAttribute("type");
        }
        if (icon.hasAttribute("color")) {
          result.iconColor = icon.getAttribute("color");
        }
        result.iconHtml = icon.innerHTML;
      }
      return result;
    };
    const getSwalInput = (templateContent) => {
      const result = {};
      const input = templateContent.querySelector("swal-input");
      if (input) {
        showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
        result.input = input.getAttribute("type") || "text";
        if (input.hasAttribute("label")) {
          result.inputLabel = input.getAttribute("label");
        }
        if (input.hasAttribute("placeholder")) {
          result.inputPlaceholder = input.getAttribute("placeholder");
        }
        if (input.hasAttribute("value")) {
          result.inputValue = input.getAttribute("value");
        }
      }
      const inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
      if (inputOptions.length) {
        result.inputOptions = {};
        inputOptions.forEach((option) => {
          showWarningsForAttributes(option, ["value"]);
          const optionValue = option.getAttribute("value");
          if (!optionValue) {
            return;
          }
          const optionName = option.innerHTML;
          result.inputOptions[optionValue] = optionName;
        });
      }
      return result;
    };
    const getSwalStringParams = (templateContent, paramNames) => {
      const result = {};
      for (const i in paramNames) {
        const paramName = paramNames[i];
        const tag = templateContent.querySelector(paramName);
        if (tag) {
          showWarningsForAttributes(tag, []);
          result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
        }
      }
      return result;
    };
    const showWarningsForElements = (templateContent) => {
      const allowedElements = swalStringParams.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
      Array.from(templateContent.children).forEach((el) => {
        const tagName = el.tagName.toLowerCase();
        if (!allowedElements.includes(tagName)) {
          warn2(`Unrecognized element <${tagName}>`);
        }
      });
    };
    const showWarningsForAttributes = (el, allowedAttributes) => {
      Array.from(el.attributes).forEach((attribute) => {
        if (allowedAttributes.indexOf(attribute.name) === -1) {
          warn2([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(", ")}` : "To set the value, use HTML within the element."}`]);
        }
      });
    };
    const SHOW_CLASS_TIMEOUT = 10;
    const openPopup = (params) => {
      const container = getContainer();
      const popup = getPopup();
      if (typeof params.willOpen === "function") {
        params.willOpen(popup);
      }
      globalState.eventEmitter.emit("willOpen", popup);
      const bodyStyles = window.getComputedStyle(document.body);
      const initialBodyOverflow = bodyStyles.overflowY;
      addClasses(container, popup, params);
      setTimeout(() => {
        setScrollingVisibility(container, popup);
      }, SHOW_CLASS_TIMEOUT);
      if (isModal()) {
        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
        setAriaHidden();
      }
      if (!isToast() && !globalState.previousActiveElement) {
        globalState.previousActiveElement = document.activeElement;
      }
      if (typeof params.didOpen === "function") {
        setTimeout(() => params.didOpen(popup));
      }
      globalState.eventEmitter.emit("didOpen", popup);
      removeClass(container, swalClasses["no-transition"]);
    };
    const swalOpenAnimationFinished = (event) => {
      const popup = getPopup();
      if (event.target !== popup) {
        return;
      }
      const container = getContainer();
      popup.removeEventListener("animationend", swalOpenAnimationFinished);
      popup.removeEventListener("transitionend", swalOpenAnimationFinished);
      container.style.overflowY = "auto";
    };
    const setScrollingVisibility = (container, popup) => {
      if (hasCssAnimation(popup)) {
        container.style.overflowY = "hidden";
        popup.addEventListener("animationend", swalOpenAnimationFinished);
        popup.addEventListener("transitionend", swalOpenAnimationFinished);
      } else {
        container.style.overflowY = "auto";
      }
    };
    const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
      iOSfix();
      if (scrollbarPadding && initialBodyOverflow !== "hidden") {
        replaceScrollbarWithPadding(initialBodyOverflow);
      }
      setTimeout(() => {
        container.scrollTop = 0;
      });
    };
    const addClasses = (container, popup, params) => {
      addClass(container, params.showClass.backdrop);
      if (params.animation) {
        popup.style.setProperty("opacity", "0", "important");
        show(popup, "grid");
        setTimeout(() => {
          addClass(popup, params.showClass.popup);
          popup.style.removeProperty("opacity");
        }, SHOW_CLASS_TIMEOUT);
      } else {
        show(popup, "grid");
      }
      addClass([document.documentElement, document.body], swalClasses.shown);
      if (params.heightAuto && params.backdrop && !params.toast) {
        addClass([document.documentElement, document.body], swalClasses["height-auto"]);
      }
    };
    var defaultInputValidators = {
      email: (string, validationMessage) => {
        return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
      },
      url: (string, validationMessage) => {
        return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
      }
    };
    function setDefaultInputValidators(params) {
      if (params.inputValidator) {
        return;
      }
      if (params.input === "email") {
        params.inputValidator = defaultInputValidators["email"];
      }
      if (params.input === "url") {
        params.inputValidator = defaultInputValidators["url"];
      }
    }
    function validateCustomTargetElement(params) {
      if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
        warn2('Target parameter is not valid, defaulting to "body"');
        params.target = "body";
      }
    }
    function setParameters(params) {
      setDefaultInputValidators(params);
      if (params.showLoaderOnConfirm && !params.preConfirm) {
        warn2(`showLoaderOnConfirm is set to true, but preConfirm is not defined.
` + `showLoaderOnConfirm should be used together with preConfirm, see usage example:
` + "https://sweetalert2.github.io/#ajax-request");
      }
      validateCustomTargetElement(params);
      if (typeof params.title === "string") {
        params.title = params.title.split(`
`).join("<br />");
      }
      init(params);
    }
    let currentInstance;
    var _promise = /* @__PURE__ */ new WeakMap;

    class SweetAlert {
      constructor(...args) {
        _classPrivateFieldInitSpec(this, _promise, undefined);
        if (typeof window === "undefined") {
          return;
        }
        currentInstance = this;
        const outerParams = Object.freeze(this.constructor.argsToParams(args));
        this.params = outerParams;
        this.isAwaitingPromise = false;
        _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
      }
      _main(userParams, mixinParams = {}) {
        showWarningsForParams(Object.assign({}, mixinParams, userParams));
        if (globalState.currentInstance) {
          const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
          const {
            isAwaitingPromise
          } = globalState.currentInstance;
          globalState.currentInstance._destroy();
          if (!isAwaitingPromise) {
            swalPromiseResolve({
              isDismissed: true
            });
          }
          if (isModal()) {
            unsetAriaHidden();
          }
        }
        globalState.currentInstance = currentInstance;
        const innerParams = prepareParams(userParams, mixinParams);
        setParameters(innerParams);
        Object.freeze(innerParams);
        if (globalState.timeout) {
          globalState.timeout.stop();
          delete globalState.timeout;
        }
        clearTimeout(globalState.restoreFocusTimeout);
        const domCache = populateDomCache(currentInstance);
        render(currentInstance, innerParams);
        privateProps.innerParams.set(currentInstance, innerParams);
        return swalPromise(currentInstance, domCache, innerParams);
      }
      then(onFulfilled) {
        return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
      }
      finally(onFinally) {
        return _classPrivateFieldGet2(_promise, this).finally(onFinally);
      }
    }
    const swalPromise = (instance, domCache, innerParams) => {
      return new Promise((resolve, reject) => {
        const dismissWith = (dismiss) => {
          instance.close({
            isDismissed: true,
            dismiss
          });
        };
        privateMethods.swalPromiseResolve.set(instance, resolve);
        privateMethods.swalPromiseReject.set(instance, reject);
        domCache.confirmButton.onclick = () => {
          handleConfirmButtonClick(instance);
        };
        domCache.denyButton.onclick = () => {
          handleDenyButtonClick(instance);
        };
        domCache.cancelButton.onclick = () => {
          handleCancelButtonClick(instance, dismissWith);
        };
        domCache.closeButton.onclick = () => {
          dismissWith(DismissReason.close);
        };
        handlePopupClick(innerParams, domCache, dismissWith);
        addKeydownHandler(globalState, innerParams, dismissWith);
        handleInputOptionsAndValue(instance, innerParams);
        openPopup(innerParams);
        setupTimer(globalState, innerParams, dismissWith);
        initFocus(domCache, innerParams);
        setTimeout(() => {
          domCache.container.scrollTop = 0;
        });
      });
    };
    const prepareParams = (userParams, mixinParams) => {
      const templateParams = getTemplateParams(userParams);
      const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
      params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
      params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
      if (params.animation === false) {
        params.showClass = {
          backdrop: "swal2-noanimation"
        };
        params.hideClass = {};
      }
      return params;
    };
    const populateDomCache = (instance) => {
      const domCache = {
        popup: getPopup(),
        container: getContainer(),
        actions: getActions(),
        confirmButton: getConfirmButton(),
        denyButton: getDenyButton(),
        cancelButton: getCancelButton(),
        loader: getLoader(),
        closeButton: getCloseButton(),
        validationMessage: getValidationMessage(),
        progressSteps: getProgressSteps()
      };
      privateProps.domCache.set(instance, domCache);
      return domCache;
    };
    const setupTimer = (globalState2, innerParams, dismissWith) => {
      const timerProgressBar = getTimerProgressBar();
      hide(timerProgressBar);
      if (innerParams.timer) {
        globalState2.timeout = new Timer(() => {
          dismissWith("timer");
          delete globalState2.timeout;
        }, innerParams.timer);
        if (innerParams.timerProgressBar) {
          show(timerProgressBar);
          applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
          setTimeout(() => {
            if (globalState2.timeout && globalState2.timeout.running) {
              animateTimerProgressBar(innerParams.timer);
            }
          });
        }
      }
    };
    const initFocus = (domCache, innerParams) => {
      if (innerParams.toast) {
        return;
      }
      if (!callIfFunction(innerParams.allowEnterKey)) {
        warnAboutDeprecation("allowEnterKey");
        blurActiveElement();
        return;
      }
      if (focusAutofocus(domCache)) {
        return;
      }
      if (focusButton(domCache, innerParams)) {
        return;
      }
      setFocus(-1, 1);
    };
    const focusAutofocus = (domCache) => {
      const autofocusElements = Array.from(domCache.popup.querySelectorAll("[autofocus]"));
      for (const autofocusElement of autofocusElements) {
        if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
          autofocusElement.focus();
          return true;
        }
      }
      return false;
    };
    const focusButton = (domCache, innerParams) => {
      if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
        domCache.denyButton.focus();
        return true;
      }
      if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
        domCache.cancelButton.focus();
        return true;
      }
      if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
        domCache.confirmButton.focus();
        return true;
      }
      return false;
    };
    const blurActiveElement = () => {
      if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
        document.activeElement.blur();
      }
    };
    SweetAlert.prototype.disableButtons = disableButtons;
    SweetAlert.prototype.enableButtons = enableButtons;
    SweetAlert.prototype.getInput = getInput;
    SweetAlert.prototype.disableInput = disableInput;
    SweetAlert.prototype.enableInput = enableInput;
    SweetAlert.prototype.hideLoading = hideLoading;
    SweetAlert.prototype.disableLoading = hideLoading;
    SweetAlert.prototype.showValidationMessage = showValidationMessage;
    SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
    SweetAlert.prototype.close = close;
    SweetAlert.prototype.closePopup = close;
    SweetAlert.prototype.closeModal = close;
    SweetAlert.prototype.closeToast = close;
    SweetAlert.prototype.rejectPromise = rejectPromise;
    SweetAlert.prototype.update = update;
    SweetAlert.prototype._destroy = _destroy;
    Object.assign(SweetAlert, staticMethods);
    Object.keys(instanceMethods).forEach((key) => {
      SweetAlert[key] = function(...args) {
        if (currentInstance && currentInstance[key]) {
          return currentInstance[key](...args);
        }
        return null;
      };
    });
    SweetAlert.DismissReason = DismissReason;
    SweetAlert.version = "11.23.0";
    const Swal = SweetAlert;
    Swal.default = Swal;
    return Swal;
  });
  if (typeof exports !== "undefined" && exports.Sweetalert2) {
    exports.swal = exports.sweetAlert = exports.Swal = exports.SweetAlert = exports.Sweetalert2;
  }
  typeof document != "undefined" && function(e, t) {
    var n = e.createElement("style");
    if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet)
      n.styleSheet.disabled || (n.styleSheet.cssText = t);
    else
      try {
        n.innerHTML = t;
      } catch (e2) {
        n.innerText = t;
      }
  }(document, ":root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.1s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border: 1px solid #d9d9d9;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.2s, box-shadow 0.2s;--swal2-input-hover-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-focus-border: 1px solid #b4dbed;--swal2-input-focus-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px $swal2-outline-color;--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-footer-border-color: #eee;--swal2-footer-background: transparent;--swal2-footer-color: inherit;--swal2-timer-progress-bar-background: rgba(0, 0, 0, 0.3);--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.2s, box-shadow 0.2s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-actions-justify-content: center;--swal2-actions-width: auto;--swal2-actions-margin: 1.25em auto 0;--swal2-actions-padding: 0;--swal2-actions-border-radius: 0;--swal2-actions-background: transparent;--swal2-action-button-transition: background-color 0.2s, box-shadow 0.2s;--swal2-action-button-hover: black 10%;--swal2-action-button-active: black 10%;--swal2-confirm-button-box-shadow: none;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-confirm-button-color: #fff;--swal2-deny-button-box-shadow: none;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-deny-button-color: #fff;--swal2-cancel-button-box-shadow: none;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-cancel-button-color: #fff;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white);--swal2-timer-progress-bar-background: rgba(255, 255, 255, 0.7)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;overflow-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:var(--swal2-actions-justify-content);width:var(--swal2-actions-width);margin:var(--swal2-actions-margin);padding:var(--swal2-actions-padding);border-radius:var(--swal2-actions-border-radius);background:var(--swal2-actions-background)}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-action-button-transition);border:none;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);box-shadow:var(--swal2-confirm-button-box-shadow);color:var(--swal2-confirm-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):hover{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):active{background-color:color-mix(in srgb, var(--swal2-confirm-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);box-shadow:var(--swal2-deny-button-box-shadow);color:var(--swal2-deny-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):hover{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):active{background-color:color-mix(in srgb, var(--swal2-deny-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);box-shadow:var(--swal2-cancel-button-box-shadow);color:var(--swal2-cancel-button-color);font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):hover{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-hover))}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):active{background-color:color-mix(in srgb, var(--swal2-cancel-button-background-color), var(--swal2-action-button-active))}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-styled)[disabled]:not(.swal2-loading){opacity:.4}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);background:var(--swal2-footer-background);color:var(--swal2-footer-color);font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:var(--swal2-timer-progress-bar-background)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;overflow-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:var(--swal2-input-border);border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):hover,div:where(.swal2-container) input:where(.swal2-file):hover,div:where(.swal2-container) textarea:where(.swal2-textarea):hover{box-shadow:var(--swal2-input-hover-box-shadow)}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:var(--swal2-input-focus-border);outline:none;box-shadow:var(--swal2-input-focus-box-shadow)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}");
});

// node_modules/smart-timeout/lib/timeout.js
var require_timeout = __commonJS((exports) => {
  var __spreadArrays = exports && exports.__spreadArrays || function() {
    for (var s3 = 0, i3 = 0, il = arguments.length;i3 < il; i3++)
      s3 += arguments[i3].length;
    for (var r3 = Array(s3), k3 = 0, i3 = 0;i3 < il; i3++)
      for (var a3 = arguments[i3], j4 = 0, jl = a3.length;j4 < jl; j4++, k3++)
        r3[k3] = a3[j4];
    return r3;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MetadataRecord = function() {
    function MetadataRecord2(callback, key, ms, params) {
      this.callback = callback;
      this.key = key;
      this.ms = ms;
      this.params = params;
      this.paused = false;
      this.startTime = new Date().getTime();
      this.timeSpentWaiting = 0;
    }
    return MetadataRecord2;
  }();
  var Timeout = function() {
    function Timeout2() {}
    Timeout2.clear = function(key, erase) {
      if (erase === undefined) {
        erase = true;
      }
      clearTimeout(Timeout2.keyId[key]);
      delete Timeout2.keyId[key];
      delete Timeout2.keyCall[key];
      if (erase) {
        delete Timeout2.metadata[key];
        delete Timeout2.originalMs[key];
      }
    };
    Timeout2.set = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key;
      var ms;
      var params;
      var callback;
      if (args.length === 0) {
        throw Error("Timeout.set() requires at least one argument");
      }
      if (typeof args[1] === "function") {
        key = args[0], callback = args[1], ms = args[2], params = args.slice(3);
      } else {
        callback = args[0], ms = args[1], params = args.slice(2);
        key = callback.toString();
      }
      if (!callback) {
        throw Error("Timeout.set() requires a callback parameter");
      }
      Timeout2.clear(key);
      var invoke = function() {
        Timeout2.metadata[key].executedTime = new Date().getTime();
        callback.apply(undefined, params);
      };
      Timeout2.keyId[key] = setTimeout(invoke, ms || 0);
      Timeout2.keyCall[key] = function() {
        return callback.apply(undefined, params);
      };
      Timeout2.originalMs[key] = Timeout2.originalMs[key] || ms;
      Timeout2.metadata[key] = new MetadataRecord(callback, key, ms, params);
      return function() {
        return Timeout2.executed(key);
      };
    };
    Timeout2.create = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (args.length === 0) {
        throw Error("Timeout.create() requires at least one argument");
      }
      var key;
      if (typeof args[1] === "function") {
        key = args[0];
      } else {
        var callback = args[0];
        key = callback.toString();
      }
      return Timeout2.exists(key) ? false : Timeout2.set.apply(Timeout2, args);
    };
    Timeout2.elapsed = function(key) {
      var metaDataRecord = Timeout2.metadata[key];
      if (!metaDataRecord)
        return 0;
      return Math.max(0, new Date().getTime() - metaDataRecord.startTime);
    };
    Timeout2.exists = function(key) {
      return key in Timeout2.keyId || Timeout2.metadata[key] !== undefined;
    };
    Timeout2.call = function(key) {
      return Timeout2.exists(key) && Timeout2.keyCall[key]();
    };
    Timeout2.executed = function(key) {
      return Timeout2.exists(key) && !!Timeout2.metadata[key].executedTime;
    };
    Timeout2.lastExecuted = function(key) {
      return !Timeout2.executed(key) ? null : new Date(Timeout2.metadata[key].executedTime);
    };
    Timeout2.meta = function(key) {
      return Timeout2.metadata[key];
    };
    Timeout2.pending = function(key) {
      return Timeout2.exists(key) && !Timeout2.executed(key);
    };
    Timeout2.paused = function(key) {
      return Timeout2.exists(key) && !Timeout2.executed(key) && Timeout2.metadata[key].paused;
    };
    Timeout2.remaining = function(key) {
      if (!Timeout2.metadata[key])
        return 0;
      var metaDataRecord = Timeout2.metadata[key];
      return Timeout2.paused(key) ? metaDataRecord.ms - metaDataRecord.timeSpentWaiting : Math.max(0, metaDataRecord.startTime + metaDataRecord.ms - new Date().getTime());
    };
    Timeout2.reset = function(key, ms) {
      var params = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        params[_i - 2] = arguments[_i];
      }
      var metaDataRecord = Timeout2.metadata[key];
      if (!metaDataRecord)
        return false;
      Timeout2.clear(key, false);
      if (metaDataRecord.paused) {
        metaDataRecord.paused = false;
      }
      return Timeout2.set.apply(Timeout2, __spreadArrays([
        key,
        metaDataRecord.callback,
        ms !== null && ms !== undefined ? ms : Timeout2.originalMs[key]
      ], params || metaDataRecord.params));
    };
    Timeout2.restart = function(key, force) {
      if (force === undefined) {
        force = false;
      }
      if (!Timeout2.metadata[key] || !force && Timeout2.executed(key))
        return false;
      var metaDataRecord = Timeout2.metadata[key];
      Timeout2.clear(key, false);
      if (metaDataRecord.paused) {
        metaDataRecord.paused = false;
      }
      return Timeout2.set.apply(Timeout2, __spreadArrays([key, metaDataRecord.callback, Timeout2.originalMs[key]], metaDataRecord.params));
    };
    Timeout2.pause = function(key) {
      if (!Timeout2.metadata[key] || Timeout2.paused(key) || Timeout2.executed(key))
        return false;
      Timeout2.clear(key, false);
      var metaDataRecord = Timeout2.metadata[key];
      metaDataRecord.paused = true;
      metaDataRecord.timeSpentWaiting = new Date().getTime() - metaDataRecord.startTime;
      return metaDataRecord.timeSpentWaiting;
    };
    Timeout2.resume = function(key) {
      if (!Timeout2.metadata[key] || Timeout2.executed(key))
        return false;
      var metaDataRecord = Timeout2.metadata[key];
      if (!metaDataRecord.paused)
        return false;
      var originalMs = Timeout2.originalMs[key];
      var remainingTime = metaDataRecord.ms - metaDataRecord.timeSpentWaiting;
      var result = Timeout2.set.apply(Timeout2, __spreadArrays([key, metaDataRecord.callback, remainingTime], metaDataRecord.params));
      Timeout2.originalMs[key] = originalMs;
      return result;
    };
    Timeout2.instantiate = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key;
      var ms;
      var params;
      var callback;
      if (args.length === 0) {
        throw Error("Timeout.set() requires at least one argument");
      }
      var linkToExisting = args.length === 1 && typeof args[0] !== "function";
      if (linkToExisting) {
        key = args[0];
        var metadata = Timeout2.meta(key);
        if (!metadata) {
          throw Error("Timeout.instantiate() attempted to link to nonexistent object by key");
        }
        ms = metadata.ms;
        params = metadata.params;
        callback = metadata.callback;
      } else if (typeof args[1] === "function") {
        key = args[0], callback = args[1], ms = args[2], params = args.slice(3);
      } else {
        callback = args[0], ms = args[1], params = args.slice(2);
        key = ("" + Math.random() + callback).replace(/\s/g, "");
      }
      if (!callback) {
        throw Error("Timeout.instantiate() requires a function parameter");
      }
      if (!linkToExisting) {
        Timeout2.set.apply(Timeout2, __spreadArrays([key, callback, ms], params));
      }
      return {
        call: function() {
          return Timeout2.call(key);
        },
        clear: function(erase) {
          if (erase === undefined) {
            erase = true;
          }
          return Timeout2.clear(key, erase);
        },
        elapsed: function() {
          return Timeout2.elapsed(key);
        },
        executed: function() {
          return Timeout2.executed(key);
        },
        exists: function() {
          return Timeout2.exists(key);
        },
        lastExecuted: function() {
          return Timeout2.lastExecuted(key);
        },
        meta: function() {
          return Timeout2.meta(key);
        },
        pause: function() {
          return Timeout2.pause(key);
        },
        paused: function() {
          return Timeout2.paused(key);
        },
        pending: function() {
          return Timeout2.pending(key);
        },
        remaining: function() {
          return Timeout2.remaining(key);
        },
        reset: function(ms2) {
          var params2 = [];
          for (var _i2 = 1;_i2 < arguments.length; _i2++) {
            params2[_i2 - 1] = arguments[_i2];
          }
          return Timeout2.reset.apply(Timeout2, __spreadArrays([key, ms2], params2));
        },
        restart: function() {
          return Timeout2.restart(key);
        },
        resume: function() {
          return Timeout2.resume(key);
        },
        set: function(newCallback, newMs) {
          if (newMs === undefined) {
            newMs = 0;
          }
          var newParams = [];
          for (var _i2 = 2;_i2 < arguments.length; _i2++) {
            newParams[_i2 - 2] = arguments[_i2];
          }
          return Timeout2.set.apply(Timeout2, __spreadArrays([key, newCallback, newMs], newParams));
        }
      };
    };
    Timeout2.keyId = {};
    Timeout2.keyCall = {};
    Timeout2.originalMs = {};
    Timeout2.metadata = {};
    return Timeout2;
  }();
  exports.Timeout = Timeout;
});

// node_modules/smart-timeout/index.js
var require_smart_timeout = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var timeout_1 = require_timeout();
  module.exports = timeout_1.Timeout;
});

// node_modules/@fortawesome/fontawesome-svg-core/index.mjs
function _defineProperty(e4, r4, t5) {
  return (r4 = _toPropertyKey(r4)) in e4 ? Object.defineProperty(e4, r4, {
    value: t5,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e4[r4] = t5, e4;
}
function ownKeys(e4, r4) {
  var t5 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e4);
    r4 && (o3 = o3.filter(function(r5) {
      return Object.getOwnPropertyDescriptor(e4, r5).enumerable;
    })), t5.push.apply(t5, o3);
  }
  return t5;
}
function _objectSpread2(e4) {
  for (var r4 = 1;r4 < arguments.length; r4++) {
    var t5 = arguments[r4] != null ? arguments[r4] : {};
    r4 % 2 ? ownKeys(Object(t5), true).forEach(function(r5) {
      _defineProperty(e4, r5, t5[r5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(t5)) : ownKeys(Object(t5)).forEach(function(r5) {
      Object.defineProperty(e4, r5, Object.getOwnPropertyDescriptor(t5, r5));
    });
  }
  return e4;
}
function _toPrimitive(t5, r4) {
  if (typeof t5 != "object" || !t5)
    return t5;
  var e4 = t5[Symbol.toPrimitive];
  if (e4 !== undefined) {
    var i4 = e4.call(t5, r4 || "default");
    if (typeof i4 != "object")
      return i4;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r4 === "string" ? String : Number)(t5);
}
function _toPropertyKey(t5) {
  var i4 = _toPrimitive(t5, "string");
  return typeof i4 == "symbol" ? i4 : i4 + "";
}
function familyProxy(obj) {
  return new Proxy(obj, {
    get(target, prop) {
      return prop in target ? target[prop] : target[s4];
    }
  });
}
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "")
    return true;
  if (val === "false")
    return false;
  if (val === "true")
    return true;
  return val;
}
function onChange(cb) {
  _onChangeCb.push(cb);
  return () => {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
function insertCss(css) {
  if (!css || !IS_DOM) {
    return;
  }
  const style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css;
  const headChildren = DOCUMENT.head.childNodes;
  let beforeChild = null;
  for (let i4 = headChildren.length - 1;i4 > -1; i4--) {
    const child = headChildren[i4];
    const tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css;
}
function nextUniqueId() {
  let size = 12;
  let id3 = "";
  while (size-- > 0) {
    id3 += idPool[Math.random() * 62 | 0];
  }
  return id3;
}
function toArray4(obj) {
  const array = [];
  for (let i4 = (obj || []).length >>> 0;i4--; ) {
    array[i4] = obj[i4];
  }
  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray4(node.classList);
  } else {
    return (node.getAttribute("class") || "").split(" ").filter((i4) => i4);
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce((acc, attributeName) => {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles) {
  return Object.keys(styles || {}).reduce((acc, styleName) => {
    return acc + "".concat(styleName, ": ").concat(styles[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  let {
    transform,
    containerWidth,
    iconWidth
  } = _ref;
  const outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  const inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  const path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path
  };
}
function transformForCss(_ref2) {
  let {
    transform,
    width = UNITS_IN_GRID,
    height = UNITS_IN_GRID,
    startCentered = false
  } = _ref2;
  let val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d$2, "em, ").concat(transform.y / d$2, "em) ");
  }
  val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}
function css() {
  const dcp = DEFAULT_CSS_PREFIX;
  const drc = DEFAULT_REPLACEMENT_CLASS;
  const fp = config3.cssPrefix;
  const rc = config3.replacementClass;
  let s5 = baseStyles;
  if (fp !== dcp || rc !== drc) {
    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    const rPatt = new RegExp("\\.".concat(drc), "g");
    s5 = s5.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s5;
}
function ensureCss() {
  if (config3.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
function domready(fn2) {
  if (!IS_DOM)
    return;
  loaded ? setTimeout(fn2, 0) : functions.push(fn2);
}
function toHtml(abstractNodes) {
  const {
    tag,
    attributes = {},
    children = []
  } = abstractNodes;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix,
      iconName,
      icon: mapping[prefix][iconName]
    };
  }
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function toHex(unicode) {
  const decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index3) {
  const size = string.length;
  let first = string.charCodeAt(index3);
  let second;
  if (first >= 55296 && first <= 56319 && size > index3 + 1) {
    second = string.charCodeAt(index3 + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce((acc, iconName) => {
    const icon = icons[iconName];
    const expanded = !!icon.icon;
    if (expanded) {
      acc[icon.iconName] = icon.icon;
    } else {
      acc[iconName] = icon;
    }
    return acc;
  }, {});
}
function defineIcons(prefix, icons) {
  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    skipHooks = false
  } = params;
  const normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), normalized);
  }
  if (prefix === "fas") {
    defineIcons("fa", icons);
  }
}
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  const parts = cls.split("-");
  const prefix = parts[0];
  const iconName = parts.slice(1).join("-");
  if (prefix === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias) {
  return (_byAlias[prefix] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  const oldUnicode = _byOldUnicode[unicode];
  const newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
function getFamilyId(values) {
  let family = s4;
  const famProps = FAMILY_NAMES.reduce((acc, familyId) => {
    acc[familyId] = "".concat(config3.cssPrefix, "-").concat(familyId);
    return acc;
  }, {});
  L4.forEach((familyId) => {
    if (values.includes(famProps[familyId]) || values.some((v$$1) => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
      family = familyId;
    }
  });
  return family;
}
function getCanonicalPrefix(styleOrPrefix) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    family = s4
  } = params;
  const style = PREFIX_TO_STYLE[family][styleOrPrefix];
  if (family === t5 && !styleOrPrefix) {
    return "fad";
  }
  const prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
  const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  const result = prefix || defined || null;
  return result;
}
function moveNonFaClassesToRest(classNames) {
  let rest = [];
  let iconName = null;
  classNames.forEach((cls) => {
    const result = getIconName(config3.cssPrefix, cls);
    if (result) {
      iconName = result;
    } else if (cls) {
      rest.push(cls);
    }
  });
  return {
    iconName,
    rest
  };
}
function sortedUniqueValues(arr) {
  return arr.sort().filter((value, index3, arr2) => {
    return arr2.indexOf(value) === index3;
  });
}
function getCanonicalIcon(values) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    skipLookups = false
  } = params;
  let givenPrefix = null;
  const faCombinedClasses = Ia.concat(bt$1);
  const faStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls) => faCombinedClasses.includes(cls)));
  const nonStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls) => !Ia.includes(cls)));
  const faStyles = faStyleOrFamilyClasses.filter((cls) => {
    givenPrefix = cls;
    return !P4.includes(cls);
  });
  const [styleFromValues = null] = faStyles;
  const family = getFamilyId(faStyleOrFamilyClasses);
  const canonical = _objectSpread2(_objectSpread2({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
    prefix: getCanonicalPrefix(styleFromValues, {
      family
    })
  });
  return _objectSpread2(_objectSpread2(_objectSpread2({}, canonical), getDefaultCanonicalPrefix({
    values,
    family,
    styles,
    config: config3,
    canonical,
    givenPrefix
  })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
}
function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
  let {
    prefix,
    iconName
  } = canonical;
  if (skipLookups || !prefix || !iconName) {
    return {
      prefix,
      iconName
    };
  }
  const shim = givenPrefix === "fa" ? byOldName(iconName) : {};
  const aliasIconName = byAlias(prefix, iconName);
  iconName = shim.iconName || aliasIconName || iconName;
  prefix = shim.prefix || prefix;
  if (prefix === "far" && !styles["far"] && styles["fas"] && !config3.autoFetchSvg) {
    prefix = "fas";
  }
  return {
    prefix,
    iconName
  };
}
function getDefaultCanonicalPrefix(prefixOptions) {
  const {
    values,
    family,
    canonical,
    givenPrefix = "",
    styles: styles2 = {},
    config: config$$1 = {}
  } = prefixOptions;
  const isDuotoneFamily = family === t5;
  const valuesHasDuotone = values.includes("fa-duotone") || values.includes("fad");
  const defaultFamilyIsDuotone = config$$1.familyDefault === "duotone";
  const canonicalPrefixIsDuotone = canonical.prefix === "fad" || canonical.prefix === "fa-duotone";
  if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
    canonical.prefix = "fad";
  }
  if (values.includes("fa-brands") || values.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
    const validPrefix = Object.keys(styles2).find((key) => newCanonicalStyles.includes(key));
    if (validPrefix || config$$1.autoFetchSvg) {
      const defaultPrefix = pt2.get(family).defaultShortPrefixId;
      canonical.prefix = defaultPrefix;
      canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
    }
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}

class Library {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var _len = arguments.length, definitions = new Array(_len), _key = 0;_key < _len; _key++) {
      definitions[_key] = arguments[_key];
    }
    const additions = definitions.reduce(this._pullDefinitions, {});
    Object.keys(additions).forEach((key) => {
      this.definitions[key] = _objectSpread2(_objectSpread2({}, this.definitions[key] || {}), additions[key]);
      defineIcons(key, additions[key]);
      const longPrefix = PREFIX_TO_LONG_STYLE[s4][key];
      if (longPrefix)
        defineIcons(longPrefix, additions[key]);
      build();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(additions, definition) {
    const normalized = definition.prefix && definition.iconName && definition.icon ? {
      0: definition
    } : definition;
    Object.keys(normalized).map((key) => {
      const {
        prefix,
        iconName,
        icon
      } = normalized[key];
      const aliases2 = icon[2];
      if (!additions[prefix])
        additions[prefix] = {};
      if (aliases2.length > 0) {
        aliases2.forEach((alias) => {
          if (typeof alias === "string") {
            additions[prefix][alias] = icon;
          }
        });
      }
      additions[prefix][iconName] = icon;
    });
    return additions;
  }
}
function registerPlugins(nextPlugins, _ref) {
  let {
    mixoutsTo: obj
  } = _ref;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach((k4) => {
    if (defaultProviderKeys.indexOf(k4) === -1) {
      delete providers[k4];
    }
  });
  _plugins.forEach((plugin) => {
    const mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach((tk) => {
      if (typeof mixout[tk] === "function") {
        obj[tk] = mixout[tk];
      }
      if (typeof mixout[tk] === "object") {
        Object.keys(mixout[tk]).forEach((sk) => {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      const hooks3 = plugin.hooks();
      Object.keys(hooks3).forEach((hook) => {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks3[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2;_key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    accumulator = hookFn.apply(null, [accumulator, ...args]);
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    hookFn.apply(null, args);
  });
  return;
}
function callProvided() {
  const hook = arguments[0];
  const args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : undefined;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  let {
    iconName
  } = iconLookup;
  const prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName)
    return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function() {
      return val.abstract.map((a4) => toHtml(a4));
    }
  });
  Object.defineProperty(val, "node", {
    get: function() {
      if (!IS_DOM)
        return;
      const container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref) {
  let {
    children,
    main,
    mask,
    attributes,
    styles: styles2,
    transform
  } = _ref;
  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    const {
      width,
      height
    } = main;
    const offset2 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread2(_objectSpread2({}, styles2), {}, {
      "transform-origin": "".concat(offset2.x + transform.x / 16, "em ").concat(offset2.y + transform.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref) {
  let {
    prefix,
    iconName,
    children,
    attributes,
    symbol
  } = _ref;
  const id3 = symbol === true ? "".concat(prefix, "-").concat(config3.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
        id: id3
      }),
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  const {
    icons: {
      main,
      mask
    },
    prefix,
    iconName,
    transform,
    symbol,
    title,
    maskId,
    titleId,
    extra,
    watchable = false
  } = params;
  const {
    width,
    height
  } = mask.found ? mask : main;
  const isUploadedIcon = Lt2.includes(prefix);
  const attrClass = [config3.replacementClass, iconName ? "".concat(config3.cssPrefix, "-").concat(iconName) : ""].filter((c$$1) => extra.classes.indexOf(c$$1) === -1).filter((c$$1) => c$$1 !== "" || !!c$$1).concat(extra.classes).join(" ");
  let content = {
    children: [],
    attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      "data-prefix": prefix,
      "data-icon": iconName,
      class: attrClass,
      role: extra.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(width, " ").concat(height)
    })
  };
  const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  const args = _objectSpread2(_objectSpread2({}, content), {}, {
    prefix,
    iconName,
    main,
    mask,
    maskId,
    transform,
    symbol,
    styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
  });
  const {
    children,
    attributes
  } = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  };
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  const {
    content,
    width,
    height,
    transform,
    title,
    extra,
    watchable = false
  } = params;
  const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    title
  } : {}), {}, {
    class: extra.classes.join(" ")
  });
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  const styles2 = _objectSpread2({}, extra.styles);
  if (transformIsMeaningful(transform)) {
    styles2["transform"] = transformForCss({
      transform,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  const styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  const {
    content,
    title,
    extra
  } = params;
  const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    title
  } : {}), {}, {
    class: extra.classes.join(" ")
  });
  const styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function asFoundIcon(icon) {
  const width = icon[0];
  const height = icon[1];
  const [vectorData] = icon.slice(4);
  let element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config3.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config3.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config3.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION && !config3.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix, '" is missing.'));
  }
}
function findIcon(iconName, prefix) {
  let givenPrefix = prefix;
  if (prefix === "fa" && config3.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }
  return new Promise((resolve, reject) => {
    if (givenPrefix === "fa") {
      const shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }
    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      const icon = styles$1[prefix][iconName];
      return resolve(asFoundIcon(icon));
    }
    maybeNotifyMissing(iconName, prefix);
    resolve(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
      icon: config3.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    }));
  });
}
function isWatched(node) {
  const i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === "string";
}
function hasPrefixAndIcon(node) {
  const prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  const icon = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon;
}
function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config3.replacementClass);
}
function getMutator() {
  if (config3.autoReplaceSvg === true) {
    return mutators.replace;
  }
  const mutator = mutators[config3.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    ceFn = abstractObj.tag === "svg" ? createElementNS : createElement
  } = params;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  const tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  const children = abstractObj.children || [];
  children.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node) {
  let comment = " ".concat(node.outerHTML, " ");
  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  return comment;
}
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  const callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    let frame = performOperationSync;
    if (config3.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(() => {
      const mutator = getMutator();
      const mark = perf.begin("mutate");
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config3.observeMutations) {
    return;
  }
  const {
    treeCallback = noop$2,
    nodeCallback = noop$2,
    pseudoElementsCallback = noop$2,
    observeMutationsRoot = DOCUMENT
  } = options;
  mo = new MUTATION_OBSERVER((objects) => {
    if (disabled)
      return;
    const defaultPrefix = getDefaultUsablePrefix();
    toArray4(objects).forEach((mutationRecord) => {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config3.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config3.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          const {
            prefix,
            iconName
          } = getCanonicalIcon(classArray(mutationRecord.target));
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName)
            mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM)
    return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo)
    return;
  mo.disconnect();
}
function styleParser(node) {
  const style = node.getAttribute("style");
  let val = [];
  if (style) {
    val = style.split(";").reduce((acc, style2) => {
      const styles2 = style2.split(":");
      const prop = styles2[0];
      const value = styles2.slice(1);
      if (prop && value.length > 0) {
        acc[prop] = value.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node) {
  const existingPrefix = node.getAttribute("data-prefix");
  const existingIconName = node.getAttribute("data-icon");
  const innerText = node.innerText !== undefined ? node.innerText.trim() : "";
  let val = getCanonicalIcon(classArray(node));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }
  if (!val.iconName && config3.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node.firstChild.data;
  }
  return val;
}
function attributesParser(node) {
  const extraAttributes = toArray4(node.attributes).reduce((acc, attr) => {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  const title = node.getAttribute("title");
  const titleId = node.getAttribute("data-fa-title-id");
  if (config3.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config3.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  let parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName,
    prefix,
    rest: extraClasses
  } = classParser(node);
  const extraAttributes = attributesParser(node);
  const pluginMeta = chainHooks("parseNodeAttributes", {}, node);
  let extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2({
    iconName,
    title: node.getAttribute("title"),
    titleId: node.getAttribute("data-fa-title-id"),
    prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}
function generateMutation(node) {
  const nodeMeta = config3.autoReplaceSvg === "nest" ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node, nodeMeta);
  }
}
function getKnownPrefixes() {
  return [...Ft2, ...Ia];
}
function onTree(root) {
  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!IS_DOM)
    return Promise.resolve();
  const htmlClassList = DOCUMENT.documentElement.classList;
  const hclAdd = (suffix) => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const hclRemove = (suffix) => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const prefixes = config3.autoFetchSvg ? getKnownPrefixes() : P4.concat(Object.keys(styles$2));
  if (!prefixes.includes("fa")) {
    prefixes.push("fa");
  }
  const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map((p$$1) => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  let candidates = [];
  try {
    candidates = toArray4(root.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {}
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  const mark = perf.begin("onTree");
  const mutations = candidates.reduce((acc, node) => {
    try {
      const mutation = generateMutation(node);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION) {
        if (e$$1.name === "MissingIcon") {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise((resolve, reject) => {
    Promise.all(mutations).then((resolvedMutations) => {
      perform(resolvedMutations, () => {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function")
          callback();
        mark();
        resolve();
      });
    }).catch((e$$1) => {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node) {
  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  generateMutation(node).then((mutation) => {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    let {
      mask
    } = params;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
      mask
    }));
  };
}
function hexValueFromContent(content) {
  const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  const codePoint = codePointAt(cleaned, 0);
  const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function getPrefix2(fontFamily, fontWeight) {
  const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
  const fontWeightInteger = parseInt(fontWeight);
  const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node, position) {
  const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
  return new Promise((resolve, reject) => {
    if (node.getAttribute(pendingAttribute) !== null) {
      return resolve();
    }
    const children = toArray4(node.children);
    const alreadyProcessedPseudoElement = children.filter((c$$1) => c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position)[0];
    const styles2 = WINDOW.getComputedStyle(node, position);
    const fontFamily = styles2.getPropertyValue("font-family");
    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    const fontWeight = styles2.getPropertyValue("font-weight");
    const content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamilyMatch && content !== "none" && content !== "") {
      const content2 = styles2.getPropertyValue("content");
      let prefix = getPrefix2(fontFamily, fontWeight);
      const {
        value: hexValue,
        isSecondary
      } = hexValueFromContent(content2);
      const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
      let iconName = byUnicode(prefix, hexValue);
      let iconIdentifier = iconName;
      if (isV4) {
        const iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node.removeChild(alreadyProcessedPseudoElement);
        }
        const meta = blankMeta();
        const {
          extra
        } = meta;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then((main) => {
          const abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix,
            iconName: iconIdentifier,
            extra,
            watchable: true
          }));
          const element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position === "::before") {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }
          element.outerHTML = abstract.map((a$$1) => toHtml(a$$1)).join(`
`);
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}
function replace(node) {
  return Promise.all([replaceForPosition(node, "::before"), replaceForPosition(node, "::after")]);
}
function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
}
function searchPseudoElements(root) {
  if (!IS_DOM)
    return;
  return new Promise((resolve, reject) => {
    const operations = toArray4(root.querySelectorAll("*")).filter(processable).map(replace);
    const end2 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(() => {
      end2();
      enableObservation();
      resolve();
    }).catch(() => {
      end2();
      enableObservation();
      reject();
    });
  });
}
function fillBlack(abstract) {
  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var noop = () => {}, _WINDOW, _DOCUMENT, _MUTATION_OBSERVER = null, _PERFORMANCE, userAgent, WINDOW, DOCUMENT, MUTATION_OBSERVER, PERFORMANCE, IS_BROWSER, IS_DOM, IS_IE, p4, g5, S3, A4, P4, s4 = "classic", t5 = "duotone", r4 = "sharp", o3 = "sharp-duotone", L4, G4, lt2, pt2, xt2, Ft2, St2, At2, Ct2, Lt2, Wt2, Et2, t$1, r$1, bt$1, Yt2, ua, I$1, ga, x5, Ia, m$1, c$1, F$1, ma, wa, NAMESPACE_IDENTIFIER = "___FONT_AWESOME___", UNITS_IN_GRID = 16, DEFAULT_CSS_PREFIX = "fa", DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa", DATA_FA_I2SVG = "data-fa-i2svg", DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element", DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending", DATA_PREFIX = "data-prefix", DATA_ICON = "data-icon", HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg", MUTATION_APPROACH_ASYNC = "async", TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS, PRODUCTION, _PREFIX_TO_STYLE, PREFIX_TO_STYLE, _STYLE_TO_PREFIX, STYLE_TO_PREFIX, _PREFIX_TO_LONG_STYLE, PREFIX_TO_LONG_STYLE, _LONG_STYLE_TO_PREFIX, LONG_STYLE_TO_PREFIX, ICON_SELECTION_SYNTAX_PATTERN, LAYERS_TEXT_CLASSNAME = "fa-layers-text", FONT_FAMILY_PATTERN, _FONT_WEIGHT_TO_PREFIX, FONT_WEIGHT_TO_PREFIX, ATTRIBUTES_WATCHED_FOR_MUTATION, DUOTONE_CLASSES, RESERVED_CLASSES, initial, _default, _config, config3, _onChangeCb, d$2, meaninglessTransform, idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", baseStyles = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`, _cssInserted = false, InjectCSS, w5, namespace, functions, listener = function() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener);
  loaded = 1;
  functions.map((fn2) => fn2());
}, loaded = false, bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a4, b4, c4, d3) {
    return func.call(thisContext, a4, b4, c4, d3);
  };
}, reduce = function fastReduceObject(subject, fn2, initialValue, thisContext) {
  var keys2 = Object.keys(subject), length = keys2.length, iterator = thisContext !== undefined ? bindInternal4(fn2, thisContext) : fn2, i4, key, result;
  if (initialValue === undefined) {
    i4 = 1;
    result = subject[keys2[0]];
  } else {
    i4 = 0;
    result = initialValue;
  }
  for (;i4 < length; i4++) {
    key = keys2[i4];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
}, styles, shims, FAMILY_NAMES, PREFIXES_FOR_FAMILY, _defaultUsablePrefix = null, _byUnicode, _byLigature, _byOldName, _byOldUnicode, _byAlias, build = () => {
  const lookup = (reducer) => {
    return reduce(styles, (o$$1, style, prefix) => {
      o$$1[prefix] = reduce(style, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup((acc, icon, iconName) => {
    if (icon[3]) {
      acc[icon[3]] = iconName;
    }
    if (icon[2]) {
      const aliases2 = icon[2].filter((a$$1) => {
        return typeof a$$1 === "number";
      });
      aliases2.forEach((alias) => {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup((acc, icon, iconName) => {
    acc[iconName] = iconName;
    if (icon[2]) {
      const aliases2 = icon[2].filter((a$$1) => {
        return typeof a$$1 === "string";
      });
      aliases2.forEach((alias) => {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup((acc, icon, iconName) => {
    const aliases2 = icon[2];
    acc[iconName] = iconName;
    aliases2.forEach((alias) => {
      acc[alias] = iconName;
    });
    return acc;
  });
  const hasRegular = "far" in styles || config3.autoFetchSvg;
  const shimLookups = reduce(shims, (acc, shim) => {
    const maybeNameMaybeUnicode = shim[0];
    let prefix = shim[1];
    const iconName = shim[2];
    if (prefix === "far" && !hasRegular) {
      prefix = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config3.styleDefault, {
    family: config3.familyDefault
  });
}, emptyCanonicalIcon = () => {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
}, newCanonicalFamilies, newCanonicalStyles, _plugins, _hooks, providers, defaultProviderKeys, library, noAuto = () => {
  config3.autoReplaceSvg = false;
  config3.observeMutations = false;
  callHooks("noAuto");
}, dom, parse2, api, autoReplace = function() {
  let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    autoReplaceSvgRoot = DOCUMENT
  } = params;
  if ((Object.keys(namespace.styles).length > 0 || config3.autoFetchSvg) && IS_DOM && config3.autoReplaceSvg)
    api.dom.i2svg({
      node: autoReplaceSvgRoot
    });
}, styles$1, missingIconResolutionMixin, noop$1 = () => {}, p$2, preamble = 'FA "6.7.2"', begin = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return () => end(name);
}, end = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
}, perf, noop$2 = () => {}, mutators, disabled = false, mo = null, styles$2, render = function(iconDefinition) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    transform = meaninglessTransform,
    symbol = false,
    mask = null,
    maskId = null,
    title = null,
    titleId = null,
    classes = [],
    attributes = {},
    styles: styles2 = {}
  } = params;
  if (!iconDefinition)
    return;
  const {
    prefix,
    iconName,
    icon
  } = iconDefinition;
  return domVariants(_objectSpread2({
    type: "icon"
  }, iconDefinition), () => {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config3.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config3.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix,
      iconName,
      transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
}, ReplaceElements, Layers, LayersCounter, LayersText, CLEAN_CONTENT_PATTERN, SECONDARY_UNICODE_RANGE, _FONT_FAMILY_WEIGHT_TO_PREFIX, FONT_FAMILY_WEIGHT_TO_PREFIX, FONT_FAMILY_WEIGHT_FALLBACK, PseudoElements, _unwatched = false, MutationObserver$1, parseTransformString = (transformString) => {
  let transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce((acc, n3) => {
    const parts = n3.toLowerCase().split("-");
    const first = parts[0];
    let rest = parts.slice(1).join("-");
    if (first && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform);
}, PowerTransforms, ALL_SPACE, Masks, MissingIconIndicator, SvgSymbols, plugins, noAuto$1, config$1, library$1, dom$1, parse$1, findIconDefinition$1, toHtml$1, icon, layer, text, counter;
var init_fontawesome_svg_core = __esm(() => {
  /*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   */
  _WINDOW = {};
  _DOCUMENT = {};
  _PERFORMANCE = {
    mark: noop,
    measure: noop
  };
  try {
    if (typeof window !== "undefined")
      _WINDOW = window;
    if (typeof document !== "undefined")
      _DOCUMENT = document;
    if (typeof MutationObserver !== "undefined")
      _MUTATION_OBSERVER = MutationObserver;
    if (typeof performance !== "undefined")
      _PERFORMANCE = performance;
  } catch (e4) {}
  ({
    userAgent = ""
  } = _WINDOW.navigator || {});
  WINDOW = _WINDOW;
  DOCUMENT = _DOCUMENT;
  MUTATION_OBSERVER = _MUTATION_OBSERVER;
  PERFORMANCE = _PERFORMANCE;
  IS_BROWSER = !!WINDOW.document;
  IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
  IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
  p4 = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/;
  g5 = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
  S3 = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    }
  };
  A4 = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  };
  P4 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
  L4 = [s4, t5, r4, o3];
  G4 = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    }
  };
  lt2 = {
    "Font Awesome 6 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 6 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 6 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 6 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 6 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 6 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    }
  };
  pt2 = new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }]]);
  xt2 = {
    classic: {
      solid: "fas",
      regular: "far",
      light: "fal",
      thin: "fat",
      brands: "fab"
    },
    duotone: {
      solid: "fad",
      regular: "fadr",
      light: "fadl",
      thin: "fadt"
    },
    sharp: {
      solid: "fass",
      regular: "fasr",
      light: "fasl",
      thin: "fast"
    },
    "sharp-duotone": {
      solid: "fasds",
      regular: "fasdr",
      light: "fasdl",
      thin: "fasdt"
    }
  };
  Ft2 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
  St2 = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  };
  At2 = ["kit"];
  Ct2 = {
    kit: {
      "fa-kit": "fak"
    },
    "kit-duotone": {
      "fa-kit-duotone": "fakd"
    }
  };
  Lt2 = ["fak", "fakd"];
  Wt2 = {
    kit: {
      fak: "fa-kit"
    },
    "kit-duotone": {
      fakd: "fa-kit-duotone"
    }
  };
  Et2 = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  };
  t$1 = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  };
  r$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
  bt$1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
  Yt2 = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  };
  ua = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    }
  };
  I$1 = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
  };
  ga = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    }
  };
  x5 = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"];
  Ia = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...r$1, ...x5];
  m$1 = ["solid", "regular", "light", "thin", "duotone", "brands"];
  c$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  F$1 = c$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
  ma = [...Object.keys(I$1), ...m$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(c$1.map((a4) => "".concat(a4, "x"))).concat(F$1.map((a4) => "w-".concat(a4)));
  wa = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  };
  TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
  PRODUCTION = (() => {
    try {
      return false;
    } catch (e$$1) {
      return false;
    }
  })();
  _PREFIX_TO_STYLE = _objectSpread2({}, S3);
  _PREFIX_TO_STYLE[s4] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    "fa-duotone": "duotone"
  }), S3[s4]), St2["kit"]), St2["kit-duotone"]);
  PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
  _STYLE_TO_PREFIX = _objectSpread2({}, xt2);
  _STYLE_TO_PREFIX[s4] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    duotone: "fad"
  }), _STYLE_TO_PREFIX[s4]), Et2["kit"]), Et2["kit-duotone"]);
  STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
  _PREFIX_TO_LONG_STYLE = _objectSpread2({}, ga);
  _PREFIX_TO_LONG_STYLE[s4] = _objectSpread2(_objectSpread2({}, _PREFIX_TO_LONG_STYLE[s4]), Wt2["kit"]);
  PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
  _LONG_STYLE_TO_PREFIX = _objectSpread2({}, ua);
  _LONG_STYLE_TO_PREFIX[s4] = _objectSpread2(_objectSpread2({}, _LONG_STYLE_TO_PREFIX[s4]), Ct2["kit"]);
  LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
  ICON_SELECTION_SYNTAX_PATTERN = p4;
  FONT_FAMILY_PATTERN = g5;
  _FONT_WEIGHT_TO_PREFIX = _objectSpread2({}, G4);
  FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);
  ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
  DUOTONE_CLASSES = A4;
  RESERVED_CLASSES = [...At2, ...ma];
  initial = WINDOW.FontAwesomeConfig || {};
  if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
    const attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    attrs.forEach((_ref) => {
      let [attr, key] = _ref;
      const val = coerce(getAttrConfig(attr));
      if (val !== undefined && val !== null) {
        initial[key] = val;
      }
    });
  }
  _default = {
    styleDefault: "solid",
    familyDefault: s4,
    cssPrefix: DEFAULT_CSS_PREFIX,
    replacementClass: DEFAULT_REPLACEMENT_CLASS,
    autoReplaceSvg: true,
    autoAddCss: true,
    autoA11y: true,
    searchPseudoElements: false,
    observeMutations: true,
    mutateApproach: "async",
    keepOriginalSource: true,
    measurePerformance: false,
    showMissingIcons: true
  };
  if (initial.familyPrefix) {
    initial.cssPrefix = initial.familyPrefix;
  }
  _config = _objectSpread2(_objectSpread2({}, _default), initial);
  if (!_config.autoReplaceSvg)
    _config.observeMutations = false;
  config3 = {};
  Object.keys(_default).forEach((key) => {
    Object.defineProperty(config3, key, {
      enumerable: true,
      set: function(val) {
        _config[key] = val;
        _onChangeCb.forEach((cb) => cb(config3));
      },
      get: function() {
        return _config[key];
      }
    });
  });
  Object.defineProperty(config3, "familyPrefix", {
    enumerable: true,
    set: function(val) {
      _config.cssPrefix = val;
      _onChangeCb.forEach((cb) => cb(config3));
    },
    get: function() {
      return _config.cssPrefix;
    }
  });
  WINDOW.FontAwesomeConfig = config3;
  _onChangeCb = [];
  d$2 = UNITS_IN_GRID;
  meaninglessTransform = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: false,
    flipY: false
  };
  InjectCSS = {
    mixout() {
      return {
        dom: {
          css,
          insertCss: ensureCss
        }
      };
    },
    hooks() {
      return {
        beforeDOMElementCreation() {
          ensureCss();
        },
        beforeI2svg() {
          ensureCss();
        }
      };
    }
  };
  w5 = WINDOW || {};
  if (!w5[NAMESPACE_IDENTIFIER])
    w5[NAMESPACE_IDENTIFIER] = {};
  if (!w5[NAMESPACE_IDENTIFIER].styles)
    w5[NAMESPACE_IDENTIFIER].styles = {};
  if (!w5[NAMESPACE_IDENTIFIER].hooks)
    w5[NAMESPACE_IDENTIFIER].hooks = {};
  if (!w5[NAMESPACE_IDENTIFIER].shims)
    w5[NAMESPACE_IDENTIFIER].shims = [];
  namespace = w5[NAMESPACE_IDENTIFIER];
  functions = [];
  if (IS_DOM) {
    loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
    if (!loaded)
      DOCUMENT.addEventListener("DOMContentLoaded", listener);
  }
  ({
    styles,
    shims
  } = namespace);
  FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
  PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce((acc, familyId) => {
    acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
    return acc;
  }, {});
  _byUnicode = {};
  _byLigature = {};
  _byOldName = {};
  _byOldUnicode = {};
  _byAlias = {};
  onChange((c$$1) => {
    _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
      family: config3.familyDefault
    });
  });
  build();
  newCanonicalFamilies = L4.filter((familyId) => {
    return familyId !== s4 || familyId !== t5;
  });
  newCanonicalStyles = Object.keys(ga).filter((key) => key !== s4).map((key) => Object.keys(ga[key])).flat();
  _plugins = [];
  _hooks = {};
  providers = {};
  defaultProviderKeys = Object.keys(providers);
  library = new Library;
  dom = {
    i2svg: function() {
      let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (IS_DOM) {
        callHooks("beforeI2svg", params);
        callProvided("pseudoElements2svg", params);
        return callProvided("i2svg", params);
      } else {
        return Promise.reject(new Error("Operation requires a DOM of some kind."));
      }
    },
    watch: function() {
      let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        autoReplaceSvgRoot
      } = params;
      if (config3.autoReplaceSvg === false) {
        config3.autoReplaceSvg = true;
      }
      config3.observeMutations = true;
      domready(() => {
        autoReplace({
          autoReplaceSvgRoot
        });
        callHooks("watch", params);
      });
    }
  };
  parse2 = {
    icon: (icon) => {
      if (icon === null) {
        return null;
      }
      if (typeof icon === "object" && icon.prefix && icon.iconName) {
        return {
          prefix: icon.prefix,
          iconName: byAlias(icon.prefix, icon.iconName) || icon.iconName
        };
      }
      if (Array.isArray(icon) && icon.length === 2) {
        const iconName = icon[1].indexOf("fa-") === 0 ? icon[1].slice(3) : icon[1];
        const prefix = getCanonicalPrefix(icon[0]);
        return {
          prefix,
          iconName: byAlias(prefix, iconName) || iconName
        };
      }
      if (typeof icon === "string" && (icon.indexOf("".concat(config3.cssPrefix, "-")) > -1 || icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
        const canonicalIcon = getCanonicalIcon(icon.split(" "), {
          skipLookups: true
        });
        return {
          prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
          iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
        };
      }
      if (typeof icon === "string") {
        const prefix = getDefaultUsablePrefix();
        return {
          prefix,
          iconName: byAlias(prefix, icon) || icon
        };
      }
    }
  };
  api = {
    noAuto,
    config: config3,
    dom,
    parse: parse2,
    library,
    findIconDefinition,
    toHtml
  };
  ({
    styles: styles$1
  } = namespace);
  missingIconResolutionMixin = {
    found: false,
    width: 512,
    height: 512
  };
  p$2 = config3.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
    mark: noop$1,
    measure: noop$1
  };
  perf = {
    begin,
    end
  };
  mutators = {
    replace: function(mutation) {
      const node = mutation[0];
      if (node.parentNode) {
        mutation[1].forEach((abstract) => {
          node.parentNode.insertBefore(convertSVG(abstract), node);
        });
        if (node.getAttribute(DATA_FA_I2SVG) === null && config3.keepOriginalSource) {
          let comment = DOCUMENT.createComment(nodeAsComment(node));
          node.parentNode.replaceChild(comment, node);
        } else {
          node.remove();
        }
      }
    },
    nest: function(mutation) {
      const node = mutation[0];
      const abstract = mutation[1];
      if (~classArray(node).indexOf(config3.replacementClass)) {
        return mutators.replace(mutation);
      }
      const forSvg = new RegExp("".concat(config3.cssPrefix, "-.*"));
      delete abstract[0].attributes.id;
      if (abstract[0].attributes.class) {
        const splitClasses = abstract[0].attributes.class.split(" ").reduce((acc, cls) => {
          if (cls === config3.replacementClass || cls.match(forSvg)) {
            acc.toSvg.push(cls);
          } else {
            acc.toNode.push(cls);
          }
          return acc;
        }, {
          toNode: [],
          toSvg: []
        });
        abstract[0].attributes.class = splitClasses.toSvg.join(" ");
        if (splitClasses.toNode.length === 0) {
          node.removeAttribute("class");
        } else {
          node.setAttribute("class", splitClasses.toNode.join(" "));
        }
      }
      const newInnerHTML = abstract.map((a4) => toHtml(a4)).join(`
`);
      node.setAttribute(DATA_FA_I2SVG, "");
      node.innerHTML = newInnerHTML;
    }
  };
  ({
    styles: styles$2
  } = namespace);
  ReplaceElements = {
    mixout() {
      return {
        icon: resolveIcons(render)
      };
    },
    hooks() {
      return {
        mutationObserverCallbacks(accumulator) {
          accumulator.treeCallback = onTree;
          accumulator.nodeCallback = onNode;
          return accumulator;
        }
      };
    },
    provides(providers$$1) {
      providers$$1.i2svg = function(params) {
        const {
          node = DOCUMENT,
          callback = () => {}
        } = params;
        return onTree(node, callback);
      };
      providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
        const {
          iconName,
          title,
          titleId,
          prefix,
          transform,
          symbol,
          mask,
          maskId,
          extra
        } = nodeMeta;
        return new Promise((resolve, reject) => {
          Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
            found: false,
            width: 512,
            height: 512,
            icon: {}
          })]).then((_ref) => {
            let [main, mask2] = _ref;
            resolve([node, makeInlineSvgAbstract({
              icons: {
                main,
                mask: mask2
              },
              prefix,
              iconName,
              transform,
              symbol,
              maskId,
              title,
              titleId,
              extra,
              watchable: true
            })]);
          }).catch(reject);
        });
      };
      providers$$1.generateAbstractIcon = function(_ref2) {
        let {
          children,
          attributes,
          main,
          transform,
          styles: styles2
        } = _ref2;
        const styleString = joinStyles(styles2);
        if (styleString.length > 0) {
          attributes["style"] = styleString;
        }
        let nextChild;
        if (transformIsMeaningful(transform)) {
          nextChild = callProvided("generateAbstractTransformGrouping", {
            main,
            transform,
            containerWidth: main.width,
            iconWidth: main.width
          });
        }
        children.push(nextChild || main.icon);
        return {
          children,
          attributes
        };
      };
    }
  };
  Layers = {
    mixout() {
      return {
        layer(assembler) {
          let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          const {
            classes = []
          } = params;
          return domVariants({
            type: "layer"
          }, () => {
            callHooks("beforeDOMElementCreation", {
              assembler,
              params
            });
            let children = [];
            assembler((args) => {
              Array.isArray(args) ? args.map((a4) => {
                children = children.concat(a4.abstract);
              }) : children = children.concat(args.abstract);
            });
            return [{
              tag: "span",
              attributes: {
                class: ["".concat(config3.cssPrefix, "-layers"), ...classes].join(" ")
              },
              children
            }];
          });
        }
      };
    }
  };
  LayersCounter = {
    mixout() {
      return {
        counter(content) {
          let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          const {
            title = null,
            classes = [],
            attributes = {},
            styles: styles2 = {}
          } = params;
          return domVariants({
            type: "counter",
            content
          }, () => {
            callHooks("beforeDOMElementCreation", {
              content,
              params
            });
            return makeLayersCounterAbstract({
              content: content.toString(),
              title,
              extra: {
                attributes,
                styles: styles2,
                classes: ["".concat(config3.cssPrefix, "-layers-counter"), ...classes]
              }
            });
          });
        }
      };
    }
  };
  LayersText = {
    mixout() {
      return {
        text(content) {
          let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          const {
            transform = meaninglessTransform,
            title = null,
            classes = [],
            attributes = {},
            styles: styles2 = {}
          } = params;
          return domVariants({
            type: "text",
            content
          }, () => {
            callHooks("beforeDOMElementCreation", {
              content,
              params
            });
            return makeLayersTextAbstract({
              content,
              transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
              title,
              extra: {
                attributes,
                styles: styles2,
                classes: ["".concat(config3.cssPrefix, "-layers-text"), ...classes]
              }
            });
          });
        }
      };
    },
    provides(providers$$1) {
      providers$$1.generateLayersText = function(node, nodeMeta) {
        const {
          title,
          transform,
          extra
        } = nodeMeta;
        let width = null;
        let height = null;
        if (IS_IE) {
          const computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
          const boundingClientRect = node.getBoundingClientRect();
          width = boundingClientRect.width / computedFontSize;
          height = boundingClientRect.height / computedFontSize;
        }
        if (config3.autoA11y && !title) {
          extra.attributes["aria-hidden"] = "true";
        }
        return Promise.resolve([node, makeLayersTextAbstract({
          content: node.innerHTML,
          width,
          height,
          transform,
          title,
          extra,
          watchable: true
        })]);
      };
    }
  };
  CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
  SECONDARY_UNICODE_RANGE = [1105920, 1112319];
  _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  }), lt2), wa), Yt2);
  FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
    acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
    return acc;
  }, {});
  FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
    const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
    acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
    return acc;
  }, {});
  PseudoElements = {
    hooks() {
      return {
        mutationObserverCallbacks(accumulator) {
          accumulator.pseudoElementsCallback = searchPseudoElements;
          return accumulator;
        }
      };
    },
    provides(providers2) {
      providers2.pseudoElements2svg = function(params) {
        const {
          node = DOCUMENT
        } = params;
        if (config3.searchPseudoElements) {
          searchPseudoElements(node);
        }
      };
    }
  };
  MutationObserver$1 = {
    mixout() {
      return {
        dom: {
          unwatch() {
            disableObservation();
            _unwatched = true;
          }
        }
      };
    },
    hooks() {
      return {
        bootstrap() {
          observe(chainHooks("mutationObserverCallbacks", {}));
        },
        noAuto() {
          disconnect();
        },
        watch(params) {
          const {
            observeMutationsRoot
          } = params;
          if (_unwatched) {
            enableObservation();
          } else {
            observe(chainHooks("mutationObserverCallbacks", {
              observeMutationsRoot
            }));
          }
        }
      };
    }
  };
  PowerTransforms = {
    mixout() {
      return {
        parse: {
          transform: (transformString) => {
            return parseTransformString(transformString);
          }
        }
      };
    },
    hooks() {
      return {
        parseNodeAttributes(accumulator, node) {
          const transformString = node.getAttribute("data-fa-transform");
          if (transformString) {
            accumulator.transform = parseTransformString(transformString);
          }
          return accumulator;
        }
      };
    },
    provides(providers2) {
      providers2.generateAbstractTransformGrouping = function(_ref) {
        let {
          main,
          transform,
          containerWidth,
          iconWidth
        } = _ref;
        const outer = {
          transform: "translate(".concat(containerWidth / 2, " 256)")
        };
        const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
        const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
        const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
        const inner = {
          transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
        };
        const path = {
          transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
        };
        const operations = {
          outer,
          inner,
          path
        };
        return {
          tag: "g",
          attributes: _objectSpread2({}, operations.outer),
          children: [{
            tag: "g",
            attributes: _objectSpread2({}, operations.inner),
            children: [{
              tag: main.icon.tag,
              children: main.icon.children,
              attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
            }]
          }]
        };
      };
    }
  };
  ALL_SPACE = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
  };
  Masks = {
    hooks() {
      return {
        parseNodeAttributes(accumulator, node) {
          const maskData = node.getAttribute("data-fa-mask");
          const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i4) => i4.trim()));
          if (!mask.prefix) {
            mask.prefix = getDefaultUsablePrefix();
          }
          accumulator.mask = mask;
          accumulator.maskId = node.getAttribute("data-fa-mask-id");
          return accumulator;
        }
      };
    },
    provides(providers2) {
      providers2.generateAbstractMask = function(_ref) {
        let {
          children,
          attributes,
          main,
          mask,
          maskId: explicitMaskId,
          transform
        } = _ref;
        const {
          width: mainWidth,
          icon: mainPath
        } = main;
        const {
          width: maskWidth,
          icon: maskPath
        } = mask;
        const trans = transformForSvg({
          transform,
          containerWidth: maskWidth,
          iconWidth: mainWidth
        });
        const maskRect = {
          tag: "rect",
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            fill: "white"
          })
        };
        const maskInnerGroupChildrenMixin = mainPath.children ? {
          children: mainPath.children.map(fillBlack)
        } : {};
        const maskInnerGroup = {
          tag: "g",
          attributes: _objectSpread2({}, trans.inner),
          children: [fillBlack(_objectSpread2({
            tag: mainPath.tag,
            attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
          }, maskInnerGroupChildrenMixin))]
        };
        const maskOuterGroup = {
          tag: "g",
          attributes: _objectSpread2({}, trans.outer),
          children: [maskInnerGroup]
        };
        const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
        const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
        const maskTag = {
          tag: "mask",
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            id: maskId,
            maskUnits: "userSpaceOnUse",
            maskContentUnits: "userSpaceOnUse"
          }),
          children: [maskRect, maskOuterGroup]
        };
        const defs = {
          tag: "defs",
          children: [{
            tag: "clipPath",
            attributes: {
              id: clipId
            },
            children: deGroup(maskPath)
          }, maskTag]
        };
        children.push(defs, {
          tag: "rect",
          attributes: _objectSpread2({
            fill: "currentColor",
            "clip-path": "url(#".concat(clipId, ")"),
            mask: "url(#".concat(maskId, ")")
          }, ALL_SPACE)
        });
        return {
          children,
          attributes
        };
      };
    }
  };
  MissingIconIndicator = {
    provides(providers2) {
      let reduceMotion = false;
      if (WINDOW.matchMedia) {
        reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
      }
      providers2.missingIconAbstract = function() {
        const gChildren = [];
        const FILL = {
          fill: "currentColor"
        };
        const ANIMATION_BASE = {
          attributeType: "XML",
          repeatCount: "indefinite",
          dur: "2s"
        };
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
          })
        });
        const OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
          attributeName: "opacity"
        });
        const dot = {
          tag: "circle",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            cx: "256",
            cy: "364",
            r: "28"
          }),
          children: []
        };
        if (!reduceMotion) {
          dot.children.push({
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
              attributeName: "r",
              values: "28;14;28;28;14;28;"
            })
          }, {
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "1;0;1;1;0;1;"
            })
          });
        }
        gChildren.push(dot);
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: "1",
            d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
          }),
          children: reduceMotion ? [] : [{
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "1;0;0;0;0;1;"
            })
          }]
        });
        if (!reduceMotion) {
          gChildren.push({
            tag: "path",
            attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
              opacity: "0",
              d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
            }),
            children: [{
              tag: "animate",
              attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
                values: "0;0;1;1;0;0;"
              })
            }]
          });
        }
        return {
          tag: "g",
          attributes: {
            class: "missing"
          },
          children: gChildren
        };
      };
    }
  };
  SvgSymbols = {
    hooks() {
      return {
        parseNodeAttributes(accumulator, node) {
          const symbolData = node.getAttribute("data-fa-symbol");
          const symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
          accumulator["symbol"] = symbol;
          return accumulator;
        }
      };
    }
  };
  plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
  registerPlugins(plugins, {
    mixoutsTo: api
  });
  noAuto$1 = api.noAuto;
  config$1 = api.config;
  library$1 = api.library;
  dom$1 = api.dom;
  parse$1 = api.parse;
  findIconDefinition$1 = api.findIconDefinition;
  toHtml$1 = api.toHtml;
  icon = api.icon;
  layer = api.layer;
  text = api.text;
  counter = api.counter;
});

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faCircleMinus, faMinusCircle, faRightFromBracket, faSignOutAlt, faLaptop, faReply, faBars, faSitemap, faList, faPenToSquare, faEdit, faUsers, faUser, faKey, faBan, faRightToBracket, faSignInAlt, faFilter, faMoneyCheck, faFileExcel, faLocationPin, faMapMarker, faCircle, faMobileScreenButton, faMobileAlt, faWrench, faCircleQuestion, faQuestionCircle, faFloppyDisk, faSave, faArrowRotateRight, faRedo, faPhone, faTrash, faFilePdf, faSuitcaseMedical, faMedkit, faUserSecret, faPhoneVolume, faComment, faEnvelope, faUserDoctor, faUserMd, faCircleInfo, faRectangleList, faListAlt, faGear, faCog, faHouse, faHome, faUpload, faUserLock, faBug, faCreditCard, faFile, faHospital, faFax, faLink, faMagnifyingGlass, faSearch, faSquarePen, faPenSquare, faPlus, faXmark, faTimes, faSpinner, faBuilding, faCalendar, faCirclePlus, faPlusCircle, faBook, faTriangleExclamation, faExclamationTriangle, faBarcode;
var init_free_solid_svg_icons = __esm(() => {
  /*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   */
  faCircleMinus = {
    prefix: "fas",
    iconName: "circle-minus",
    icon: [512, 512, ["minus-circle"], "f056", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM184 232l144 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-144 0c-13.3 0-24-10.7-24-24s10.7-24 24-24z"]
  };
  faMinusCircle = faCircleMinus;
  faRightFromBracket = {
    prefix: "fas",
    iconName: "right-from-bracket",
    icon: [512, 512, ["sign-out-alt"], "f2f5", "M377.9 105.9L500.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L377.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1-128 0c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM160 96L96 96c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c-53 0-96-43-96-96L0 128C0 75 43 32 96 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32z"]
  };
  faSignOutAlt = faRightFromBracket;
  faLaptop = {
    prefix: "fas",
    iconName: "laptop",
    icon: [640, 512, [128187], "f109", "M128 32C92.7 32 64 60.7 64 96l0 256 64 0 0-256 384 0 0 256 64 0 0-256c0-35.3-28.7-64-64-64L128 32zM19.2 384C8.6 384 0 392.6 0 403.2C0 445.6 34.4 480 76.8 480l486.4 0c42.4 0 76.8-34.4 76.8-76.8c0-10.6-8.6-19.2-19.2-19.2L19.2 384z"]
  };
  faReply = {
    prefix: "fas",
    iconName: "reply",
    icon: [512, 512, [61714, "mail-reply"], "f3e5", "M205 34.8c11.5 5.1 19 16.6 19 29.2l0 64 112 0c97.2 0 176 78.8 176 176c0 113.3-81.5 163.9-100.2 174.1c-2.5 1.4-5.3 1.9-8.1 1.9c-10.9 0-19.7-8.9-19.7-19.7c0-7.5 4.3-14.4 9.8-19.5c9.4-8.8 22.2-26.4 22.2-56.7c0-53-43-96-96-96l-96 0 0 64c0 12.6-7.4 24.1-19 29.2s-25 3-34.4-5.4l-160-144C3.9 225.7 0 217.1 0 208s3.9-17.7 10.6-23.8l160-144c9.4-8.5 22.9-10.6 34.4-5.4z"]
  };
  faBars = {
    prefix: "fas",
    iconName: "bars",
    icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
  };
  faSitemap = {
    prefix: "fas",
    iconName: "sitemap",
    icon: [576, 512, [], "f0e8", "M208 80c0-26.5 21.5-48 48-48l64 0c26.5 0 48 21.5 48 48l0 64c0 26.5-21.5 48-48 48l-8 0 0 40 152 0c30.9 0 56 25.1 56 56l0 32 8 0c26.5 0 48 21.5 48 48l0 64c0 26.5-21.5 48-48 48l-64 0c-26.5 0-48-21.5-48-48l0-64c0-26.5 21.5-48 48-48l8 0 0-32c0-4.4-3.6-8-8-8l-152 0 0 40 8 0c26.5 0 48 21.5 48 48l0 64c0 26.5-21.5 48-48 48l-64 0c-26.5 0-48-21.5-48-48l0-64c0-26.5 21.5-48 48-48l8 0 0-40-152 0c-4.4 0-8 3.6-8 8l0 32 8 0c26.5 0 48 21.5 48 48l0 64c0 26.5-21.5 48-48 48l-64 0c-26.5 0-48-21.5-48-48l0-64c0-26.5 21.5-48 48-48l8 0 0-32c0-30.9 25.1-56 56-56l152 0 0-40-8 0c-26.5 0-48-21.5-48-48l0-64z"]
  };
  faList = {
    prefix: "fas",
    iconName: "list",
    icon: [512, 512, ["list-squares"], "f03a", "M40 48C26.7 48 16 58.7 16 72l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24L40 48zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM16 232l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24zM40 368c-13.3 0-24 10.7-24 24l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0z"]
  };
  faPenToSquare = {
    prefix: "fas",
    iconName: "pen-to-square",
    icon: [512, 512, ["edit"], "f044", "M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160L0 416c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-96c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 64z"]
  };
  faEdit = faPenToSquare;
  faUsers = {
    prefix: "fas",
    iconName: "users",
    icon: [640, 512, [], "f0c0", "M144 0a80 80 0 1 1 0 160A80 80 0 1 1 144 0zM512 0a80 80 0 1 1 0 160A80 80 0 1 1 512 0zM0 298.7C0 239.8 47.8 192 106.7 192l42.7 0c15.9 0 31 3.5 44.6 9.7c-1.3 7.2-1.9 14.7-1.9 22.3c0 38.2 16.8 72.5 43.3 96c-.2 0-.4 0-.7 0L21.3 320C9.6 320 0 310.4 0 298.7zM405.3 320c-.2 0-.4 0-.7 0c26.6-23.5 43.3-57.8 43.3-96c0-7.6-.7-15-1.9-22.3c13.6-6.3 28.7-9.7 44.6-9.7l42.7 0C592.2 192 640 239.8 640 298.7c0 11.8-9.6 21.3-21.3 21.3l-213.3 0zM224 224a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zM128 485.3C128 411.7 187.7 352 261.3 352l117.3 0C452.3 352 512 411.7 512 485.3c0 14.7-11.9 26.7-26.7 26.7l-330.7 0c-14.7 0-26.7-11.9-26.7-26.7z"]
  };
  faUser = {
    prefix: "fas",
    iconName: "user",
    icon: [448, 512, [128100, 62144], "f007", "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l388.6 0c16.4 0 29.7-13.3 29.7-29.7C448 383.8 368.2 304 269.7 304l-91.4 0z"]
  };
  faKey = {
    prefix: "fas",
    iconName: "key",
    icon: [512, 512, [128273], "f084", "M336 352c97.2 0 176-78.8 176-176S433.2 0 336 0S160 78.8 160 176c0 18.7 2.9 36.8 8.3 53.7L7 391c-4.5 4.5-7 10.6-7 17l0 80c0 13.3 10.7 24 24 24l80 0c13.3 0 24-10.7 24-24l0-40 40 0c13.3 0 24-10.7 24-24l0-40 40 0c6.4 0 12.5-2.5 17-7l33.3-33.3c16.9 5.4 35 8.3 53.7 8.3zM376 96a40 40 0 1 1 0 80 40 40 0 1 1 0-80z"]
  };
  faBan = {
    prefix: "fas",
    iconName: "ban",
    icon: [512, 512, [128683, "cancel"], "f05e", "M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z"]
  };
  faRightToBracket = {
    prefix: "fas",
    iconName: "right-to-bracket",
    icon: [512, 512, ["sign-in-alt"], "f2f6", "M217.9 105.9L340.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L217.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1L32 320c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM352 416l64 0c17.7 0 32-14.3 32-32l0-256c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64 0c53 0 96 43 96 96l0 256c0 53-43 96-96 96l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"]
  };
  faSignInAlt = faRightToBracket;
  faFilter = {
    prefix: "fas",
    iconName: "filter",
    icon: [512, 512, [], "f0b0", "M3.9 54.9C10.5 40.9 24.5 32 40 32l432 0c15.5 0 29.5 8.9 36.1 22.9s4.6 30.5-5.2 42.5L320 320.9 320 448c0 12.1-6.8 23.2-17.7 28.6s-23.8 4.3-33.5-3l-64-48c-8.1-6-12.8-15.5-12.8-25.6l0-79.1L9 97.3C-.7 85.4-2.8 68.8 3.9 54.9z"]
  };
  faMoneyCheck = {
    prefix: "fas",
    iconName: "money-check",
    icon: [576, 512, [], "f53c", "M64 64C28.7 64 0 92.7 0 128L0 384c0 35.3 28.7 64 64 64l448 0c35.3 0 64-28.7 64-64l0-256c0-35.3-28.7-64-64-64L64 64zm48 160l160 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-160 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zM96 336c0-8.8 7.2-16 16-16l352 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-352 0c-8.8 0-16-7.2-16-16zM376 160l80 0c13.3 0 24 10.7 24 24l0 48c0 13.3-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24l0-48c0-13.3 10.7-24 24-24z"]
  };
  faFileExcel = {
    prefix: "fas",
    iconName: "file-excel",
    icon: [384, 512, [], "f1c3", "M64 0C28.7 0 0 28.7 0 64L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-288-128 0c-17.7 0-32-14.3-32-32L224 0 64 0zM256 0l0 128 128 0L256 0zM155.7 250.2L192 302.1l36.3-51.9c7.6-10.9 22.6-13.5 33.4-5.9s13.5 22.6 5.9 33.4L221.3 344l46.4 66.2c7.6 10.9 5 25.8-5.9 33.4s-25.8 5-33.4-5.9L192 385.8l-36.3 51.9c-7.6 10.9-22.6 13.5-33.4 5.9s-13.5-22.6-5.9-33.4L162.7 344l-46.4-66.2c-7.6-10.9-5-25.8 5.9-33.4s25.8-5 33.4 5.9z"]
  };
  faLocationPin = {
    prefix: "fas",
    iconName: "location-pin",
    icon: [384, 512, ["map-marker"], "f041", "M384 192c0 87.4-117 243-168.3 307.2c-12.3 15.3-35.1 15.3-47.4 0C117 435 0 279.4 0 192C0 86 86 0 192 0S384 86 384 192z"]
  };
  faMapMarker = faLocationPin;
  faCircle = {
    prefix: "fas",
    iconName: "circle",
    icon: [512, 512, [128308, 128309, 128992, 128993, 128994, 128995, 128996, 9679, 9898, 9899, 11044, 61708, 61915], "f111", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"]
  };
  faMobileScreenButton = {
    prefix: "fas",
    iconName: "mobile-screen-button",
    icon: [384, 512, ["mobile-alt"], "f3cd", "M16 64C16 28.7 44.7 0 80 0L304 0c35.3 0 64 28.7 64 64l0 384c0 35.3-28.7 64-64 64L80 512c-35.3 0-64-28.7-64-64L16 64zM224 448a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM304 64L80 64l0 320 224 0 0-320z"]
  };
  faMobileAlt = faMobileScreenButton;
  faWrench = {
    prefix: "fas",
    iconName: "wrench",
    icon: [512, 512, [128295], "f0ad", "M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7L336 192c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"]
  };
  faCircleQuestion = {
    prefix: "fas",
    iconName: "circle-question",
    icon: [512, 512, [62108, "question-circle"], "f059", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM169.8 165.3c7.9-22.3 29.1-37.3 52.8-37.3l58.3 0c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24l0-13.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1l-58.3 0c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
  };
  faQuestionCircle = faCircleQuestion;
  faFloppyDisk = {
    prefix: "fas",
    iconName: "floppy-disk",
    icon: [448, 512, [128190, 128426, "save"], "f0c7", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-242.7c0-17-6.7-33.3-18.7-45.3L352 50.7C340 38.7 323.7 32 306.7 32L64 32zm0 96c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32l0 64c0 17.7-14.3 32-32 32L96 224c-17.7 0-32-14.3-32-32l0-64zM224 288a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"]
  };
  faSave = faFloppyDisk;
  faArrowRotateRight = {
    prefix: "fas",
    iconName: "arrow-rotate-right",
    icon: [512, 512, [8635, "arrow-right-rotate", "arrow-rotate-forward", "redo"], "f01e", "M386.3 160L336 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l128 0c17.7 0 32-14.3 32-32l0-128c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0s-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3s163.8-62.5 226.3 0L386.3 160z"]
  };
  faRedo = faArrowRotateRight;
  faPhone = {
    prefix: "fas",
    iconName: "phone",
    icon: [512, 512, [128222, 128379], "f095", "M164.9 24.6c-7.7-18.6-28-28.5-47.4-23.2l-88 24C12.1 30.2 0 46 0 64C0 311.4 200.6 512 448 512c18 0 33.8-12.1 38.6-29.5l24-88c5.3-19.4-4.6-39.7-23.2-47.4l-96-40c-16.3-6.8-35.2-2.1-46.3 11.6L304.7 368C234.3 334.7 177.3 277.7 144 207.3L193.3 167c13.7-11.2 18.4-30 11.6-46.3l-40-96z"]
  };
  faTrash = {
    prefix: "fas",
    iconName: "trash",
    icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z"]
  };
  faFilePdf = {
    prefix: "fas",
    iconName: "file-pdf",
    icon: [512, 512, [], "f1c1", "M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 144-208 0c-35.3 0-64 28.7-64 64l0 144-48 0c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM176 352l32 0c30.9 0 56 25.1 56 56s-25.1 56-56 56l-16 0 0 32c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-48 0-80c0-8.8 7.2-16 16-16zm32 80c13.3 0 24-10.7 24-24s-10.7-24-24-24l-16 0 0 48 16 0zm96-80l32 0c26.5 0 48 21.5 48 48l0 64c0 26.5-21.5 48-48 48l-32 0c-8.8 0-16-7.2-16-16l0-128c0-8.8 7.2-16 16-16zm32 128c8.8 0 16-7.2 16-16l0-64c0-8.8-7.2-16-16-16l-16 0 0 96 16 0zm80-112c0-8.8 7.2-16 16-16l48 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-32 0 0 32 32 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-32 0 0 48c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-64 0-64z"]
  };
  faSuitcaseMedical = {
    prefix: "fas",
    iconName: "suitcase-medical",
    icon: [512, 512, ["medkit"], "f0fa", "M184 48l144 0c4.4 0 8 3.6 8 8l0 40L176 96l0-40c0-4.4 3.6-8 8-8zm-56 8l0 40 0 32 0 352 256 0 0-352 0-32 0-40c0-30.9-25.1-56-56-56L184 0c-30.9 0-56 25.1-56 56zM96 96L64 96C28.7 96 0 124.7 0 160L0 416c0 35.3 28.7 64 64 64l32 0L96 96zM416 480l32 0c35.3 0 64-28.7 64-64l0-256c0-35.3-28.7-64-64-64l-32 0 0 384zM224 208c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 48 48 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-48 0 0 48c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-48-48 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16l48 0 0-48z"]
  };
  faMedkit = faSuitcaseMedical;
  faUserSecret = {
    prefix: "fas",
    iconName: "user-secret",
    icon: [448, 512, [128373], "f21b", "M224 16c-6.7 0-10.8-2.8-15.5-6.1C201.9 5.4 194 0 176 0c-30.5 0-52 43.7-66 89.4C62.7 98.1 32 112.2 32 128c0 14.3 25 27.1 64.6 35.9c-.4 4-.6 8-.6 12.1c0 17 3.3 33.2 9.3 48l-59.9 0C38 224 32 230 32 237.4c0 1.7 .3 3.4 1 5l38.8 96.9C28.2 371.8 0 423.8 0 482.3C0 498.7 13.3 512 29.7 512l388.6 0c16.4 0 29.7-13.3 29.7-29.7c0-58.5-28.2-110.4-71.7-143L415 242.4c.6-1.6 1-3.3 1-5c0-7.4-6-13.4-13.4-13.4l-59.9 0c6-14.8 9.3-31 9.3-48c0-4.1-.2-8.1-.6-12.1C391 155.1 416 142.3 416 128c0-15.8-30.7-29.9-78-38.6C324 43.7 302.5 0 272 0c-18 0-25.9 5.4-32.5 9.9c-4.8 3.3-8.8 6.1-15.5 6.1zm56 208l-12.4 0c-16.5 0-31.1-10.6-36.3-26.2c-2.3-7-12.2-7-14.5 0c-5.2 15.6-19.9 26.2-36.3 26.2L168 224c-22.1 0-40-17.9-40-40l0-14.4c28.2 4.1 61 6.4 96 6.4s67.8-2.3 96-6.4l0 14.4c0 22.1-17.9 40-40 40zm-88 96l16 32L176 480 128 288l64 32zm128-32L272 480 240 352l16-32 64-32z"]
  };
  faPhoneVolume = {
    prefix: "fas",
    iconName: "phone-volume",
    icon: [512, 512, ["volume-control-phone"], "f2a0", "M280 0C408.1 0 512 103.9 512 232c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-101.6-82.4-184-184-184c-13.3 0-24-10.7-24-24s10.7-24 24-24zm8 192a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm-32-72c0-13.3 10.7-24 24-24c75.1 0 136 60.9 136 136c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-48.6-39.4-88-88-88c-13.3 0-24-10.7-24-24zM117.5 1.4c19.4-5.3 39.7 4.6 47.4 23.2l40 96c6.8 16.3 2.1 35.2-11.6 46.3L144 207.3c33.3 70.4 90.3 127.4 160.7 160.7L345 318.7c11.2-13.7 30-18.4 46.3-11.6l96 40c18.6 7.7 28.5 28 23.2 47.4l-24 88C481.8 499.9 466 512 448 512C200.6 512 0 311.4 0 64C0 46 12.1 30.2 29.5 25.4l88-24z"]
  };
  faComment = {
    prefix: "fas",
    iconName: "comment",
    icon: [512, 512, [128489, 61669], "f075", "M512 240c0 114.9-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6C73.6 471.1 44.7 480 16 480c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c0 0 0 0 0 0s0 0 0 0s0 0 0 0c0 0 0 0 0 0l.3-.3c.3-.3 .7-.7 1.3-1.4c1.1-1.2 2.8-3.1 4.9-5.7c4.1-5 9.6-12.4 15.2-21.6c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208z"]
  };
  faEnvelope = {
    prefix: "fas",
    iconName: "envelope",
    icon: [512, 512, [128386, 9993, 61443], "f0e0", "M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48L48 64zM0 176L0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-208L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"]
  };
  faUserDoctor = {
    prefix: "fas",
    iconName: "user-doctor",
    icon: [448, 512, ["user-md"], "f0f0", "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-96 55.2C54 332.9 0 401.3 0 482.3C0 498.7 13.3 512 29.7 512l388.6 0c16.4 0 29.7-13.3 29.7-29.7c0-81-54-149.4-128-171.1l0 50.8c27.6 7.1 48 32.2 48 62l0 40c0 8.8-7.2 16-16 16l-16 0c-8.8 0-16-7.2-16-16s7.2-16 16-16l0-24c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 24c8.8 0 16 7.2 16 16s-7.2 16-16 16l-16 0c-8.8 0-16-7.2-16-16l0-40c0-29.8 20.4-54.9 48-62l0-57.1c-6-.6-12.1-.9-18.3-.9l-91.4 0c-6.2 0-12.3 .3-18.3 .9l0 65.4c23.1 6.9 40 28.3 40 53.7c0 30.9-25.1 56-56 56s-56-25.1-56-56c0-25.4 16.9-46.8 40-53.7l0-59.1zM144 448a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"]
  };
  faUserMd = faUserDoctor;
  faCircleInfo = {
    prefix: "fas",
    iconName: "circle-info",
    icon: [512, 512, ["info-circle"], "f05a", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"]
  };
  faRectangleList = {
    prefix: "fas",
    iconName: "rectangle-list",
    icon: [576, 512, ["list-alt"], "f022", "M0 96C0 60.7 28.7 32 64 32l448 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM128 288a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm32-128a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM128 384a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm96-248c-13.3 0-24 10.7-24 24s10.7 24 24 24l224 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-224 0zm0 96c-13.3 0-24 10.7-24 24s10.7 24 24 24l224 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-224 0zm0 96c-13.3 0-24 10.7-24 24s10.7 24 24 24l224 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-224 0z"]
  };
  faListAlt = faRectangleList;
  faGear = {
    prefix: "fas",
    iconName: "gear",
    icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
  };
  faCog = faGear;
  faHouse = {
    prefix: "fas",
    iconName: "house",
    icon: [576, 512, [127968, 63498, 63500, "home", "home-alt", "home-lg-alt"], "f015", "M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"]
  };
  faHome = faHouse;
  faUpload = {
    prefix: "fas",
    iconName: "upload",
    icon: [512, 512, [], "f093", "M288 109.3L288 352c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-242.7-73.4 73.4c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l128-128c12.5-12.5 32.8-12.5 45.3 0l128 128c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L288 109.3zM64 352l128 0c0 35.3 28.7 64 64 64s64-28.7 64-64l128 0c35.3 0 64 28.7 64 64l0 32c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64l0-32c0-35.3 28.7-64 64-64zM432 456a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"]
  };
  faUserLock = {
    prefix: "fas",
    iconName: "user-lock",
    icon: [640, 512, [], "f502", "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l362.8 0c-5.4-9.4-8.6-20.3-8.6-32l0-128c0-2.1 .1-4.2 .3-6.3c-31-26-71-41.7-114.6-41.7l-91.4 0zM528 240c17.7 0 32 14.3 32 32l0 48-64 0 0-48c0-17.7 14.3-32 32-32zm-80 32l0 48c-17.7 0-32 14.3-32 32l0 128c0 17.7 14.3 32 32 32l160 0c17.7 0 32-14.3 32-32l0-128c0-17.7-14.3-32-32-32l0-48c0-44.2-35.8-80-80-80s-80 35.8-80 80z"]
  };
  faBug = {
    prefix: "fas",
    iconName: "bug",
    icon: [512, 512, [], "f188", "M256 0c53 0 96 43 96 96l0 3.6c0 15.7-12.7 28.4-28.4 28.4l-135.1 0c-15.7 0-28.4-12.7-28.4-28.4l0-3.6c0-53 43-96 96-96zM41.4 105.4c12.5-12.5 32.8-12.5 45.3 0l64 64c.7 .7 1.3 1.4 1.9 2.1c14.2-7.3 30.4-11.4 47.5-11.4l112 0c17.1 0 33.2 4.1 47.5 11.4c.6-.7 1.2-1.4 1.9-2.1l64-64c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-64 64c-.7 .7-1.4 1.3-2.1 1.9c6.2 12 10.1 25.3 11.1 39.5l64.3 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c0 24.6-5.5 47.8-15.4 68.6c2.2 1.3 4.2 2.9 6 4.8l64 64c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0l-63.1-63.1c-24.5 21.8-55.8 36.2-90.3 39.6L272 240c0-8.8-7.2-16-16-16s-16 7.2-16 16l0 239.2c-34.5-3.4-65.8-17.8-90.3-39.6L86.6 502.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l64-64c1.9-1.9 3.9-3.4 6-4.8C101.5 367.8 96 344.6 96 320l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64.3 0c1.1-14.1 5-27.5 11.1-39.5c-.7-.6-1.4-1.2-2.1-1.9l-64-64c-12.5-12.5-12.5-32.8 0-45.3z"]
  };
  faCreditCard = {
    prefix: "fas",
    iconName: "credit-card",
    icon: [576, 512, [128179, 62083, "credit-card-alt"], "f09d", "M64 32C28.7 32 0 60.7 0 96l0 32 576 0 0-32c0-35.3-28.7-64-64-64L64 32zM576 224L0 224 0 416c0 35.3 28.7 64 64 64l448 0c35.3 0 64-28.7 64-64l0-192zM112 352l64 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-64 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zm112 16c0-8.8 7.2-16 16-16l128 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-128 0c-8.8 0-16-7.2-16-16z"]
  };
  faFile = {
    prefix: "fas",
    iconName: "file",
    icon: [384, 512, [128196, 128459, 61462], "f15b", "M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 288c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128z"]
  };
  faHospital = {
    prefix: "fas",
    iconName: "hospital",
    icon: [640, 512, [127973, 62589, "hospital-alt", "hospital-wide"], "f0f8", "M192 48c0-26.5 21.5-48 48-48L400 0c26.5 0 48 21.5 48 48l0 464-80 0 0-80c0-26.5-21.5-48-48-48s-48 21.5-48 48l0 80-80 0 0-464zM48 96l112 0 0 416L48 512c-26.5 0-48-21.5-48-48L0 320l80 0c8.8 0 16-7.2 16-16s-7.2-16-16-16L0 288l0-64 80 0c8.8 0 16-7.2 16-16s-7.2-16-16-16L0 192l0-48c0-26.5 21.5-48 48-48zm544 0c26.5 0 48 21.5 48 48l0 48-80 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l80 0 0 64-80 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l80 0 0 144c0 26.5-21.5 48-48 48l-112 0 0-416 112 0zM312 64c-8.8 0-16 7.2-16 16l0 24-24 0c-8.8 0-16 7.2-16 16l0 16c0 8.8 7.2 16 16 16l24 0 0 24c0 8.8 7.2 16 16 16l16 0c8.8 0 16-7.2 16-16l0-24 24 0c8.8 0 16-7.2 16-16l0-16c0-8.8-7.2-16-16-16l-24 0 0-24c0-8.8-7.2-16-16-16l-16 0z"]
  };
  faFax = {
    prefix: "fas",
    iconName: "fax",
    icon: [512, 512, [128224, 128439], "f1ac", "M128 64l0 96 64 0 0-96 194.7 0L416 93.3l0 66.7 64 0 0-66.7c0-17-6.7-33.3-18.7-45.3L432 18.7C420 6.7 403.7 0 386.7 0L192 0c-35.3 0-64 28.7-64 64zM0 160L0 480c0 17.7 14.3 32 32 32l32 0c17.7 0 32-14.3 32-32l0-320c0-17.7-14.3-32-32-32l-32 0c-17.7 0-32 14.3-32 32zm480 32l-352 0 0 288c0 17.7 14.3 32 32 32l320 0c17.7 0 32-14.3 32-32l0-256c0-17.7-14.3-32-32-32zM256 256a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm96 32a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm32 96a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM224 416a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
  };
  faLink = {
    prefix: "fas",
    iconName: "link",
    icon: [640, 512, [128279, "chain"], "f0c1", "M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"]
  };
  faMagnifyingGlass = {
    prefix: "fas",
    iconName: "magnifying-glass",
    icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
  };
  faSearch = faMagnifyingGlass;
  faSquarePen = {
    prefix: "fas",
    iconName: "square-pen",
    icon: [448, 512, ["pen-square", "pencil-square"], "f14b", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM325.8 139.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-21.4 21.4-71-71 21.4-21.4c15.6-15.6 40.9-15.6 56.6 0zM119.9 289L225.1 183.8l71 71L190.9 359.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"]
  };
  faPenSquare = faSquarePen;
  faPlus = {
    prefix: "fas",
    iconName: "plus",
    icon: [448, 512, [10133, 61543, "add"], "2b", "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"]
  };
  faXmark = {
    prefix: "fas",
    iconName: "xmark",
    icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
  };
  faTimes = faXmark;
  faSpinner = {
    prefix: "fas",
    iconName: "spinner",
    icon: [512, 512, [], "f110", "M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z"]
  };
  faBuilding = {
    prefix: "fas",
    iconName: "building",
    icon: [384, 512, [127970, 61687], "f1ad", "M48 0C21.5 0 0 21.5 0 48L0 464c0 26.5 21.5 48 48 48l96 0 0-80c0-26.5 21.5-48 48-48s48 21.5 48 48l0 80 96 0c26.5 0 48-21.5 48-48l0-416c0-26.5-21.5-48-48-48L48 0zM64 240c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32zm112-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16zm80 16c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32zM80 96l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16zm80 16c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32zM272 96l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16z"]
  };
  faCalendar = {
    prefix: "fas",
    iconName: "calendar",
    icon: [448, 512, [128197, 128198], "f133", "M96 32l0 32L48 64C21.5 64 0 85.5 0 112l0 48 448 0 0-48c0-26.5-21.5-48-48-48l-48 0 0-32c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 32L160 64l0-32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192L0 192 0 464c0 26.5 21.5 48 48 48l352 0c26.5 0 48-21.5 48-48l0-272z"]
  };
  faCirclePlus = {
    prefix: "fas",
    iconName: "circle-plus",
    icon: [512, 512, ["plus-circle"], "f055", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM232 344l0-64-64 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l64 0 0-64c0-13.3 10.7-24 24-24s24 10.7 24 24l0 64 64 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-64 0 0 64c0 13.3-10.7 24-24 24s-24-10.7-24-24z"]
  };
  faPlusCircle = faCirclePlus;
  faBook = {
    prefix: "fas",
    iconName: "book",
    icon: [448, 512, [128212], "f02d", "M96 0C43 0 0 43 0 96L0 416c0 53 43 96 96 96l288 0 32 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l0-64c17.7 0 32-14.3 32-32l0-320c0-17.7-14.3-32-32-32L384 0 96 0zm0 384l256 0 0 64L96 448c-17.7 0-32-14.3-32-32s14.3-32 32-32zm32-240c0-8.8 7.2-16 16-16l192 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-192 0c-8.8 0-16-7.2-16-16zm16 48l192 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-192 0c-8.8 0-16-7.2-16-16s7.2-16 16-16z"]
  };
  faTriangleExclamation = {
    prefix: "fas",
    iconName: "triangle-exclamation",
    icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"]
  };
  faExclamationTriangle = faTriangleExclamation;
  faBarcode = {
    prefix: "fas",
    iconName: "barcode",
    icon: [512, 512, [], "f02a", "M24 32C10.7 32 0 42.7 0 56L0 456c0 13.3 10.7 24 24 24l16 0c13.3 0 24-10.7 24-24L64 56c0-13.3-10.7-24-24-24L24 32zm88 0c-8.8 0-16 7.2-16 16l0 416c0 8.8 7.2 16 16 16s16-7.2 16-16l0-416c0-8.8-7.2-16-16-16zm72 0c-13.3 0-24 10.7-24 24l0 400c0 13.3 10.7 24 24 24l16 0c13.3 0 24-10.7 24-24l0-400c0-13.3-10.7-24-24-24l-16 0zm96 0c-13.3 0-24 10.7-24 24l0 400c0 13.3 10.7 24 24 24l16 0c13.3 0 24-10.7 24-24l0-400c0-13.3-10.7-24-24-24l-16 0zM448 56l0 400c0 13.3 10.7 24 24 24l16 0c13.3 0 24-10.7 24-24l0-400c0-13.3-10.7-24-24-24l-16 0c-13.3 0-24 10.7-24 24zm-64-8l0 416c0 8.8 7.2 16 16 16s16-7.2 16-16l0-416c0-8.8-7.2-16-16-16s-16 7.2-16 16z"]
  };
});

// app/javascript/awesome.js
var exports_awesome = {};
var init_awesome = __esm(() => {
  init_fontawesome_svg_core();
  init_free_solid_svg_icons();
  config$1.mutateApproach = "sync";
  library$1.add(faBan, faBarcode, faBars, faBook, faBuilding, faBug, faCalendar, faCircle, faCircleInfo, faCog, faComment, faCreditCard, faEdit, faEnvelope, faExclamationTriangle, faFax, faFile, faFileExcel, faFilePdf, faFilter, faHome, faHospital, faKey, faLaptop, faLink, faList, faListAlt, faMedkit, faMapMarker, faMinusCircle, faMobileAlt, faMoneyCheck, faQuestionCircle, faPenSquare, faPlus, faPlusCircle, faPhone, faPhoneVolume, faRedo, faReply, faSave, faSearch, faSitemap, faSignInAlt, faSignOutAlt, faSpinner, faSuitcaseMedical, faTimes, faTrash, faUpload, faUser, faUserLock, faUserMd, faUsers, faUserSecret, faWrench);
  dom$1.watch();
});

// node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
var exports_turbo_es2017_esm = {};
__export(exports_turbo_es2017_esm, {
  visit: () => visit,
  start: () => start,
  setProgressBarDelay: () => setProgressBarDelay,
  setFormMode: () => setFormMode,
  setConfirmMethod: () => setConfirmMethod,
  session: () => session,
  renderStreamMessage: () => renderStreamMessage,
  registerAdapter: () => registerAdapter,
  navigator: () => navigator$1,
  isSafe: () => isSafe,
  fetchMethodFromString: () => fetchMethodFromString,
  fetchEnctypeFromString: () => fetchEnctypeFromString,
  fetch: () => fetchWithTurboHeaders,
  disconnectStreamSource: () => disconnectStreamSource,
  connectStreamSource: () => connectStreamSource,
  config: () => config,
  clearCache: () => clearCache,
  cache: () => cache,
  StreamSourceElement: () => StreamSourceElement,
  StreamElement: () => StreamElement,
  StreamActions: () => StreamActions,
  PageSnapshot: () => PageSnapshot,
  PageRenderer: () => PageRenderer,
  FrameRenderer: () => FrameRenderer,
  FrameLoadingStyle: () => FrameLoadingStyle,
  FrameElement: () => FrameElement,
  FetchResponse: () => FetchResponse,
  FetchRequest: () => FetchRequest,
  FetchMethod: () => FetchMethod,
  FetchEnctype: () => FetchEnctype
});
/*!
Turbo 8.0.13
Copyright  2025 37signals LLC
 */
(function(prototype) {
  if (typeof prototype.requestSubmit == "function")
    return;
  prototype.requestSubmit = function(submitter) {
    if (submitter) {
      validateSubmitter(submitter, this);
      submitter.click();
    } else {
      submitter = document.createElement("input");
      submitter.type = "submit";
      submitter.hidden = true;
      this.appendChild(submitter);
      submitter.click();
      this.removeChild(submitter);
    }
  };
  function validateSubmitter(submitter, form) {
    submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }
  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
  }
})(HTMLFormElement.prototype);
var submittersByForm = new WeakMap;
function findSubmitterFromClickTarget(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return candidate?.type == "submit" ? candidate : null;
}
function clickCaptured(event) {
  const submitter = findSubmitterFromClickTarget(event.target);
  if (submitter && submitter.form) {
    submittersByForm.set(submitter.form, submitter);
  }
}
(function() {
  if ("submitter" in Event.prototype)
    return;
  let prototype = window.Event.prototype;
  if ("SubmitEvent" in window) {
    const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
    if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
      prototype = prototypeOfSubmitEvent;
    } else {
      return;
    }
  }
  addEventListener("click", clickCaptured, true);
  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target);
      }
    }
  });
})();
var FrameLoadingStyle = {
  eager: "eager",
  lazy: "lazy"
};

class FrameElement extends HTMLElement {
  static delegateConstructor = undefined;
  loaded = Promise.resolve();
  static get observedAttributes() {
    return ["disabled", "loading", "src"];
  }
  constructor() {
    super();
    this.delegate = new FrameElement.delegateConstructor(this);
  }
  connectedCallback() {
    this.delegate.connect();
  }
  disconnectedCallback() {
    this.delegate.disconnect();
  }
  reload() {
    return this.delegate.sourceURLReloaded();
  }
  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else if (name == "disabled") {
      this.delegate.disabledChanged();
    }
  }
  get src() {
    return this.getAttribute("src");
  }
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }
  get refresh() {
    return this.getAttribute("refresh");
  }
  set refresh(value) {
    if (value) {
      this.setAttribute("refresh", value);
    } else {
      this.removeAttribute("refresh");
    }
  }
  get shouldReloadWithMorph() {
    return this.src && this.refresh === "morph";
  }
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "");
  }
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }
  get disabled() {
    return this.hasAttribute("disabled");
  }
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }
  get autoscroll() {
    return this.hasAttribute("autoscroll");
  }
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }
  get complete() {
    return !this.delegate.isLoading;
  }
  get isActive() {
    return this.ownerDocument === document && !this.isPreview;
  }
  get isPreview() {
    return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
  }
}
function frameLoadingStyleFromString(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy;
    default:
      return FrameLoadingStyle.eager;
  }
}
var drive = {
  enabled: true,
  progressBarDelay: 500,
  unvisitableExtensions: new Set([
    ".7z",
    ".aac",
    ".apk",
    ".avi",
    ".bmp",
    ".bz2",
    ".css",
    ".csv",
    ".deb",
    ".dmg",
    ".doc",
    ".docx",
    ".exe",
    ".gif",
    ".gz",
    ".heic",
    ".heif",
    ".ico",
    ".iso",
    ".jpeg",
    ".jpg",
    ".js",
    ".json",
    ".m4a",
    ".mkv",
    ".mov",
    ".mp3",
    ".mp4",
    ".mpeg",
    ".mpg",
    ".msi",
    ".ogg",
    ".ogv",
    ".pdf",
    ".pkg",
    ".png",
    ".ppt",
    ".pptx",
    ".rar",
    ".rtf",
    ".svg",
    ".tar",
    ".tif",
    ".tiff",
    ".txt",
    ".wav",
    ".webm",
    ".webp",
    ".wma",
    ".wmv",
    ".xls",
    ".xlsx",
    ".xml",
    ".zip"
  ])
};
function activateScriptElement(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element;
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce = getCspNonce();
    if (cspNonce) {
      createdScriptElement.nonce = cspNonce;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement;
  }
}
function copyElementAttributes(destinationElement, sourceElement) {
  for (const { name, value } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
}
function createDocumentFragment(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function dispatch(eventName, { target, cancelable, detail } = {}) {
  const event = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });
  if (target && target.isConnected) {
    target.dispatchEvent(event);
  } else {
    document.documentElement.dispatchEvent(event);
  }
  return event;
}
function cancelEvent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function nextRepaint() {
  if (document.visibilityState === "hidden") {
    return nextEventLoopTick();
  } else {
    return nextAnimationFrame();
  }
}
function nextAnimationFrame() {
  return new Promise((resolve) => requestAnimationFrame(() => resolve()));
}
function nextEventLoopTick() {
  return new Promise((resolve) => setTimeout(() => resolve(), 0));
}
function nextMicrotask() {
  return Promise.resolve();
}
function parseHTMLDocument(html = "") {
  return new DOMParser().parseFromString(html, "text/html");
}
function unindent(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split(`
`);
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map((line) => line.slice(indent)).join(`
`);
}
function interpolate(strings, values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] == undefined ? "" : values[i];
    return result + string + value;
  }, "");
}
function uuid() {
  return Array.from({ length: 36 }).map((_, i) => {
    if (i == 8 || i == 13 || i == 18 || i == 23) {
      return "-";
    } else if (i == 14) {
      return "4";
    } else if (i == 19) {
      return (Math.floor(Math.random() * 4) + 8).toString(16);
    } else {
      return Math.floor(Math.random() * 15).toString(16);
    }
  }).join("");
}
function getAttribute(attributeName, ...elements) {
  for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
    if (typeof value == "string")
      return value;
  }
  return null;
}
function hasAttribute(attributeName, ...elements) {
  return elements.some((element) => element && element.hasAttribute(attributeName));
}
function markAsBusy(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
}
function clearBusyState(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }
    element.removeAttribute("aria-busy");
  }
}
function waitForLoad(element, timeoutInMilliseconds = 2000) {
  return new Promise((resolve) => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve();
    };
    element.addEventListener("load", onComplete, { once: true });
    element.addEventListener("error", onComplete, { once: true });
    setTimeout(resolve, timeoutInMilliseconds);
  });
}
function getHistoryMethodForAction(action) {
  switch (action) {
    case "replace":
      return history.replaceState;
    case "advance":
    case "restore":
      return history.pushState;
  }
}
function isAction(action) {
  return action == "advance" || action == "replace" || action == "restore";
}
function getVisitAction(...elements) {
  const action = getAttribute("data-turbo-action", ...elements);
  return isAction(action) ? action : null;
}
function getMetaElement(name) {
  return document.querySelector(`meta[name="${name}"]`);
}
function getMetaContent(name) {
  const element = getMetaElement(name);
  return element && element.content;
}
function getCspNonce() {
  const element = getMetaElement("csp-nonce");
  if (element) {
    const { nonce, content } = element;
    return nonce == "" ? content : nonce;
  }
}
function setMetaContent(name, content) {
  let element = getMetaElement(name);
  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);
    document.head.appendChild(element);
  }
  element.setAttribute("content", content);
  return element;
}
function findClosestRecursively(element, selector) {
  if (element instanceof Element) {
    return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
  }
}
function elementIsFocusable(element) {
  const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
}
function queryAutofocusableElement(elementOrDocumentFragment) {
  return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
}
async function around(callback, reader) {
  const before = reader();
  callback();
  await nextAnimationFrame();
  const after = reader();
  return [before, after];
}
function doesNotTargetIFrame(name) {
  if (name === "_blank") {
    return false;
  } else if (name) {
    for (const element of document.getElementsByName(name)) {
      if (element instanceof HTMLIFrameElement)
        return false;
    }
    return true;
  } else {
    return true;
  }
}
function findLinkFromClickTarget(target) {
  return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
}
function getLocationForLink(link) {
  return expandURL(link.getAttribute("href") || "");
}
function debounce(fn, delay) {
  let timeoutId = null;
  return (...args) => {
    const callback = () => fn.apply(this, args);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(callback, delay);
  };
}
var submitter = {
  "aria-disabled": {
    beforeSubmit: (submitter2) => {
      submitter2.setAttribute("aria-disabled", "true");
      submitter2.addEventListener("click", cancelEvent);
    },
    afterSubmit: (submitter2) => {
      submitter2.removeAttribute("aria-disabled");
      submitter2.removeEventListener("click", cancelEvent);
    }
  },
  disabled: {
    beforeSubmit: (submitter2) => submitter2.disabled = true,
    afterSubmit: (submitter2) => submitter2.disabled = false
  }
};

class Config {
  #submitter = null;
  constructor(config) {
    Object.assign(this, config);
  }
  get submitter() {
    return this.#submitter;
  }
  set submitter(value) {
    this.#submitter = submitter[value] || value;
  }
}
var forms = new Config({
  mode: "on",
  submitter: "disabled"
});
var config = {
  drive,
  forms
};
function expandURL(locatable) {
  return new URL(locatable.toString(), document.baseURI);
}
function getAnchor(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1);
  } else if (anchorMatch = url.href.match(/#(.*)$/)) {
    return anchorMatch[1];
  }
}
function getAction$1(form, submitter2) {
  const action = submitter2?.getAttribute("formaction") || form.getAttribute("action") || form.action;
  return expandURL(action);
}
function getExtension(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
}
function isPrefixedBy(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
}
function locationIsVisitable(location2, rootLocation) {
  return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
}
function getRequestURL(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
}
function toCacheKey(url) {
  return getRequestURL(url);
}
function urlsAreEqual(left, right) {
  return expandURL(left).href == expandURL(right).href;
}
function getPathComponents(url) {
  return url.pathname.split("/").slice(1);
}
function getLastPathComponent(url) {
  return getPathComponents(url).slice(-1)[0];
}
function getPrefix(url) {
  return addTrailingSlash(url.origin + url.pathname);
}
function addTrailingSlash(value) {
  return value.endsWith("/") ? value : value + "/";
}

class FetchResponse {
  constructor(response) {
    this.response = response;
  }
  get succeeded() {
    return this.response.ok;
  }
  get failed() {
    return !this.succeeded;
  }
  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499;
  }
  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
  get redirected() {
    return this.response.redirected;
  }
  get location() {
    return expandURL(this.response.url);
  }
  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
  }
  get statusCode() {
    return this.response.status;
  }
  get contentType() {
    return this.header("Content-Type");
  }
  get responseText() {
    return this.response.clone().text();
  }
  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text();
    } else {
      return Promise.resolve(undefined);
    }
  }
  header(name) {
    return this.response.headers.get(name);
  }
}

class LimitedSet extends Set {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
  }
  add(value) {
    if (this.size >= this.maxSize) {
      const iterator = this.values();
      const oldestValue = iterator.next().value;
      this.delete(oldestValue);
    }
    super.add(value);
  }
}
var recentRequests = new LimitedSet(20);
var nativeFetch = window.fetch;
function fetchWithTurboHeaders(url, options = {}) {
  const modifiedHeaders = new Headers(options.headers || {});
  const requestUID = uuid();
  recentRequests.add(requestUID);
  modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
  return nativeFetch(url, {
    ...options,
    headers: modifiedHeaders
  });
}
function fetchMethodFromString(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get;
    case "post":
      return FetchMethod.post;
    case "put":
      return FetchMethod.put;
    case "patch":
      return FetchMethod.patch;
    case "delete":
      return FetchMethod.delete;
  }
}
var FetchMethod = {
  get: "get",
  post: "post",
  put: "put",
  patch: "patch",
  delete: "delete"
};
function fetchEnctypeFromString(encoding) {
  switch (encoding.toLowerCase()) {
    case FetchEnctype.multipart:
      return FetchEnctype.multipart;
    case FetchEnctype.plain:
      return FetchEnctype.plain;
    default:
      return FetchEnctype.urlEncoded;
  }
}
var FetchEnctype = {
  urlEncoded: "application/x-www-form-urlencoded",
  multipart: "multipart/form-data",
  plain: "text/plain"
};

class FetchRequest {
  abortController = new AbortController;
  #resolveRequestPromise = (_value) => {};
  constructor(delegate, method, location2, requestBody = new URLSearchParams, target = null, enctype = FetchEnctype.urlEncoded) {
    const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
    this.delegate = delegate;
    this.url = url;
    this.target = target;
    this.fetchOptions = {
      credentials: "same-origin",
      redirect: "follow",
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders },
      body,
      signal: this.abortSignal,
      referrer: this.delegate.referrer?.href
    };
    this.enctype = enctype;
  }
  get method() {
    return this.fetchOptions.method;
  }
  set method(value) {
    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData;
    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
    this.url.search = "";
    const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
    this.url = url;
    this.fetchOptions.body = body;
    this.fetchOptions.method = fetchMethod.toUpperCase();
  }
  get headers() {
    return this.fetchOptions.headers;
  }
  set headers(value) {
    this.fetchOptions.headers = value;
  }
  get body() {
    if (this.isSafe) {
      return this.url.searchParams;
    } else {
      return this.fetchOptions.body;
    }
  }
  set body(value) {
    this.fetchOptions.body = value;
  }
  get location() {
    return this.url;
  }
  get params() {
    return this.url.searchParams;
  }
  get entries() {
    return this.body ? Array.from(this.body.entries()) : [];
  }
  cancel() {
    this.abortController.abort();
  }
  async perform() {
    const { fetchOptions } = this;
    this.delegate.prepareRequest(this);
    const event = await this.#allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);
      if (event.detail.fetchRequest) {
        this.response = event.detail.fetchRequest.response;
      } else {
        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
      }
      const response = await this.response;
      return await this.receive(response);
    } catch (error) {
      if (error.name !== "AbortError") {
        if (this.#willDelegateErrorHandling(error)) {
          this.delegate.requestErrored(this, error);
        }
        throw error;
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }
  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: { fetchResponse },
      target: this.target
    });
    if (event.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse;
  }
  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    };
  }
  get isSafe() {
    return isSafe(this.method);
  }
  get abortSignal() {
    return this.abortController.signal;
  }
  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }
  async#allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
    const event = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.#resolveRequestPromise
      },
      target: this.target
    });
    this.url = event.detail.url;
    if (event.defaultPrevented)
      await requestInterception;
    return event;
  }
  #willDelegateErrorHandling(error) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error }
    });
    return !event.defaultPrevented;
  }
}
function isSafe(fetchMethod) {
  return fetchMethodFromString(fetchMethod) == FetchMethod.get;
}
function buildResourceAndBody(resource, method, requestBody, enctype) {
  const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
  if (isSafe(method)) {
    return [mergeIntoURLSearchParams(resource, searchParams), null];
  } else if (enctype == FetchEnctype.urlEncoded) {
    return [resource, searchParams];
  } else {
    return [resource, requestBody];
  }
}
function entriesExcludingFiles(requestBody) {
  const entries = [];
  for (const [name, value] of requestBody) {
    if (value instanceof File)
      continue;
    else
      entries.push([name, value]);
  }
  return entries;
}
function mergeIntoURLSearchParams(url, requestBody) {
  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
  url.search = searchParams.toString();
  return url;
}

class AppearanceObserver {
  started = false;
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }
  intersect = (entries) => {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry?.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  };
}

class StreamMessage {
  static contentType = "text/vnd.turbo-stream.html";
  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message));
    } else {
      return message;
    }
  }
  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
}
function importStreamElements(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);
    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }
    element.replaceWith(streamElement);
  }
  return fragment;
}
var PREFETCH_DELAY = 100;

class PrefetchCache {
  #prefetchTimeout = null;
  #prefetched = null;
  get(url) {
    if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
      return this.#prefetched.request;
    }
  }
  setLater(url, request, ttl) {
    this.clear();
    this.#prefetchTimeout = setTimeout(() => {
      request.perform();
      this.set(url, request, ttl);
      this.#prefetchTimeout = null;
    }, PREFETCH_DELAY);
  }
  set(url, request, ttl) {
    this.#prefetched = { url, request, expire: new Date(new Date().getTime() + ttl) };
  }
  clear() {
    if (this.#prefetchTimeout)
      clearTimeout(this.#prefetchTimeout);
    this.#prefetched = null;
  }
}
var cacheTtl = 10 * 1000;
var prefetchCache = new PrefetchCache;
var FormSubmissionState = {
  initialized: "initialized",
  requesting: "requesting",
  waiting: "waiting",
  receiving: "receiving",
  stopping: "stopping",
  stopped: "stopped"
};

class FormSubmission {
  state = FormSubmissionState.initialized;
  static confirmMethod(message) {
    return Promise.resolve(confirm(message));
  }
  constructor(delegate, formElement, submitter2, mustRedirect = false) {
    const method = getMethod(formElement, submitter2);
    const action = getAction(getFormAction(formElement, submitter2), method);
    const body = buildFormData(formElement, submitter2);
    const enctype = getEnctype(formElement, submitter2);
    this.delegate = delegate;
    this.formElement = formElement;
    this.submitter = submitter2;
    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
    this.mustRedirect = mustRedirect;
  }
  get method() {
    return this.fetchRequest.method;
  }
  set method(value) {
    this.fetchRequest.method = value;
  }
  get action() {
    return this.fetchRequest.url.toString();
  }
  set action(value) {
    this.fetchRequest.url = expandURL(value);
  }
  get body() {
    return this.fetchRequest.body;
  }
  get enctype() {
    return this.fetchRequest.enctype;
  }
  get isSafe() {
    return this.fetchRequest.isSafe;
  }
  get location() {
    return this.fetchRequest.url;
  }
  async start() {
    const { initialized, requesting } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
    if (typeof confirmationMessage === "string") {
      const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : FormSubmission.confirmMethod;
      const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return;
      }
    }
    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform();
    }
  }
  stop() {
    const { stopping, stopped } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true;
    }
  }
  prepareRequest(request) {
    if (!request.isSafe) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }
    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    this.state = FormSubmissionState.waiting;
    if (this.submitter)
      config.forms.submitter.beforeSubmit(this.submitter);
    this.setSubmitsWith();
    markAsBusy(this.formElement);
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: { formSubmission: this }
    });
    this.delegate.formSubmissionStarted(this);
  }
  requestPreventedHandlingResponse(request, response) {
    prefetchCache.clear();
    this.result = { success: response.succeeded, fetchResponse: response };
  }
  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
      return;
    }
    prefetchCache.clear();
    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = { success: true, fetchResponse: response };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }
  requestFailedWithResponse(request, response) {
    this.result = { success: false, fetchResponse: response };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }
  requestErrored(request, error) {
    this.result = { success: false, error };
    this.delegate.formSubmissionErrored(this, error);
  }
  requestFinished(_request) {
    this.state = FormSubmissionState.stopped;
    if (this.submitter)
      config.forms.submitter.afterSubmit(this.submitter);
    this.resetSubmitterText();
    clearBusyState(this.formElement);
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: { formSubmission: this, ...this.result }
    });
    this.delegate.formSubmissionFinished(this);
  }
  setSubmitsWith() {
    if (!this.submitter || !this.submitsWith)
      return;
    if (this.submitter.matches("button")) {
      this.originalSubmitText = this.submitter.innerHTML;
      this.submitter.innerHTML = this.submitsWith;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      this.originalSubmitText = input.value;
      input.value = this.submitsWith;
    }
  }
  resetSubmitterText() {
    if (!this.submitter || !this.originalSubmitText)
      return;
    if (this.submitter.matches("button")) {
      this.submitter.innerHTML = this.originalSubmitText;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      input.value = this.originalSubmitText;
    }
  }
  requestMustRedirect(request) {
    return !request.isSafe && this.mustRedirect;
  }
  requestAcceptsTurboStreamResponse(request) {
    return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
  }
  get submitsWith() {
    return this.submitter?.getAttribute("data-turbo-submits-with");
  }
}
function buildFormData(formElement, submitter2) {
  const formData = new FormData(formElement);
  const name = submitter2?.getAttribute("name");
  const value = submitter2?.getAttribute("value");
  if (name) {
    formData.append(name, value || "");
  }
  return formData;
}
function getCookieValue(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : undefined;
    }
  }
}
function responseSucceededWithoutRedirect(response) {
  return response.statusCode == 200 && !response.redirected;
}
function getFormAction(formElement, submitter2) {
  const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
  if (submitter2?.hasAttribute("formaction")) {
    return submitter2.getAttribute("formaction") || "";
  } else {
    return formElement.getAttribute("action") || formElementAction || "";
  }
}
function getAction(formAction, fetchMethod) {
  const action = expandURL(formAction);
  if (isSafe(fetchMethod)) {
    action.search = "";
  }
  return action;
}
function getMethod(formElement, submitter2) {
  const method = submitter2?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
}
function getEnctype(formElement, submitter2) {
  return fetchEnctypeFromString(submitter2?.getAttribute("formenctype") || formElement.enctype);
}

class Snapshot {
  constructor(element) {
    this.element = element;
  }
  get activeElement() {
    return this.element.ownerDocument.activeElement;
  }
  get children() {
    return [...this.element.children];
  }
  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null;
  }
  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
  }
  get isConnected() {
    return this.element.isConnected;
  }
  get firstAutofocusableElement() {
    return queryAutofocusableElement(this.element);
  }
  get permanentElements() {
    return queryPermanentElementsAll(this.element);
  }
  getPermanentElementById(id) {
    return getPermanentElementById(this.element, id);
  }
  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};
    for (const currentPermanentElement of this.permanentElements) {
      const { id } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id);
      if (newPermanentElement) {
        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
      }
    }
    return permanentElementMap;
  }
}
function getPermanentElementById(node, id) {
  return node.querySelector(`#${id}[data-turbo-permanent]`);
}
function queryPermanentElementsAll(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]");
}

class FormSubmitObserver {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }
  submitCaptured = () => {
    this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
    this.eventTarget.addEventListener("submit", this.submitBubbled, false);
  };
  submitBubbled = (event) => {
    if (!event.defaultPrevented) {
      const form = event.target instanceof HTMLFormElement ? event.target : undefined;
      const submitter2 = event.submitter || undefined;
      if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.delegate.formSubmitted(form, submitter2);
      }
    }
  };
}
function submissionDoesNotDismissDialog(form, submitter2) {
  const method = submitter2?.getAttribute("formmethod") || form.getAttribute("method");
  return method != "dialog";
}
function submissionDoesNotTargetIFrame(form, submitter2) {
  const target = submitter2?.getAttribute("formtarget") || form.getAttribute("target");
  return doesNotTargetIFrame(target);
}

class View {
  #resolveRenderPromise = (_value) => {};
  #resolveInterceptionPromise = (_value) => {};
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({ x: 0, y: 0 });
    }
  }
  scrollToAnchorFromLocation(location2) {
    this.scrollToAnchor(getAnchor(location2));
  }
  scrollToElement(element) {
    element.scrollIntoView();
  }
  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }
  scrollToPosition({ x, y }) {
    this.scrollRoot.scrollTo(x, y);
  }
  scrollToTop() {
    this.scrollToPosition({ x: 0, y: 0 });
  }
  get scrollRoot() {
    return window;
  }
  async render(renderer) {
    const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
    const shouldInvalidate = willRender;
    if (shouldRender) {
      try {
        this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);
        const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
        const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender)
          await renderInterception;
        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.#resolveRenderPromise(undefined);
        delete this.renderPromise;
      }
    } else if (shouldInvalidate) {
      this.invalidate(renderer.reloadReason);
    }
  }
  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }
  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }
  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }
  markVisitDirection(direction) {
    this.element.setAttribute("data-turbo-visit-direction", direction);
  }
  unmarkVisitDirection() {
    this.element.removeAttribute("data-turbo-visit-direction");
  }
  async renderSnapshot(renderer) {
    await renderer.render();
  }
  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
}

class FrameView extends View {
  missing() {
    this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
  }
  get snapshot() {
    return new Snapshot(this.element);
  }
}

class LinkInterceptor {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }
  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }
  clickBubbled = (event) => {
    if (this.clickEventIsSignificant(event)) {
      this.clickEvent = event;
    } else {
      delete this.clickEvent;
    }
  };
  linkClicked = (event) => {
    if (this.clickEvent && this.clickEventIsSignificant(event)) {
      if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
        this.clickEvent.preventDefault();
        event.preventDefault();
        this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
      }
    }
    delete this.clickEvent;
  };
  willVisit = (_event) => {
    delete this.clickEvent;
  };
  clickEventIsSignificant(event) {
    const target = event.composed ? event.target?.parentElement : event.target;
    const element = findLinkFromClickTarget(target) || target;
    return element instanceof Element && element.closest("turbo-frame, html") == this.element;
  }
}

class LinkClickObserver {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }
  clickCaptured = () => {
    this.eventTarget.removeEventListener("click", this.clickBubbled, false);
    this.eventTarget.addEventListener("click", this.clickBubbled, false);
  };
  clickBubbled = (event) => {
    if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
      const target = event.composedPath && event.composedPath()[0] || event.target;
      const link = findLinkFromClickTarget(target);
      if (link && doesNotTargetIFrame(link.target)) {
        const location2 = getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
          event.preventDefault();
          this.delegate.followedLinkToLocation(link, location2);
        }
      }
    }
  };
  clickEventIsSignificant(event) {
    return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
  }
}

class FormLinkClickObserver {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
  }
  stop() {
    this.linkInterceptor.stop();
  }
  canPrefetchRequestToLocation(link, location2) {
    return false;
  }
  prefetchAndCacheRequestToLocation(link, location2) {
    return;
  }
  willFollowLinkToLocation(link, location2, originalEvent) {
    return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
  }
  followedLinkToLocation(link, location2) {
    const form = document.createElement("form");
    const type = "hidden";
    for (const [name, value] of location2.searchParams) {
      form.append(Object.assign(document.createElement("input"), { type, name, value }));
    }
    const action = Object.assign(location2, { search: "" });
    form.setAttribute("data-turbo", "true");
    form.setAttribute("action", action.href);
    form.setAttribute("hidden", "");
    const method = link.getAttribute("data-turbo-method");
    if (method)
      form.setAttribute("method", method);
    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame)
      form.setAttribute("data-turbo-frame", turboFrame);
    const turboAction = getVisitAction(link);
    if (turboAction)
      form.setAttribute("data-turbo-action", turboAction);
    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm)
      form.setAttribute("data-turbo-confirm", turboConfirm);
    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream)
      form.setAttribute("data-turbo-stream", "");
    this.delegate.submittedFormLinkToLocation(link, location2, form);
    document.body.appendChild(form);
    form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
    requestAnimationFrame(() => form.requestSubmit());
  }
}

class Bardo {
  static async preservingPermanentElements(delegate, permanentElementMap, callback) {
    const bardo = new this(delegate, permanentElementMap);
    bardo.enter();
    await callback();
    bardo.leave();
  }
  constructor(delegate, permanentElementMap) {
    this.delegate = delegate;
    this.permanentElementMap = permanentElementMap;
  }
  enter() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }
  leave() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }
  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }
  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone);
  }
  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder?.replaceWith(permanentElement);
  }
  getPlaceholderById(id) {
    return this.placeholders.find((element) => element.content == id);
  }
  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
  }
}
function createPlaceholderForPermanentElement(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element;
}

class Renderer {
  #activeElement = null;
  static renderElement(currentElement, newElement) {}
  constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = this.constructor.renderElement;
    this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
  }
  get shouldRender() {
    return true;
  }
  get shouldAutofocus() {
    return true;
  }
  get reloadReason() {
    return;
  }
  prepareToRender() {
    return;
  }
  render() {}
  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }
  async preservingPermanentElements(callback) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
  }
  focusFirstAutofocusableElement() {
    if (this.shouldAutofocus) {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
  }
  enteringBardo(currentPermanentElement) {
    if (this.#activeElement)
      return;
    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.#activeElement = this.currentSnapshot.activeElement;
    }
  }
  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
      this.#activeElement.focus();
      this.#activeElement = null;
    }
  }
  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
  }
  get currentElement() {
    return this.currentSnapshot.element;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
  }
  get renderMethod() {
    return "replace";
  }
}

class FrameRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();
    const frameElement = newElement;
    const sourceRange = frameElement.ownerDocument?.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }
  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate;
  }
  get shouldRender() {
    return true;
  }
  async render() {
    await nextRepaint();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextRepaint();
    this.focusFirstAutofocusableElement();
    await nextRepaint();
    this.activateScriptElements();
  }
  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }
  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
      if (element) {
        element.scrollIntoView({ block, behavior });
        return true;
      }
    }
    return false;
  }
  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  get newScriptElements() {
    return this.currentElement.querySelectorAll("script");
  }
}
function readScrollLogicalPosition(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value;
  } else {
    return defaultValue;
  }
}
function readScrollBehavior(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value;
  } else {
    return defaultValue;
  }
}
var Idiomorph = function() {
  const noOp = () => {};
  const defaults = {
    morphStyle: "outerHTML",
    callbacks: {
      beforeNodeAdded: noOp,
      afterNodeAdded: noOp,
      beforeNodeMorphed: noOp,
      afterNodeMorphed: noOp,
      beforeNodeRemoved: noOp,
      afterNodeRemoved: noOp,
      beforeAttributeUpdated: noOp
    },
    head: {
      style: "merge",
      shouldPreserve: (elt) => elt.getAttribute("im-preserve") === "true",
      shouldReAppend: (elt) => elt.getAttribute("im-re-append") === "true",
      shouldRemove: noOp,
      afterHeadMorphed: noOp
    },
    restoreFocus: true
  };
  function morph(oldNode, newContent, config2 = {}) {
    oldNode = normalizeElement(oldNode);
    const newNode = normalizeParent(newContent);
    const ctx = createMorphContext(oldNode, newNode, config2);
    const morphedNodes = saveAndRestoreFocus(ctx, () => {
      return withHeadBlocking(ctx, oldNode, newNode, (ctx2) => {
        if (ctx2.morphStyle === "innerHTML") {
          morphChildren(ctx2, oldNode, newNode);
          return Array.from(oldNode.childNodes);
        } else {
          return morphOuterHTML(ctx2, oldNode, newNode);
        }
      });
    });
    ctx.pantry.remove();
    return morphedNodes;
  }
  function morphOuterHTML(ctx, oldNode, newNode) {
    const oldParent = normalizeParent(oldNode);
    let childNodes = Array.from(oldParent.childNodes);
    const index = childNodes.indexOf(oldNode);
    const rightMargin = childNodes.length - (index + 1);
    morphChildren(ctx, oldParent, newNode, oldNode, oldNode.nextSibling);
    childNodes = Array.from(oldParent.childNodes);
    return childNodes.slice(index, childNodes.length - rightMargin);
  }
  function saveAndRestoreFocus(ctx, fn) {
    if (!ctx.config.restoreFocus)
      return fn();
    let activeElement = document.activeElement;
    if (!(activeElement instanceof HTMLInputElement || activeElement instanceof HTMLTextAreaElement)) {
      return fn();
    }
    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;
    const results = fn();
    if (activeElementId && activeElementId !== document.activeElement?.id) {
      activeElement = ctx.target.querySelector(`#${activeElementId}`);
      activeElement?.focus();
    }
    if (activeElement && !activeElement.selectionEnd && selectionEnd) {
      activeElement.setSelectionRange(selectionStart, selectionEnd);
    }
    return results;
  }
  const morphChildren = function() {
    function morphChildren2(ctx, oldParent, newParent, insertionPoint = null, endPoint = null) {
      if (oldParent instanceof HTMLTemplateElement && newParent instanceof HTMLTemplateElement) {
        oldParent = oldParent.content;
        newParent = newParent.content;
      }
      insertionPoint ||= oldParent.firstChild;
      for (const newChild of newParent.childNodes) {
        if (insertionPoint && insertionPoint != endPoint) {
          const bestMatch = findBestMatch(ctx, newChild, insertionPoint, endPoint);
          if (bestMatch) {
            if (bestMatch !== insertionPoint) {
              removeNodesBetween(ctx, insertionPoint, bestMatch);
            }
            morphNode(bestMatch, newChild, ctx);
            insertionPoint = bestMatch.nextSibling;
            continue;
          }
        }
        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {
          const movedChild = moveBeforeById(oldParent, newChild.id, insertionPoint, ctx);
          morphNode(movedChild, newChild, ctx);
          insertionPoint = movedChild.nextSibling;
          continue;
        }
        const insertedNode = createNode(oldParent, newChild, insertionPoint, ctx);
        if (insertedNode) {
          insertionPoint = insertedNode.nextSibling;
        }
      }
      while (insertionPoint && insertionPoint != endPoint) {
        const tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(ctx, tempNode);
      }
    }
    function createNode(oldParent, newChild, insertionPoint, ctx) {
      if (ctx.callbacks.beforeNodeAdded(newChild) === false)
        return null;
      if (ctx.idMap.has(newChild)) {
        const newEmptyChild = document.createElement(newChild.tagName);
        oldParent.insertBefore(newEmptyChild, insertionPoint);
        morphNode(newEmptyChild, newChild, ctx);
        ctx.callbacks.afterNodeAdded(newEmptyChild);
        return newEmptyChild;
      } else {
        const newClonedChild = document.importNode(newChild, true);
        oldParent.insertBefore(newClonedChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newClonedChild);
        return newClonedChild;
      }
    }
    const findBestMatch = function() {
      function findBestMatch2(ctx, node, startPoint, endPoint) {
        let softMatch = null;
        let nextSibling = node.nextSibling;
        let siblingSoftMatchCount = 0;
        let cursor = startPoint;
        while (cursor && cursor != endPoint) {
          if (isSoftMatch(cursor, node)) {
            if (isIdSetMatch(ctx, cursor, node)) {
              return cursor;
            }
            if (softMatch === null) {
              if (!ctx.idMap.has(cursor)) {
                softMatch = cursor;
              }
            }
          }
          if (softMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {
            siblingSoftMatchCount++;
            nextSibling = nextSibling.nextSibling;
            if (siblingSoftMatchCount >= 2) {
              softMatch = undefined;
            }
          }
          if (cursor.contains(document.activeElement))
            break;
          cursor = cursor.nextSibling;
        }
        return softMatch || null;
      }
      function isIdSetMatch(ctx, oldNode, newNode) {
        let oldSet = ctx.idMap.get(oldNode);
        let newSet = ctx.idMap.get(newNode);
        if (!newSet || !oldSet)
          return false;
        for (const id of oldSet) {
          if (newSet.has(id)) {
            return true;
          }
        }
        return false;
      }
      function isSoftMatch(oldNode, newNode) {
        const oldElt = oldNode;
        const newElt = newNode;
        return oldElt.nodeType === newElt.nodeType && oldElt.tagName === newElt.tagName && (!oldElt.id || oldElt.id === newElt.id);
      }
      return findBestMatch2;
    }();
    function removeNode(ctx, node) {
      if (ctx.idMap.has(node)) {
        moveBefore(ctx.pantry, node, null);
      } else {
        if (ctx.callbacks.beforeNodeRemoved(node) === false)
          return;
        node.parentNode?.removeChild(node);
        ctx.callbacks.afterNodeRemoved(node);
      }
    }
    function removeNodesBetween(ctx, startInclusive, endExclusive) {
      let cursor = startInclusive;
      while (cursor && cursor !== endExclusive) {
        let tempNode = cursor;
        cursor = cursor.nextSibling;
        removeNode(ctx, tempNode);
      }
      return cursor;
    }
    function moveBeforeById(parentNode, id, after, ctx) {
      const target = ctx.target.querySelector(`#${id}`) || ctx.pantry.querySelector(`#${id}`);
      removeElementFromAncestorsIdMaps(target, ctx);
      moveBefore(parentNode, target, after);
      return target;
    }
    function removeElementFromAncestorsIdMaps(element, ctx) {
      const id = element.id;
      while (element = element.parentNode) {
        let idSet = ctx.idMap.get(element);
        if (idSet) {
          idSet.delete(id);
          if (!idSet.size) {
            ctx.idMap.delete(element);
          }
        }
      }
    }
    function moveBefore(parentNode, element, after) {
      if (parentNode.moveBefore) {
        try {
          parentNode.moveBefore(element, after);
        } catch (e) {
          parentNode.insertBefore(element, after);
        }
      } else {
        parentNode.insertBefore(element, after);
      }
    }
    return morphChildren2;
  }();
  const morphNode = function() {
    function morphNode2(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement) {
        return null;
      }
      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {
        return oldNode;
      }
      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore)
        ;
      else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
        handleHeadElement(oldNode, newContent, ctx);
      } else {
        morphAttributes(oldNode, newContent, ctx);
        if (!ignoreValueOfActiveElement(oldNode, ctx)) {
          morphChildren(ctx, oldNode, newContent);
        }
      }
      ctx.callbacks.afterNodeMorphed(oldNode, newContent);
      return oldNode;
    }
    function morphAttributes(oldNode, newNode, ctx) {
      let type = newNode.nodeType;
      if (type === 1) {
        const oldElt = oldNode;
        const newElt = newNode;
        const oldAttributes = oldElt.attributes;
        const newAttributes = newElt.attributes;
        for (const newAttribute of newAttributes) {
          if (ignoreAttribute(newAttribute.name, oldElt, "update", ctx)) {
            continue;
          }
          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {
            oldElt.setAttribute(newAttribute.name, newAttribute.value);
          }
        }
        for (let i = oldAttributes.length - 1;0 <= i; i--) {
          const oldAttribute = oldAttributes[i];
          if (!oldAttribute)
            continue;
          if (!newElt.hasAttribute(oldAttribute.name)) {
            if (ignoreAttribute(oldAttribute.name, oldElt, "remove", ctx)) {
              continue;
            }
            oldElt.removeAttribute(oldAttribute.name);
          }
        }
        if (!ignoreValueOfActiveElement(oldElt, ctx)) {
          syncInputValue(oldElt, newElt, ctx);
        }
      }
      if (type === 8 || type === 3) {
        if (oldNode.nodeValue !== newNode.nodeValue) {
          oldNode.nodeValue = newNode.nodeValue;
        }
      }
    }
    function syncInputValue(oldElement, newElement, ctx) {
      if (oldElement instanceof HTMLInputElement && newElement instanceof HTMLInputElement && newElement.type !== "file") {
        let newValue = newElement.value;
        let oldValue = oldElement.value;
        syncBooleanAttribute(oldElement, newElement, "checked", ctx);
        syncBooleanAttribute(oldElement, newElement, "disabled", ctx);
        if (!newElement.hasAttribute("value")) {
          if (!ignoreAttribute("value", oldElement, "remove", ctx)) {
            oldElement.value = "";
            oldElement.removeAttribute("value");
          }
        } else if (oldValue !== newValue) {
          if (!ignoreAttribute("value", oldElement, "update", ctx)) {
            oldElement.setAttribute("value", newValue);
            oldElement.value = newValue;
          }
        }
      } else if (oldElement instanceof HTMLOptionElement && newElement instanceof HTMLOptionElement) {
        syncBooleanAttribute(oldElement, newElement, "selected", ctx);
      } else if (oldElement instanceof HTMLTextAreaElement && newElement instanceof HTMLTextAreaElement) {
        let newValue = newElement.value;
        let oldValue = oldElement.value;
        if (ignoreAttribute("value", oldElement, "update", ctx)) {
          return;
        }
        if (newValue !== oldValue) {
          oldElement.value = newValue;
        }
        if (oldElement.firstChild && oldElement.firstChild.nodeValue !== newValue) {
          oldElement.firstChild.nodeValue = newValue;
        }
      }
    }
    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {
      const newLiveValue = newElement[attributeName], oldLiveValue = oldElement[attributeName];
      if (newLiveValue !== oldLiveValue) {
        const ignoreUpdate = ignoreAttribute(attributeName, oldElement, "update", ctx);
        if (!ignoreUpdate) {
          oldElement[attributeName] = newElement[attributeName];
        }
        if (newLiveValue) {
          if (!ignoreUpdate) {
            oldElement.setAttribute(attributeName, "");
          }
        } else {
          if (!ignoreAttribute(attributeName, oldElement, "remove", ctx)) {
            oldElement.removeAttribute(attributeName);
          }
        }
      }
    }
    function ignoreAttribute(attr, element, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && element === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) === false;
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return !!ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    return morphNode2;
  }();
  function withHeadBlocking(ctx, oldNode, newNode, callback) {
    if (ctx.head.block) {
      const oldHead = oldNode.querySelector("head");
      const newHead = newNode.querySelector("head");
      if (oldHead && newHead) {
        const promises = handleHeadElement(oldHead, newHead, ctx);
        return Promise.all(promises).then(() => {
          const newCtx = Object.assign(ctx, {
            head: {
              block: false,
              ignore: true
            }
          });
          return callback(newCtx);
        });
      }
    }
    return callback(ctx);
  }
  function handleHeadElement(oldHead, newHead, ctx) {
    let added = [];
    let removed = [];
    let preserved = [];
    let nodesToAppend = [];
    let srcToNewHeadNodes = new Map;
    for (const newHeadChild of newHead.children) {
      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
    }
    for (const currentHeadElt of oldHead.children) {
      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
      if (inNewContent || isPreserved) {
        if (isReAppended) {
          removed.push(currentHeadElt);
        } else {
          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
          preserved.push(currentHeadElt);
        }
      } else {
        if (ctx.head.style === "append") {
          if (isReAppended) {
            removed.push(currentHeadElt);
            nodesToAppend.push(currentHeadElt);
          }
        } else {
          if (ctx.head.shouldRemove(currentHeadElt) !== false) {
            removed.push(currentHeadElt);
          }
        }
      }
    }
    nodesToAppend.push(...srcToNewHeadNodes.values());
    let promises = [];
    for (const newNode of nodesToAppend) {
      let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
        if ("href" in newElt && newElt.href || "src" in newElt && newElt.src) {
          let resolve;
          let promise = new Promise(function(_resolve) {
            resolve = _resolve;
          });
          newElt.addEventListener("load", function() {
            resolve();
          });
          promises.push(promise);
        }
        oldHead.appendChild(newElt);
        ctx.callbacks.afterNodeAdded(newElt);
        added.push(newElt);
      }
    }
    for (const removedElement of removed) {
      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
        oldHead.removeChild(removedElement);
        ctx.callbacks.afterNodeRemoved(removedElement);
      }
    }
    ctx.head.afterHeadMorphed(oldHead, {
      added,
      kept: preserved,
      removed
    });
    return promises;
  }
  const createMorphContext = function() {
    function createMorphContext2(oldNode, newContent, config2) {
      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);
      const mergedConfig = mergeDefaults(config2);
      const morphStyle = mergedConfig.morphStyle || "outerHTML";
      if (!["innerHTML", "outerHTML"].includes(morphStyle)) {
        throw `Do not understand how to morph style ${morphStyle}`;
      }
      return {
        target: oldNode,
        newContent,
        config: mergedConfig,
        morphStyle,
        ignoreActive: mergedConfig.ignoreActive,
        ignoreActiveValue: mergedConfig.ignoreActiveValue,
        restoreFocus: mergedConfig.restoreFocus,
        idMap,
        persistentIds,
        pantry: createPantry(),
        callbacks: mergedConfig.callbacks,
        head: mergedConfig.head
      };
    }
    function mergeDefaults(config2) {
      let finalConfig = Object.assign({}, defaults);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = Object.assign({}, defaults.callbacks, config2.callbacks);
      finalConfig.head = Object.assign({}, defaults.head, config2.head);
      return finalConfig;
    }
    function createPantry() {
      const pantry = document.createElement("div");
      pantry.hidden = true;
      document.body.insertAdjacentElement("afterend", pantry);
      return pantry;
    }
    function findIdElements(root) {
      let elements = Array.from(root.querySelectorAll("[id]"));
      if (root.id) {
        elements.push(root);
      }
      return elements;
    }
    function populateIdMapWithTree(idMap, persistentIds, root, elements) {
      for (const elt of elements) {
        if (persistentIds.has(elt.id)) {
          let current = elt;
          while (current) {
            let idSet = idMap.get(current);
            if (idSet == null) {
              idSet = new Set;
              idMap.set(current, idSet);
            }
            idSet.add(elt.id);
            if (current === root)
              break;
            current = current.parentElement;
          }
        }
      }
    }
    function createIdMaps(oldContent, newContent) {
      const oldIdElements = findIdElements(oldContent);
      const newIdElements = findIdElements(newContent);
      const persistentIds = createPersistentIds(oldIdElements, newIdElements);
      let idMap = new Map;
      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);
      const newRoot = newContent.__idiomorphRoot || newContent;
      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);
      return { persistentIds, idMap };
    }
    function createPersistentIds(oldIdElements, newIdElements) {
      let duplicateIds = new Set;
      let oldIdTagNameMap = new Map;
      for (const { id, tagName } of oldIdElements) {
        if (oldIdTagNameMap.has(id)) {
          duplicateIds.add(id);
        } else {
          oldIdTagNameMap.set(id, tagName);
        }
      }
      let persistentIds = new Set;
      for (const { id, tagName } of newIdElements) {
        if (persistentIds.has(id)) {
          duplicateIds.add(id);
        } else if (oldIdTagNameMap.get(id) === tagName) {
          persistentIds.add(id);
        }
      }
      for (const id of duplicateIds) {
        persistentIds.delete(id);
      }
      return persistentIds;
    }
    return createMorphContext2;
  }();
  const { normalizeElement, normalizeParent } = function() {
    const generatedByIdiomorph = new WeakSet;
    function normalizeElement2(content) {
      if (content instanceof Document) {
        return content.documentElement;
      } else {
        return content;
      }
    }
    function normalizeParent2(newContent) {
      if (newContent == null) {
        return document.createElement("div");
      } else if (typeof newContent === "string") {
        return normalizeParent2(parseContent(newContent));
      } else if (generatedByIdiomorph.has(newContent)) {
        return newContent;
      } else if (newContent instanceof Node) {
        if (newContent.parentNode) {
          return createDuckTypedParent(newContent);
        } else {
          const dummyParent = document.createElement("div");
          dummyParent.append(newContent);
          return dummyParent;
        }
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function createDuckTypedParent(newContent) {
      return {
        childNodes: [newContent],
        querySelectorAll: (s) => {
          const elements = newContent.querySelectorAll(s);
          return newContent.matches(s) ? [newContent, ...elements] : elements;
        },
        insertBefore: (n, r) => newContent.parentNode.insertBefore(n, r),
        moveBefore: (n, r) => newContent.parentNode.moveBefore(n, r),
        get __idiomorphRoot() {
          return newContent;
        }
      };
    }
    function parseContent(newContent) {
      let parser = new DOMParser;
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          generatedByIdiomorph.add(content);
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            generatedByIdiomorph.add(htmlElement);
          }
          return htmlElement;
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        generatedByIdiomorph.add(content);
        return content;
      }
    }
    return { normalizeElement: normalizeElement2, normalizeParent: normalizeParent2 };
  }();
  return {
    morph,
    defaults
  };
}();
function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
  Idiomorph.morph(currentElement, newElement, {
    ...options,
    callbacks: new DefaultIdiomorphCallbacks(callbacks)
  });
}
function morphChildren(currentElement, newElement) {
  morphElements(currentElement, newElement.childNodes, {
    morphStyle: "innerHTML"
  });
}

class DefaultIdiomorphCallbacks {
  #beforeNodeMorphed;
  constructor({ beforeNodeMorphed } = {}) {
    this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
  }
  beforeNodeAdded = (node) => {
    return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
  };
  beforeNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
        const event = dispatch("turbo:before-morph-element", {
          cancelable: true,
          target: currentElement,
          detail: { currentElement, newElement }
        });
        return !event.defaultPrevented;
      } else {
        return false;
      }
    }
  };
  beforeAttributeUpdated = (attributeName, target, mutationType) => {
    const event = dispatch("turbo:before-morph-attribute", {
      cancelable: true,
      target,
      detail: { attributeName, mutationType }
    });
    return !event.defaultPrevented;
  };
  beforeNodeRemoved = (node) => {
    return this.beforeNodeMorphed(node);
  };
  afterNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      dispatch("turbo:morph-element", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
    }
  };
}

class MorphingFrameRenderer extends FrameRenderer {
  static renderElement(currentElement, newElement) {
    dispatch("turbo:before-frame-morph", {
      target: currentElement,
      detail: { currentElement, newElement }
    });
    morphChildren(currentElement, newElement);
  }
  async preservingPermanentElements(callback) {
    return await callback();
  }
}

class ProgressBar {
  static animationDuration = 300;
  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
  }
  hiding = false;
  value = 0;
  visible = false;
  constructor() {
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }
  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }
  setValue(value) {
    this.value = value;
    this.refresh();
  }
  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }
  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }
  fadeProgressElement(callback) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback, ProgressBar.animationDuration * 1.5);
  }
  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }
  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
    }
  }
  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }
  trickle = () => {
    this.setValue(this.value + Math.random() / 100);
  };
  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }
  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = ProgressBar.defaultCSS;
    const cspNonce = getCspNonce();
    if (cspNonce) {
      element.nonce = cspNonce;
    }
    return element;
  }
  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element;
  }
}

class HeadSnapshot extends Snapshot {
  detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
    const { outerHTML } = element;
    const details = outerHTML in result ? result[outerHTML] : {
      type: elementType(element),
      tracked: elementIsTracked(element),
      elements: []
    };
    return {
      ...result,
      [outerHTML]: {
        ...details,
        elements: [...details.elements, element]
      }
    };
  }, {});
  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
  }
  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
  }
  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
  }
  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
  }
  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements];
      } else if (elements.length > 1) {
        return [...result, ...elements.slice(1)];
      } else {
        return result;
      }
    }, []);
  }
  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null;
  }
  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result;
    }, undefined | undefined);
  }
}
function elementType(element) {
  if (elementIsScript(element)) {
    return "script";
  } else if (elementIsStylesheet(element)) {
    return "stylesheet";
  }
}
function elementIsTracked(element) {
  return element.getAttribute("data-turbo-track") == "reload";
}
function elementIsScript(element) {
  const tagName = element.localName;
  return tagName == "script";
}
function elementIsNoscript(element) {
  const tagName = element.localName;
  return tagName == "noscript";
}
function elementIsStylesheet(element) {
  const tagName = element.localName;
  return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
}
function elementIsMetaElementWithName(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name;
}
function elementWithoutNonce(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }
  return element;
}

class PageSnapshot extends Snapshot {
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html));
  }
  static fromElement(element) {
    return this.fromDocument(element.ownerDocument);
  }
  static fromDocument({ documentElement, body, head }) {
    return new this(documentElement, body, new HeadSnapshot(head));
  }
  constructor(documentElement, body, headSnapshot) {
    super(body);
    this.documentElement = documentElement;
    this.headSnapshot = headSnapshot;
  }
  clone() {
    const clonedElement = this.element.cloneNode(true);
    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");
    for (const [index, source] of selectElements.entries()) {
      const clone = clonedSelectElements[index];
      for (const option of clone.selectedOptions)
        option.selected = false;
      for (const option of source.selectedOptions)
        clone.options[option.index].selected = true;
    }
    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }
    return new PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
  }
  get lang() {
    return this.documentElement.getAttribute("lang");
  }
  get headElement() {
    return this.headSnapshot.element;
  }
  get rootLocation() {
    const root = this.getSetting("root") ?? "/";
    return expandURL(root);
  }
  get cacheControlValue() {
    return this.getSetting("cache-control");
  }
  get isPreviewable() {
    return this.cacheControlValue != "no-preview";
  }
  get isCacheable() {
    return this.cacheControlValue != "no-cache";
  }
  get isVisitable() {
    return this.getSetting("visit-control") != "reload";
  }
  get prefersViewTransitions() {
    return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
  }
  get shouldMorphPage() {
    return this.getSetting("refresh-method") === "morph";
  }
  get shouldPreserveScrollPosition() {
    return this.getSetting("refresh-scroll") === "preserve";
  }
  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`);
  }
}

class ViewTransitioner {
  #viewTransitionStarted = false;
  #lastOperation = Promise.resolve();
  renderChange(useViewTransition, render) {
    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
      this.#viewTransitionStarted = true;
      this.#lastOperation = this.#lastOperation.then(async () => {
        await document.startViewTransition(render).finished;
      });
    } else {
      this.#lastOperation = this.#lastOperation.then(render);
    }
    return this.#lastOperation;
  }
  get viewTransitionsAvailable() {
    return document.startViewTransition;
  }
}
var defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {},
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};
var TimingMetric = {
  visitStart: "visitStart",
  requestStart: "requestStart",
  requestEnd: "requestEnd",
  visitEnd: "visitEnd"
};
var VisitState = {
  initialized: "initialized",
  started: "started",
  canceled: "canceled",
  failed: "failed",
  completed: "completed"
};
var SystemStatusCode = {
  networkFailure: 0,
  timeoutFailure: -1,
  contentTypeMismatch: -2
};
var Direction = {
  advance: "forward",
  restore: "back",
  replace: "none"
};

class Visit {
  identifier = uuid();
  timingMetrics = {};
  followedRedirect = false;
  historyChanged = false;
  scrolled = false;
  shouldCacheSnapshot = true;
  acceptsStreamResponse = false;
  snapshotCached = false;
  state = VisitState.initialized;
  viewTransitioner = new ViewTransitioner;
  constructor(delegate, location2, restorationIdentifier, options = {}) {
    this.delegate = delegate;
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier || uuid();
    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse,
      direction
    } = {
      ...defaultOptions,
      ...options
    };
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.isPageRefresh = this.view.isPageRefresh(this);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
    this.direction = direction || Direction[action];
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
  }
  get silent() {
    return this.isSamePage;
  }
  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }
  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }
  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.adapter.visitCompleted(this);
      this.state = VisitState.completed;
      this.followRedirect();
      if (!this.followedRedirect) {
        this.delegate.visitCompleted(this);
      }
    }
  }
  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
      this.delegate.visitCompleted(this);
    }
  }
  changeHistory() {
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }
  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }
  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }
  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }
  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const { statusCode } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }
  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }
  loadResponse() {
    if (this.response) {
      const { statusCode, responseHTML } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot)
          this.cacheSnapshot();
        if (this.view.renderPromise)
          await this.view.renderPromise;
        if (isSuccessful(statusCode) && responseHTML != null) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          await this.renderPageSnapshot(snapshot, false);
          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }
  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot;
      }
    }
  }
  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML);
    }
  }
  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null;
  }
  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage || this.isPageRefresh) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise)
            await this.view.renderPromise;
          await this.renderPageSnapshot(snapshot, isPreview);
          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }
  followRedirect() {
    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }
  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }
  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted() {
    this.startRequest();
  }
  requestPreventedHandlingResponse(_request, _response) {}
  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : undefined;
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }
  requestFinished() {
    this.finishRequest();
  }
  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }
      this.scrolled = true;
    }
  }
  scrollToRestoredPosition() {
    const { scrollPosition } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true;
    }
  }
  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true;
    }
  }
  recordTimingMetric(metric) {
    this.timingMetrics[metric] = new Date().getTime();
  }
  getTimingMetrics() {
    return { ...this.timingMetrics };
  }
  hasPreloadedResponse() {
    return typeof this.response == "object";
  }
  shouldIssueRequest() {
    if (this.isSamePage) {
      return false;
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot();
    } else {
      return this.willRender;
    }
  }
  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }
  async render(callback) {
    this.cancelRender();
    await new Promise((resolve) => {
      this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
    });
    await callback();
    delete this.frame;
  }
  async renderPageSnapshot(snapshot, isPreview) {
    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
      await this.view.renderPage(snapshot, isPreview, this.willRender, this);
      this.performScroll();
    });
  }
  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
}
function isSuccessful(statusCode) {
  return statusCode >= 200 && statusCode < 300;
}

class BrowserAdapter {
  progressBar = new ProgressBar;
  constructor(session) {
    this.session = session;
  }
  visitProposedToLocation(location2, options) {
    if (locationIsVisitable(location2, this.navigator.rootLocation)) {
      this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
    } else {
      window.location.href = location2.toString();
    }
  }
  visitStarted(visit) {
    this.location = visit.location;
    visit.loadCachedSnapshot();
    visit.issueRequest();
    visit.goToSamePageAnchor();
  }
  visitRequestStarted(visit) {
    this.progressBar.setValue(0);
    if (visit.hasCachedSnapshot() || visit.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }
  visitRequestCompleted(visit) {
    visit.loadResponse();
  }
  visitRequestFailedWithStatusCode(visit, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        });
      default:
        return visit.loadResponse();
    }
  }
  visitRequestFinished(_visit) {}
  visitCompleted(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  pageInvalidated(reason) {
    this.reload(reason);
  }
  visitFailed(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  visitRendered(_visit) {}
  linkPrefetchingIsEnabledForLocation(location2) {
    return true;
  }
  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }
  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }
  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }
  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }
  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }
  showProgressBar = () => {
    this.progressBar.show();
  };
  reload(reason) {
    dispatch("turbo:reload", { detail: reason });
    window.location.href = this.location?.toString() || window.location.href;
  }
  get navigator() {
    return this.session.navigator;
  }
}

class CacheObserver {
  selector = "[data-turbo-temporary]";
  deprecatedSelector = "[data-turbo-cache=false]";
  started = false;
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  removeTemporaryElements = (_event) => {
    for (const element of this.temporaryElements) {
      element.remove();
    }
  };
  get temporaryElements() {
    return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
  }
  get temporaryElementsWithDeprecation() {
    const elements = document.querySelectorAll(this.deprecatedSelector);
    if (elements.length) {
      console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`);
    }
    return [...elements];
  }
}

class FrameRedirector {
  constructor(session, element) {
    this.session = session;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }
  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldRedirect(element);
  }
  linkClickIntercepted(element, url, event) {
    const frame = this.#findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event);
    }
  }
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter2);
    }
  }
  #shouldSubmit(form, submitter2) {
    const action = getAction$1(form, submitter2);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");
    return this.#shouldRedirect(form, submitter2) && locationIsVisitable(action, rootLocation);
  }
  #shouldRedirect(element, submitter2) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = this.#findFrameElement(element, submitter2);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  }
  #findFrameElement(element, submitter2) {
    const id = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  }
}

class History {
  location;
  restorationIdentifier = uuid();
  restorationData = {};
  started = false;
  pageLoaded = false;
  currentIndex = 0;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.currentIndex = history.state?.turbo?.restorationIndex || 0;
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }
  push(location2, restorationIdentifier) {
    this.update(history.pushState, location2, restorationIdentifier);
  }
  replace(location2, restorationIdentifier) {
    this.update(history.replaceState, location2, restorationIdentifier);
  }
  update(method, location2, restorationIdentifier = uuid()) {
    if (method === history.pushState)
      ++this.currentIndex;
    const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
    method.call(history, state, "", location2.href);
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier;
  }
  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {};
  }
  updateRestorationData(additionalData) {
    const { restorationIdentifier } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = {
      ...restorationData,
      ...additionalData
    };
  }
  assumeControlOfScrollRestoration() {
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = history.scrollRestoration ?? "auto";
      history.scrollRestoration = "manual";
    }
  }
  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }
  onPopState = (event) => {
    if (this.shouldHandlePopState()) {
      const { turbo } = event.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const { restorationIdentifier, restorationIndex } = turbo;
        this.restorationIdentifier = restorationIdentifier;
        const direction = restorationIndex > this.currentIndex ? "forward" : "back";
        this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
        this.currentIndex = restorationIndex;
      }
    }
  };
  onPageLoad = async (_event) => {
    await nextMicrotask();
    this.pageLoaded = true;
  };
  shouldHandlePopState() {
    return this.pageIsLoaded();
  }
  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete";
  }
}

class LinkPrefetchObserver {
  started = false;
  #prefetchedLink = null;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (this.started)
      return;
    if (this.eventTarget.readyState === "loading") {
      this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
    } else {
      this.#enable();
    }
  }
  stop() {
    if (!this.started)
      return;
    this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = false;
  }
  #enable = () => {
    this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = true;
  };
  #tryToPrefetchRequest = (event) => {
    if (getMetaContent("turbo-prefetch") === "false")
      return;
    const target = event.target;
    const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
    if (isLink && this.#isPrefetchable(target)) {
      const link = target;
      const location2 = getLocationForLink(link);
      if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
        this.#prefetchedLink = link;
        const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams, target);
        prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
      }
    }
  };
  #cancelRequestIfObsolete = (event) => {
    if (event.target === this.#prefetchedLink)
      this.#cancelPrefetchRequest();
  };
  #cancelPrefetchRequest = () => {
    prefetchCache.clear();
    this.#prefetchedLink = null;
  };
  #tryToUsePrefetchedRequest = (event) => {
    if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
      const cached = prefetchCache.get(event.detail.url.toString());
      if (cached) {
        event.detail.fetchRequest = cached;
      }
      prefetchCache.clear();
    }
  };
  prepareRequest(request) {
    const link = request.target;
    request.headers["X-Sec-Purpose"] = "prefetch";
    const turboFrame = link.closest("turbo-frame");
    const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
    if (turboFrameTarget && turboFrameTarget !== "_top") {
      request.headers["Turbo-Frame"] = turboFrameTarget;
    }
  }
  requestSucceededWithResponse() {}
  requestStarted(fetchRequest) {}
  requestErrored(fetchRequest) {}
  requestFinished(fetchRequest) {}
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}
  requestFailedWithResponse(fetchRequest, fetchResponse) {}
  get #cacheTtl() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  }
  #isPrefetchable(link) {
    const href = link.getAttribute("href");
    if (!href)
      return false;
    if (unfetchableLink(link))
      return false;
    if (linkToTheSamePage(link))
      return false;
    if (linkOptsOut(link))
      return false;
    if (nonSafeLink(link))
      return false;
    if (eventPrevented(link))
      return false;
    return true;
  }
}
var unfetchableLink = (link) => {
  return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
};
var linkToTheSamePage = (link) => {
  return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
};
var linkOptsOut = (link) => {
  if (link.getAttribute("data-turbo-prefetch") === "false")
    return true;
  if (link.getAttribute("data-turbo") === "false")
    return true;
  const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
  if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false")
    return true;
  return false;
};
var nonSafeLink = (link) => {
  const turboMethod = link.getAttribute("data-turbo-method");
  if (turboMethod && turboMethod.toLowerCase() !== "get")
    return true;
  if (isUJS(link))
    return true;
  if (link.hasAttribute("data-turbo-confirm"))
    return true;
  if (link.hasAttribute("data-turbo-stream"))
    return true;
  return false;
};
var isUJS = (link) => {
  return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
};
var eventPrevented = (link) => {
  const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
  return event.defaultPrevented;
};

class Navigator {
  constructor(delegate) {
    this.delegate = delegate;
  }
  proposeVisit(location2, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
      this.delegate.visitProposedToLocation(location2, options);
    }
  }
  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
      referrer: this.location,
      ...options
    });
    this.currentVisit.start();
  }
  submitForm(form, submitter2) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form, submitter2, true);
    this.formSubmission.start();
  }
  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }
    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get rootLocation() {
    return this.view.snapshot.rootLocation;
  }
  get history() {
    return this.delegate.history;
  }
  formSubmissionStarted(formSubmission) {
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }
  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.isSafe;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }
        const { statusCode, redirected } = fetchResponse;
        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: { statusCode, responseHTML, redirected }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }
  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      if (!snapshot.shouldPreserveScrollPosition) {
        this.view.scrollToTop();
      }
      this.view.clearSnapshotCache();
    }
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished(formSubmission) {
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }
  linkPrefetchingIsEnabledForLocation(location2) {
    if (typeof this.adapter.linkPrefetchingIsEnabledForLocation === "function") {
      return this.adapter.linkPrefetchingIsEnabledForLocation(location2);
    }
    return true;
  }
  visitStarted(visit) {
    this.delegate.visitStarted(visit);
  }
  visitCompleted(visit) {
    this.delegate.visitCompleted(visit);
    delete this.currentVisit;
  }
  locationWithActionIsSamePage(location2, action) {
    const anchor = getAnchor(location2);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
    return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  #getActionForFormSubmission(formSubmission, fetchResponse) {
    const { submitter: submitter2, formElement } = formSubmission;
    return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
  }
  #getDefaultAction(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance";
  }
}
var PageStage = {
  initial: 0,
  loading: 1,
  interactive: 2,
  complete: 3
};

class PageObserver {
  stage = PageStage.initial;
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }
  interpretReadyState = () => {
    const { readyState } = this;
    if (readyState == "interactive") {
      this.pageIsInteractive();
    } else if (readyState == "complete") {
      this.pageIsComplete();
    }
  };
  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }
  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }
  pageWillUnload = () => {
    this.delegate.pageWillUnload();
  };
  get readyState() {
    return document.readyState;
  }
}

class ScrollObserver {
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }
  onScroll = () => {
    this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
  };
  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
}

class StreamMessageRenderer {
  render({ fragment }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
      withAutofocusFromFragment(fragment, () => {
        withPreservedFocus(() => {
          document.documentElement.appendChild(fragment);
        });
      });
    });
  }
  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }
  leavingBardo() {}
}
function getPermanentElementMapForFragment(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const { id } = permanentElementInDocument;
    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
      if (elementInStream) {
        permanentElementMap[id] = [permanentElementInDocument, elementInStream];
      }
    }
  }
  return permanentElementMap;
}
async function withAutofocusFromFragment(fragment, callback) {
  const generatedID = `turbo-stream-autofocus-${uuid()}`;
  const turboStreams = fragment.querySelectorAll("turbo-stream");
  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
  let willAutofocusId = null;
  if (elementWithAutofocus) {
    if (elementWithAutofocus.id) {
      willAutofocusId = elementWithAutofocus.id;
    } else {
      willAutofocusId = generatedID;
    }
    elementWithAutofocus.id = willAutofocusId;
  }
  callback();
  await nextRepaint();
  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
  if (hasNoActiveElement && willAutofocusId) {
    const elementToAutofocus = document.getElementById(willAutofocusId);
    if (elementIsFocusable(elementToAutofocus)) {
      elementToAutofocus.focus();
    }
    if (elementToAutofocus && elementToAutofocus.id == generatedID) {
      elementToAutofocus.removeAttribute("id");
    }
  }
}
async function withPreservedFocus(callback) {
  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
  if (restoreFocusTo) {
    const elementToFocus = document.getElementById(restoreFocusTo);
    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
      elementToFocus.focus();
    }
  }
}
function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
  for (const streamElement of nodeListOfStreamElements) {
    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
    if (elementWithAutofocus)
      return elementWithAutofocus;
  }
  return null;
}

class StreamObserver {
  sources = new Set;
  #started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.#started) {
      this.#started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  stop() {
    if (this.#started) {
      this.#started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }
  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }
  streamSourceIsConnected(source) {
    return this.sources.has(source);
  }
  inspectFetchResponse = (event) => {
    const response = fetchResponseFromEvent(event);
    if (response && fetchResponseIsStream(response)) {
      event.preventDefault();
      this.receiveMessageResponse(response);
    }
  };
  receiveMessageEvent = (event) => {
    if (this.#started && typeof event.data == "string") {
      this.receiveMessageHTML(event.data);
    }
  };
  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }
  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
}
function fetchResponseFromEvent(event) {
  const fetchResponse = event.detail?.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse;
  }
}
function fetchResponseIsStream(response) {
  const contentType = response.contentType ?? "";
  return contentType.startsWith(StreamMessage.contentType);
}

class ErrorRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const { documentElement, body } = document;
    documentElement.replaceChild(newElement, body);
  }
  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }
  replaceHeadAndBody() {
    const { documentElement, head } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }
  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }
  get newHead() {
    return this.newSnapshot.headSnapshot.element;
  }
  get scriptElements() {
    return document.documentElement.querySelectorAll("script");
  }
}

class PageRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }
  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
  }
  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      };
    }
    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      };
    }
  }
  async prepareToRender() {
    this.#setLanguage();
    await this.mergeHead();
  }
  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }
  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }
  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot;
  }
  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  #setLanguage() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  }
  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();
    await mergedHeadElements;
    await newStylesheetElements;
    if (this.willRender) {
      this.removeUnusedDynamicStylesheetElements();
    }
  }
  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }
  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
  }
  async copyNewHeadStylesheetElements() {
    const loadingElements = [];
    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));
      document.head.appendChild(element);
    }
    await Promise.all(loadingElements);
  }
  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }
  removeUnusedDynamicStylesheetElements() {
    for (const element of this.unusedDynamicStylesheetElements) {
      document.head.removeChild(element);
    }
  }
  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];
    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }
    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }
  isCurrentElementInElementList(element, elementList) {
    for (const [index, newElement] of elementList.entries()) {
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue;
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index, 1);
          return true;
        }
      }
      if (newElement.isEqualNode(element)) {
        elementList.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }
  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }
  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }
  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }
  get unusedDynamicStylesheetElements() {
    return this.oldHeadStylesheetElements.filter((element) => {
      return element.getAttribute("data-turbo-track") === "dynamic";
    });
  }
  get oldHeadStylesheetElements() {
    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
  }
  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements;
  }
  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements;
  }
  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script");
  }
}

class MorphingPageRenderer extends PageRenderer {
  static renderElement(currentElement, newElement) {
    morphElements(currentElement, newElement, {
      callbacks: {
        beforeNodeMorphed: (element) => !canRefreshFrame(element)
      }
    });
    for (const frame of currentElement.querySelectorAll("turbo-frame")) {
      if (canRefreshFrame(frame))
        frame.reload();
    }
    dispatch("turbo:morph", { detail: { currentElement, newElement } });
  }
  async preservingPermanentElements(callback) {
    return await callback();
  }
  get renderMethod() {
    return "morph";
  }
  get shouldAutofocus() {
    return false;
  }
}
function canRefreshFrame(frame) {
  return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
}

class SnapshotCache {
  keys = [];
  snapshots = {};
  constructor(size) {
    this.size = size;
  }
  has(location2) {
    return toCacheKey(location2) in this.snapshots;
  }
  get(location2) {
    if (this.has(location2)) {
      const snapshot = this.read(location2);
      this.touch(location2);
      return snapshot;
    }
  }
  put(location2, snapshot) {
    this.write(location2, snapshot);
    this.touch(location2);
    return snapshot;
  }
  clear() {
    this.snapshots = {};
  }
  read(location2) {
    return this.snapshots[toCacheKey(location2)];
  }
  write(location2, snapshot) {
    this.snapshots[toCacheKey(location2)] = snapshot;
  }
  touch(location2) {
    const key = toCacheKey(location2);
    const index = this.keys.indexOf(key);
    if (index > -1)
      this.keys.splice(index, 1);
    this.keys.unshift(key);
    this.trim();
  }
  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
}

class PageView extends View {
  snapshotCache = new SnapshotCache(10);
  lastRenderedLocation = new URL(location.href);
  forceReloaded = false;
  shouldTransitionTo(newSnapshot) {
    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
  }
  renderPage(snapshot, isPreview = false, willRender = true, visit) {
    const shouldMorphPage = this.isPageRefresh(visit) && this.snapshot.shouldMorphPage;
    const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
    const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit?.changeHistory();
    }
    return this.render(renderer);
  }
  renderError(snapshot, visit) {
    visit?.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
    return this.render(renderer);
  }
  clearSnapshotCache() {
    this.snapshotCache.clear();
  }
  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const { lastRenderedLocation: location2 } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location2, cachedSnapshot);
      return cachedSnapshot;
    }
  }
  getCachedSnapshotForLocation(location2) {
    return this.snapshotCache.get(location2);
  }
  isPageRefresh(visit) {
    return !visit || this.lastRenderedLocation.pathname === visit.location.pathname && visit.action === "replace";
  }
  shouldPreserveScrollPosition(visit) {
    return this.isPageRefresh(visit) && this.snapshot.shouldPreserveScrollPosition;
  }
  get snapshot() {
    return PageSnapshot.fromElement(this.element);
  }
}

class Preloader {
  selector = "a[data-turbo-preload]";
  constructor(delegate, snapshotCache) {
    this.delegate = delegate;
    this.snapshotCache = snapshotCache;
  }
  start() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", this.#preloadAll);
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }
  stop() {
    document.removeEventListener("DOMContentLoaded", this.#preloadAll);
  }
  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      if (this.delegate.shouldPreloadLink(link)) {
        this.preloadURL(link);
      }
    }
  }
  async preloadURL(link) {
    const location2 = new URL(link.href);
    if (this.snapshotCache.has(location2)) {
      return;
    }
    const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams, link);
    await fetchRequest.perform();
  }
  prepareRequest(fetchRequest) {
    fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
  }
  async requestSucceededWithResponse(fetchRequest, fetchResponse) {
    try {
      const responseHTML = await fetchResponse.responseHTML;
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      this.snapshotCache.put(fetchRequest.url, snapshot);
    } catch (_) {}
  }
  requestStarted(fetchRequest) {}
  requestErrored(fetchRequest) {}
  requestFinished(fetchRequest) {}
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}
  requestFailedWithResponse(fetchRequest, fetchResponse) {}
  #preloadAll = () => {
    this.preloadOnLoadLinksForView(document.body);
  };
}

class Cache {
  constructor(session) {
    this.session = session;
  }
  clear() {
    this.session.clearCache();
  }
  resetCacheControl() {
    this.#setCacheControl("");
  }
  exemptPageFromCache() {
    this.#setCacheControl("no-cache");
  }
  exemptPageFromPreview() {
    this.#setCacheControl("no-preview");
  }
  #setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
}

class Session {
  navigator = new Navigator(this);
  history = new History(this);
  view = new PageView(this, document.documentElement);
  adapter = new BrowserAdapter(this);
  pageObserver = new PageObserver(this);
  cacheObserver = new CacheObserver;
  linkPrefetchObserver = new LinkPrefetchObserver(this, document);
  linkClickObserver = new LinkClickObserver(this, window);
  formSubmitObserver = new FormSubmitObserver(this, document);
  scrollObserver = new ScrollObserver(this);
  streamObserver = new StreamObserver(this);
  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
  frameRedirector = new FrameRedirector(this, document.documentElement);
  streamMessageRenderer = new StreamMessageRenderer;
  cache = new Cache(this);
  enabled = true;
  started = false;
  #pageRefreshDebouncePeriod = 150;
  constructor(recentRequests2) {
    this.recentRequests = recentRequests2;
    this.preloader = new Preloader(this, this.view.snapshotCache);
    this.debouncedRefresh = this.refresh;
    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
  }
  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.linkPrefetchObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }
  disable() {
    this.enabled = false;
  }
  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.linkPrefetchObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.preloader.stop();
      this.started = false;
    }
  }
  registerAdapter(adapter) {
    this.adapter = adapter;
  }
  visit(location2, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;
    if (frameElement instanceof FrameElement) {
      const action = options.action || getVisitAction(frameElement);
      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
      frameElement.src = location2.toString();
    } else {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
  }
  refresh(url, requestId) {
    const isRecentRequest = requestId && this.recentRequests.has(requestId);
    const isCurrentUrl = url === document.baseURI;
    if (!isRecentRequest && !this.navigator.currentVisit && isCurrentUrl) {
      this.visit(url, { action: "replace", shouldCacheSnapshot: false });
    }
  }
  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }
  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }
  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }
  clearCache() {
    this.view.clearSnapshotCache();
  }
  setProgressBarDelay(delay) {
    console.warn("Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`");
    this.progressBarDelay = delay;
  }
  set progressBarDelay(delay) {
    config.drive.progressBarDelay = delay;
  }
  get progressBarDelay() {
    return config.drive.progressBarDelay;
  }
  set drive(value) {
    config.drive.enabled = value;
  }
  get drive() {
    return config.drive.enabled;
  }
  set formMode(value) {
    config.forms.mode = value;
  }
  get formMode() {
    return config.forms.mode;
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  get pageRefreshDebouncePeriod() {
    return this.#pageRefreshDebouncePeriod;
  }
  set pageRefreshDebouncePeriod(value) {
    this.refresh = debounce(this.debouncedRefresh.bind(this), value);
    this.#pageRefreshDebouncePeriod = value;
  }
  shouldPreloadLink(element) {
    const isUnsafe = element.hasAttribute("data-turbo-method");
    const isStream = element.hasAttribute("data-turbo-stream");
    const frameTarget = element.getAttribute("data-turbo-frame");
    const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
    if (isUnsafe || isStream || frame instanceof FrameElement) {
      return false;
    } else {
      const location2 = new URL(element.href);
      return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
  }
  historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
    if (this.enabled) {
      this.navigator.startVisit(location2, restorationIdentifier, {
        action: "restore",
        historyChanged: true,
        direction
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }
  scrollPositionChanged(position) {
    this.history.updateRestorationData({ scrollPosition: position });
  }
  willSubmitFormLinkToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
  }
  submittedFormLinkToLocation() {}
  canPrefetchRequestToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.navigator.linkPrefetchingIsEnabledForLocation(location2);
  }
  willFollowLinkToLocation(link, location2, event) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
  }
  followedLinkToLocation(link, location2) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
    this.visit(location2.href, { action, acceptsStreamResponse });
  }
  allowsVisitingLocationWithAction(location2, action) {
    return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
  }
  visitProposedToLocation(location2, options) {
    extendURLWithDeprecatedProperties(location2);
    this.adapter.visitProposedToLocation(location2, options);
  }
  visitStarted(visit) {
    if (!visit.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
      this.view.markVisitDirection(visit.direction);
    }
    extendURLWithDeprecatedProperties(visit.location);
    if (!visit.silent) {
      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);
    }
  }
  visitCompleted(visit) {
    this.view.unmarkVisitDirection();
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());
  }
  locationWithActionIsSamePage(location2, action) {
    return this.navigator.locationWithActionIsSamePage(location2, action);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }
  willSubmitForm(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
  }
  formSubmitted(form, submitter2) {
    this.navigator.submitForm(form, submitter2);
  }
  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }
  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }
  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }
  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }
  viewWillCacheSnapshot() {
    if (!this.navigator.currentVisit?.silent) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }
  allowsImmediateRender({ element }, options) {
    const event = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: { render }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender(renderMethod);
  }
  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }
  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }
  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }
  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }
  applicationAllowsFollowingLinkToLocation(link, location2, ev) {
    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
    return !event.defaultPrevented;
  }
  applicationAllowsVisitingLocation(location2) {
    const event = this.notifyApplicationBeforeVisitingLocation(location2);
    return !event.defaultPrevented;
  }
  notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
    return dispatch("turbo:click", {
      target: link,
      detail: { url: location2.href, originalEvent: event },
      cancelable: true
    });
  }
  notifyApplicationBeforeVisitingLocation(location2) {
    return dispatch("turbo:before-visit", {
      detail: { url: location2.href },
      cancelable: true
    });
  }
  notifyApplicationAfterVisitingLocation(location2, action) {
    return dispatch("turbo:visit", { detail: { url: location2.href, action } });
  }
  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache");
  }
  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: { newBody, ...options },
      cancelable: true
    });
  }
  notifyApplicationAfterRender(renderMethod) {
    return dispatch("turbo:render", { detail: { renderMethod } });
  }
  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: { url: this.location.href, timing }
    });
  }
  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(new HashChangeEvent("hashchange", {
      oldURL: oldURL.toString(),
      newURL: newURL.toString()
    }));
  }
  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", { target: frame });
  }
  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: { fetchResponse },
      target: frame,
      cancelable: true
    });
  }
  submissionIsNavigatable(form, submitter2) {
    if (config.forms.mode == "off") {
      return false;
    } else {
      const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
      if (config.forms.mode == "optin") {
        return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form);
      }
    }
  }
  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");
    if (config.drive.enabled || withinFrame) {
      if (container) {
        return container.getAttribute("data-turbo") != "false";
      } else {
        return true;
      }
    } else {
      if (container) {
        return container.getAttribute("data-turbo") == "true";
      } else {
        return false;
      }
    }
  }
  getActionForLink(link) {
    return getVisitAction(link) || "advance";
  }
  get snapshot() {
    return this.view.snapshot;
  }
}
function extendURLWithDeprecatedProperties(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
}
var deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString();
    }
  }
};
var session = new Session(recentRequests);
var { cache, navigator: navigator$1 } = session;
function start() {
  session.start();
}
function registerAdapter(adapter) {
  session.registerAdapter(adapter);
}
function visit(location2, options) {
  session.visit(location2, options);
}
function connectStreamSource(source) {
  session.connectStreamSource(source);
}
function disconnectStreamSource(source) {
  session.disconnectStreamSource(source);
}
function renderStreamMessage(message) {
  session.renderStreamMessage(message);
}
function clearCache() {
  console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  session.clearCache();
}
function setProgressBarDelay(delay) {
  console.warn("Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  config.drive.progressBarDelay = delay;
}
function setConfirmMethod(confirmMethod) {
  console.warn("Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  config.forms.confirm = confirmMethod;
}
function setFormMode(mode) {
  console.warn("Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
  config.forms.mode = mode;
}
var Turbo = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session,
  cache,
  PageRenderer,
  PageSnapshot,
  FrameRenderer,
  fetch: fetchWithTurboHeaders,
  config,
  start,
  registerAdapter,
  visit,
  connectStreamSource,
  disconnectStreamSource,
  renderStreamMessage,
  clearCache,
  setProgressBarDelay,
  setConfirmMethod,
  setFormMode
});

class TurboFrameMissingError extends Error {
}

class FrameController {
  fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
  #currentFetchRequest = null;
  #resolveVisitPromise = () => {};
  #connected = false;
  #hasBeenLoaded = false;
  #ignoredAttributes = new Set;
  #shouldMorphFrame = false;
  action = null;
  constructor(element) {
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }
  connect() {
    if (!this.#connected) {
      this.#connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.#loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }
  disconnect() {
    if (this.#connected) {
      this.#connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }
  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.#loadSourceURL();
    }
  }
  sourceURLChanged() {
    if (this.#isIgnoringChangesTo("src"))
      return;
    if (this.element.isConnected) {
      this.complete = false;
    }
    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
      this.#loadSourceURL();
    }
  }
  sourceURLReloaded() {
    const { refresh, src } = this.element;
    this.#shouldMorphFrame = src && refresh === "morph";
    this.element.removeAttribute("complete");
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded;
  }
  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.#loadSourceURL();
    }
  }
  async#loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.#visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.#hasBeenLoaded = true;
    }
  }
  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
      this.sourceURL = fetchResponse.response.url;
    }
    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const document2 = parseHTMLDocument(html);
        const pageSnapshot = PageSnapshot.fromDocument(document2);
        if (pageSnapshot.isVisitable) {
          await this.#loadFrameResponse(fetchResponse, document2);
        } else {
          await this.#handleUnvisitableFrameResponse(fetchResponse);
        }
      }
    } finally {
      this.#shouldMorphFrame = false;
      this.fetchResponseLoaded = () => Promise.resolve();
    }
  }
  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
    this.#loadSourceURL();
  }
  willSubmitFormLinkToLocation(link) {
    return this.#shouldInterceptNavigation(link);
  }
  submittedFormLinkToLocation(link, _location, form) {
    const frame = this.#findFrameElement(link);
    if (frame)
      form.setAttribute("data-turbo-frame", frame.id);
  }
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldInterceptNavigation(element);
  }
  linkClickIntercepted(element, location2) {
    this.#navigateFrame(element, location2);
  }
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }
    this.formSubmission = new FormSubmission(this, element, submitter2);
    const { fetchRequest } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }
  prepareRequest(request) {
    request.headers["Turbo-Frame"] = this.id;
    if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    markAsBusy(this.element);
  }
  requestPreventedHandlingResponse(_request, _response) {
    this.#resolveVisitPromise();
  }
  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  async requestFailedWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  requestErrored(request, error) {
    console.error(error);
    this.#resolveVisitPromise();
  }
  requestFinished(_request) {
    clearBusyState(this.element);
  }
  formSubmissionStarted({ formElement }) {
    markAsBusy(formElement, this.#findFrameElement(formElement));
  }
  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
    frame.delegate.loadResponse(response);
    if (!formSubmission.isSafe) {
      session.clearCache();
    }
  }
  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
    session.clearCache();
  }
  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }
  formSubmissionFinished({ formElement }) {
    clearBusyState(formElement, this.#findFrameElement(formElement));
  }
  allowsImmediateRender({ element: newFrame }, options) {
    const event = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: { newFrame, ...options },
      cancelable: true
    });
    const {
      defaultPrevented,
      detail: { render }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {}
  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }
  viewInvalidated() {}
  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }
  visitCachedSnapshot = ({ element }) => {
    const frame = element.querySelector("#" + this.element.id);
    if (frame && this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }
    delete this.previousFrameElement;
  };
  async#loadFrameResponse(fetchResponse, document2) {
    const newFrameElement = await this.extractForeignFrameElement(document2.body);
    const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
      if (this.view.renderPromise)
        await this.view.renderPromise;
      this.changeHistory();
      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
      this.#handleFrameMissingFromResponse(fetchResponse);
    }
  }
  async#visit(url) {
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams, this.element);
    this.#currentFetchRequest?.cancel();
    this.#currentFetchRequest = request;
    return new Promise((resolve) => {
      this.#resolveVisitPromise = () => {
        this.#resolveVisitPromise = () => {};
        this.#currentFetchRequest = null;
        resolve();
      };
      request.perform();
    });
  }
  #navigateFrame(element, url, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter2, element, frame));
    this.#withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }
  proposeVisitIfNavigatedWithAction(frame, action = null) {
    this.action = action;
    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const { visitCachedSnapshot } = frame.delegate;
      frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
        if (frame.src) {
          const { statusCode, redirected } = fetchResponse;
          const responseHTML = await fetchResponse.responseHTML;
          const response = { statusCode, redirected, responseHTML };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };
          if (this.action)
            options.action = this.action;
          session.visit(frame.src, options);
        }
      };
    }
  }
  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }
  async#handleUnvisitableFrameResponse(fetchResponse) {
    console.warn(`The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`);
    await this.#visitResponse(fetchResponse.response);
  }
  #willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit2 = async (url, options) => {
      if (url instanceof Response) {
        this.#visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };
    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: { response, visit: visit2 },
      cancelable: true
    });
    return !event.defaultPrevented;
  }
  #handleFrameMissingFromResponse(fetchResponse) {
    this.view.missing();
    this.#throwFrameMissingError(fetchResponse);
  }
  #throwFrameMissingError(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  }
  async#visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const { location: location2, redirected, statusCode } = wrapped;
    return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
  }
  #findFrameElement(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    return getFrameElementById(id) ?? this.element;
  }
  async extractForeignFrameElement(container) {
    let element;
    const id = CSS.escape(this.id);
    try {
      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
      if (element) {
        return element;
      }
      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element);
      }
    } catch (error) {
      console.error(error);
      return new FrameElement;
    }
    return null;
  }
  #formActionIsVisitable(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  }
  #shouldInterceptNavigation(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter2 && !session.elementIsNavigatable(submitter2)) {
      return false;
    }
    return true;
  }
  get id() {
    return this.element.id;
  }
  get enabled() {
    return !this.element.disabled;
  }
  get sourceURL() {
    if (this.element.src) {
      return this.element.src;
    }
  }
  set sourceURL(sourceURL) {
    this.#ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL ?? null;
    });
  }
  get loadingStyle() {
    return this.element.loading;
  }
  get isLoading() {
    return this.formSubmission !== undefined || this.#resolveVisitPromise() !== undefined;
  }
  get complete() {
    return this.element.hasAttribute("complete");
  }
  set complete(value) {
    if (value) {
      this.element.setAttribute("complete", "");
    } else {
      this.element.removeAttribute("complete");
    }
  }
  get isActive() {
    return this.element.isActive && this.#connected;
  }
  get rootLocation() {
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = meta?.content ?? "/";
    return expandURL(root);
  }
  #isIgnoringChangesTo(attributeName) {
    return this.#ignoredAttributes.has(attributeName);
  }
  #ignoringChangesToAttribute(attributeName, callback) {
    this.#ignoredAttributes.add(attributeName);
    callback();
    this.#ignoredAttributes.delete(attributeName);
  }
  #withCurrentNavigationElement(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  }
}
function getFrameElementById(id) {
  if (id != null) {
    const element = document.getElementById(id);
    if (element instanceof FrameElement) {
      return element;
    }
  }
}
function activateElement(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }
    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element;
    }
  }
}
var StreamActions = {
  after() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));
  },
  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.append(this.templateContent));
  },
  before() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e));
  },
  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.prepend(this.templateContent));
  },
  remove() {
    this.targetElements.forEach((e) => e.remove());
  },
  replace() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphElements(targetElement, this.templateContent);
      } else {
        targetElement.replaceWith(this.templateContent);
      }
    });
  },
  update() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphChildren(targetElement, this.templateContent);
      } else {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      }
    });
  },
  refresh() {
    session.refresh(this.baseURI, this.requestId);
  }
};

class StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }
  async connectedCallback() {
    try {
      await this.render();
    } catch (error) {
      console.error(error);
    } finally {
      this.disconnect();
    }
  }
  async render() {
    return this.renderPromise ??= (async () => {
      const event = this.beforeRenderEvent;
      if (this.dispatchEvent(event)) {
        await nextRepaint();
        await event.detail.render(this);
      }
    })();
  }
  disconnect() {
    try {
      this.remove();
    } catch {}
  }
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach((c) => c.remove());
  }
  get duplicateChildren() {
    const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.getAttribute("id"));
    const newChildrenIds = [...this.templateContent?.children || []].filter((c) => !!c.getAttribute("id")).map((c) => c.getAttribute("id"));
    return existingChildren.filter((c) => newChildrenIds.includes(c.getAttribute("id")));
  }
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction;
      }
      this.#raise("unknown action");
    }
    this.#raise("action attribute is missing");
  }
  get targetElements() {
    if (this.target) {
      return this.targetElementsById;
    } else if (this.targets) {
      return this.targetElementsByQuery;
    } else {
      this.#raise("target or targets attribute is missing");
    }
  }
  get templateContent() {
    return this.templateElement.content.cloneNode(true);
  }
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template;
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild;
    }
    this.#raise("first child element must be a <template> element");
  }
  get action() {
    return this.getAttribute("action");
  }
  get target() {
    return this.getAttribute("target");
  }
  get targets() {
    return this.getAttribute("targets");
  }
  get requestId() {
    return this.getAttribute("request-id");
  }
  #raise(message) {
    throw new Error(`${this.description}: ${message}`);
  }
  get description() {
    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
  }
  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: { newStream: this, render: StreamElement.renderElement }
    });
  }
  get targetElementsById() {
    const element = this.ownerDocument?.getElementById(this.target);
    if (element !== null) {
      return [element];
    } else {
      return [];
    }
  }
  get targetElementsByQuery() {
    const elements = this.ownerDocument?.querySelectorAll(this.targets);
    if (elements.length !== 0) {
      return Array.prototype.slice.call(elements);
    } else {
      return [];
    }
  }
}

class StreamSourceElement extends HTMLElement {
  streamSource = null;
  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
    connectStreamSource(this.streamSource);
  }
  disconnectedCallback() {
    if (this.streamSource) {
      this.streamSource.close();
      disconnectStreamSource(this.streamSource);
    }
  }
  get src() {
    return this.getAttribute("src") || "";
  }
}
FrameElement.delegateConstructor = FrameController;
if (customElements.get("turbo-frame") === undefined) {
  customElements.define("turbo-frame", FrameElement);
}
if (customElements.get("turbo-stream") === undefined) {
  customElements.define("turbo-stream", StreamElement);
}
if (customElements.get("turbo-stream-source") === undefined) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}
(() => {
  let element = document.currentScript;
  if (!element)
    return;
  if (element.hasAttribute("data-turbo-suppress-warning"))
    return;
  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
    }
    element = element.parentElement;
  }
})();
window.Turbo = { ...Turbo, StreamActions };
start();

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
var consumer;
async function getConsumer() {
  return consumer || setConsumer(createConsumer2().then(setConsumer));
}
function setConsumer(newConsumer) {
  return consumer = newConsumer;
}
async function createConsumer2() {
  const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), exports_src));
  return createConsumer3();
}
async function subscribeTo(channel, mixin) {
  const { subscriptions } = await getConsumer();
  return subscriptions.create(channel, mixin);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
function walk(obj) {
  if (!obj || typeof obj !== "object")
    return obj;
  if (obj instanceof Date || obj instanceof RegExp)
    return obj;
  if (Array.isArray(obj))
    return obj.map(walk);
  return Object.keys(obj).reduce(function(acc, key) {
    var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
      return "_" + x.toLowerCase();
    });
    acc[camel] = walk(obj[key]);
    return acc;
  }, {});
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
class TurboCableStreamSourceElement extends HTMLElement {
  static observedAttributes = ["channel", "signed-stream-name"];
  async connectedCallback() {
    connectStreamSource(this);
    this.subscription = await subscribeTo(this.channel, {
      received: this.dispatchMessageEvent.bind(this),
      connected: this.subscriptionConnected.bind(this),
      disconnected: this.subscriptionDisconnected.bind(this)
    });
  }
  disconnectedCallback() {
    disconnectStreamSource(this);
    if (this.subscription)
      this.subscription.unsubscribe();
    this.subscriptionDisconnected();
  }
  attributeChangedCallback() {
    if (this.subscription) {
      this.disconnectedCallback();
      this.connectedCallback();
    }
  }
  dispatchMessageEvent(data) {
    const event = new MessageEvent("message", { data });
    return this.dispatchEvent(event);
  }
  subscriptionConnected() {
    this.setAttribute("connected", "");
  }
  subscriptionDisconnected() {
    this.removeAttribute("connected");
  }
  get channel() {
    const channel = this.getAttribute("channel");
    const signed_stream_name = this.getAttribute("signed-stream-name");
    return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
  }
}
if (customElements.get("turbo-cable-stream-source") === undefined) {
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
function encodeMethodIntoRequestBody(event) {
  if (event.target instanceof HTMLFormElement) {
    const { target: form, detail: { fetchOptions } } = event;
    form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
      const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams;
      const method = determineFetchMethod(submitter2, body, form);
      if (!/get/i.test(method)) {
        if (/post/i.test(method)) {
          body.delete("_method");
        } else {
          body.set("_method", method);
        }
        fetchOptions.method = "post";
      }
    }, { once: true });
  }
}
function determineFetchMethod(submitter2, body, form) {
  const formMethod = determineFormMethod(submitter2);
  const overrideMethod = body.get("_method");
  const method = form.getAttribute("method") || "get";
  if (typeof formMethod == "string") {
    return formMethod;
  } else if (typeof overrideMethod == "string") {
    return overrideMethod;
  } else {
    return method;
  }
}
function determineFormMethod(submitter2) {
  if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
    if (submitter2.name === "_method") {
      return submitter2.value;
    } else if (submitter2.hasAttribute("formmethod")) {
      return submitter2.formMethod;
    } else {
      return null;
    }
  } else {
    return null;
  }
}
function isBodyInit(body) {
  return body instanceof FormData || body instanceof URLSearchParams;
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
window.Turbo = exports_turbo_es2017_esm;
addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

// node_modules/@hotwired/stimulus/dist/stimulus.js
class EventListener {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = new Set;
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  hasBindings() {
    return this.unorderedBindings.size > 0;
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) => {
      const leftIndex = left.index, rightIndex = right.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
}
function extendEvent(event) {
  if ("immediatePropagationStopped" in event) {
    return event;
  } else {
    const { stopImmediatePropagation } = event;
    return Object.assign(event, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
}

class Dispatcher {
  constructor(application) {
    this.application = application;
    this.eventListenerMaps = new Map;
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach((eventListener) => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach((eventListener) => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding, clearEventListeners = false) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    if (clearEventListeners)
      this.clearEventListenersForBinding(binding);
  }
  handleError(error, message, detail = {}) {
    this.application.handleError(error, `Error ${message}`, detail);
  }
  clearEventListenersForBinding(binding) {
    const eventListener = this.fetchEventListenerForBinding(binding);
    if (!eventListener.hasBindings()) {
      eventListener.disconnect();
      this.removeMappedEventListenerFor(binding);
    }
  }
  removeMappedEventListenerFor(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    eventListenerMap.delete(cacheKey);
    if (eventListenerMap.size == 0)
      this.eventListenerMaps.delete(eventTarget);
  }
  fetchEventListenerForBinding(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = new Map;
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach((key) => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
}
var defaultActionDescriptorFilters = {
  stop({ event, value }) {
    if (value)
      event.stopPropagation();
    return true;
  },
  prevent({ event, value }) {
    if (value)
      event.preventDefault();
    return true;
  },
  self({ event, value, element }) {
    if (value) {
      return element === event.target;
    } else {
      return true;
    }
  }
};
var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
  const source = descriptorString.trim();
  const matches = source.match(descriptorPattern) || [];
  let eventName = matches[2];
  let keyFilter = matches[3];
  if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
    eventName += `.${keyFilter}`;
    keyFilter = "";
  }
  return {
    eventTarget: parseEventTarget(matches[4]),
    eventName,
    eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
    identifier: matches[5],
    methodName: matches[6],
    keyFilter: matches[1] || keyFilter
  };
}
function parseEventTarget(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
}
function parseEventOptions(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
}
function camelize(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
  return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
  return value.match(/[^\s]+/g) || [];
}
function isSomething(object) {
  return object !== null && object !== undefined;
}
function hasProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
var allModifiers = ["meta", "ctrl", "alt", "shift"];

class Action {
  constructor(element, index, descriptor, schema) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
    this.keyFilter = descriptor.keyFilter || "";
    this.schema = schema;
  }
  static forToken(token, schema) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
  }
  toString() {
    const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
    const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
  }
  shouldIgnoreKeyboardEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = this.keyFilter.split("+");
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
    if (!standardFilter) {
      return false;
    }
    if (!hasProperty(this.keyMappings, standardFilter)) {
      error(`contains unknown key filter: ${this.keyFilter}`);
    }
    return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
  }
  shouldIgnoreMouseEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = [this.keyFilter];
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    return false;
  }
  get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
    for (const { name, value } of Array.from(this.element.attributes)) {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        params[camelize(key)] = typecast(value);
      }
    }
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
  get keyMappings() {
    return this.schema.keyMappings;
  }
  keyFilterDissatisfied(event, filters) {
    const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
    return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
  }
}
var defaultEventNames = {
  a: () => "click",
  button: () => "click",
  form: () => "submit",
  details: () => "toggle",
  input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
  select: () => "change",
  textarea: () => "input"
};
function getDefaultEventNameForElement(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
}
function error(message) {
  throw new Error(message);
}
function typecast(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
}

class Binding {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event) {
    const actionEvent = this.prepareActionEvent(event);
    if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
      this.invokeWithEvent(actionEvent);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  applyEventModifiers(event) {
    const { element } = this.action;
    const { actionDescriptorFilters } = this.context.application;
    const { controller } = this.context;
    let passes = true;
    for (const [name, value] of Object.entries(this.eventOptions)) {
      if (name in actionDescriptorFilters) {
        const filter = actionDescriptorFilters[name];
        passes = passes && filter({ name, value, event, element, controller });
      } else {
        continue;
      }
    }
    return passes;
  }
  prepareActionEvent(event) {
    return Object.assign(event, { params: this.action.params });
  }
  invokeWithEvent(event) {
    const { target, currentTarget } = event;
    try {
      this.method.call(this.controller, event);
      this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
    } catch (error2) {
      const { identifier, controller, element, index } = this;
      const detail = { identifier, controller, element, index, event };
      this.context.handleError(error2, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
      return false;
    }
    if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
      return false;
    }
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
}

class ElementObserver {
  constructor(element, delegate) {
    this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = new Set;
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(element, attributeName) {
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
}

class AttributeObserver {
  constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
}
function add(map, key, value) {
  fetch2(map, key).add(value);
}
function del(map, key, value) {
  fetch2(map, key).delete(value);
  prune(map, key);
}
function fetch2(map, key) {
  let values = map.get(key);
  if (!values) {
    values = new Set;
    map.set(key, values);
  }
  return values;
}
function prune(map, key) {
  const values = map.get(key);
  if (values != null && values.size == 0) {
    map.delete(key);
  }
}

class Multimap {
  constructor() {
    this.valuesByKey = new Map;
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) => values.concat(Array.from(set)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) => size + set.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some((set) => set.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
  }
}
class SelectorObserver {
  constructor(element, selector, delegate, details) {
    this._selector = selector;
    this.details = details;
    this.elementObserver = new ElementObserver(element, this);
    this.delegate = delegate;
    this.matchesByElement = new Multimap;
  }
  get started() {
    return this.elementObserver.started;
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    this._selector = selector;
    this.refresh();
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get element() {
    return this.elementObserver.element;
  }
  matchElement(element) {
    const { selector } = this;
    if (selector) {
      const matches = element.matches(selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    } else {
      return false;
    }
  }
  matchElementsInTree(tree) {
    const { selector } = this;
    if (selector) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
      return match.concat(matches);
    } else {
      return [];
    }
  }
  elementMatched(element) {
    const { selector } = this;
    if (selector) {
      this.selectorMatched(element, selector);
    }
  }
  elementUnmatched(element) {
    const selectors = this.matchesByElement.getKeysForValue(element);
    for (const selector of selectors) {
      this.selectorUnmatched(element, selector);
    }
  }
  elementAttributeChanged(element, _attributeName) {
    const { selector } = this;
    if (selector) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(selector, element);
      if (matches && !matchedBefore) {
        this.selectorMatched(element, selector);
      } else if (!matches && matchedBefore) {
        this.selectorUnmatched(element, selector);
      }
    }
  }
  selectorMatched(element, selector) {
    this.delegate.selectorMatched(element, selector, this.details);
    this.matchesByElement.add(selector, element);
  }
  selectorUnmatched(element, selector) {
    this.delegate.selectorUnmatched(element, selector, this.details);
    this.matchesByElement.delete(selector, element);
  }
}

class StringMapObserver {
  constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = new Map;
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue2 = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue2)
          this.stringMapKeyRemoved(key, attributeName, oldValue2);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map((attribute) => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
}

class TokenListObserver {
  constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap;
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback) {
    this.attributeObserver.pause(callback);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach((token) => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach((token) => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
}
function parseTokenString(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
}
function zip(left, right) {
  const length = Math.max(left.length, right.length);
  return Array.from({ length }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
  return left && right && left.index == right.index && left.content == right.content;
}

class ValueListObserver {
  constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = new WeakMap;
    this.valuesByTokenByElement = new WeakMap;
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = new Map;
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return { value };
    } catch (error2) {
      return { error: error2 };
    }
  }
}

class BindingObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = new Map;
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token, this.schema);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
}

class ValueObserver {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
  }
  start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null)
      return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
      if (defaultValue != null && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), undefined);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      try {
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      } catch (error2) {
        if (error2 instanceof TypeError) {
          error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
        }
        throw error2;
      }
    }
  }
  get valueDescriptors() {
    const { valueDescriptorMap } = this;
    return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach((key) => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
}

class TargetObserver {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap;
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({ element, content: name }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({ element, content: name }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === undefined || _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === undefined || _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
}
function readInheritableStaticArrayValues(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor2) => {
    getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
    return values;
  }, new Set));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor2) => {
    pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
    return pairs;
  }, []);
}
function getAncestorsForConstructor(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
}

class OutletObserver {
  constructor(context, delegate) {
    this.started = false;
    this.context = context;
    this.delegate = delegate;
    this.outletsByName = new Multimap;
    this.outletElementsByName = new Multimap;
    this.selectorObserverMap = new Map;
    this.attributeObserverMap = new Map;
  }
  start() {
    if (!this.started) {
      this.outletDefinitions.forEach((outletName) => {
        this.setupSelectorObserverForOutlet(outletName);
        this.setupAttributeObserverForOutlet(outletName);
      });
      this.started = true;
      this.dependentContexts.forEach((context) => context.refresh());
    }
  }
  refresh() {
    this.selectorObserverMap.forEach((observer) => observer.refresh());
    this.attributeObserverMap.forEach((observer) => observer.refresh());
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.disconnectAllOutlets();
      this.stopSelectorObservers();
      this.stopAttributeObservers();
    }
  }
  stopSelectorObservers() {
    if (this.selectorObserverMap.size > 0) {
      this.selectorObserverMap.forEach((observer) => observer.stop());
      this.selectorObserverMap.clear();
    }
  }
  stopAttributeObservers() {
    if (this.attributeObserverMap.size > 0) {
      this.attributeObserverMap.forEach((observer) => observer.stop());
      this.attributeObserverMap.clear();
    }
  }
  selectorMatched(element, _selector, { outletName }) {
    const outlet = this.getOutlet(element, outletName);
    if (outlet) {
      this.connectOutlet(outlet, element, outletName);
    }
  }
  selectorUnmatched(element, _selector, { outletName }) {
    const outlet = this.getOutletFromMap(element, outletName);
    if (outlet) {
      this.disconnectOutlet(outlet, element, outletName);
    }
  }
  selectorMatchElement(element, { outletName }) {
    const selector = this.selector(outletName);
    const hasOutlet = this.hasOutlet(element, outletName);
    const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
    if (selector) {
      return hasOutlet && hasOutletController && element.matches(selector);
    } else {
      return false;
    }
  }
  elementMatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementAttributeValueChanged(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementUnmatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  connectOutlet(outlet, element, outletName) {
    var _a;
    if (!this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.add(outletName, outlet);
      this.outletElementsByName.add(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === undefined || _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
    }
  }
  disconnectOutlet(outlet, element, outletName) {
    var _a;
    if (this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.delete(outletName, outlet);
      this.outletElementsByName.delete(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === undefined || _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
    }
  }
  disconnectAllOutlets() {
    for (const outletName of this.outletElementsByName.keys) {
      for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
        for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
          this.disconnectOutlet(outlet, element, outletName);
        }
      }
    }
  }
  updateSelectorObserverForOutlet(outletName) {
    const observer = this.selectorObserverMap.get(outletName);
    if (observer) {
      observer.selector = this.selector(outletName);
    }
  }
  setupSelectorObserverForOutlet(outletName) {
    const selector = this.selector(outletName);
    const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
    this.selectorObserverMap.set(outletName, selectorObserver);
    selectorObserver.start();
  }
  setupAttributeObserverForOutlet(outletName) {
    const attributeName = this.attributeNameForOutletName(outletName);
    const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
    this.attributeObserverMap.set(outletName, attributeObserver);
    attributeObserver.start();
  }
  selector(outletName) {
    return this.scope.outlets.getSelectorForOutletName(outletName);
  }
  attributeNameForOutletName(outletName) {
    return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
  }
  getOutletNameFromOutletAttributeName(attributeName) {
    return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
  }
  get outletDependencies() {
    const dependencies = new Multimap;
    this.router.modules.forEach((module) => {
      const constructor = module.definition.controllerConstructor;
      const outlets = readInheritableStaticArrayValues(constructor, "outlets");
      outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
    });
    return dependencies;
  }
  get outletDefinitions() {
    return this.outletDependencies.getKeysForValue(this.identifier);
  }
  get dependentControllerIdentifiers() {
    return this.outletDependencies.getValuesForKey(this.identifier);
  }
  get dependentContexts() {
    const identifiers = this.dependentControllerIdentifiers;
    return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
  }
  hasOutlet(element, outletName) {
    return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
  }
  getOutlet(element, outletName) {
    return this.application.getControllerForElementAndIdentifier(element, outletName);
  }
  getOutletFromMap(element, outletName) {
    return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
  }
  get scope() {
    return this.context.scope;
  }
  get schema() {
    return this.context.schema;
  }
  get identifier() {
    return this.context.identifier;
  }
  get application() {
    return this.context.application;
  }
  get router() {
    return this.application.router;
  }
}

class Context {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    this.outletObserver = new OutletObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error2) {
      this.handleError(error2, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    this.outletObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error2) {
      this.handleError(error2, "connecting controller");
    }
  }
  refresh() {
    this.outletObserver.refresh();
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error2) {
      this.handleError(error2, "disconnecting controller");
    }
    this.outletObserver.stop();
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error2, message, detail = {}) {
    const { identifier, controller, element } = this;
    detail = Object.assign({ identifier, controller, element }, detail);
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  outletConnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
  }
  outletDisconnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
}
function bless(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
  const shadowConstructor = extend2(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
}
function getBlessedProperties(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
}
function getShadowProperties(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, { [key]: descriptor });
    }
    return shadowProperties;
  }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
}
var getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
var extend2 = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: { value: extended }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a = function() {
      this.a.call(this);
    };
    const b = extendWithReflect(a);
    b.prototype.a = function() {};
    return new b;
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error2) {
    return (constructor) => class extended extends constructor {
    };
  }
})();
function blessDefinition(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
}

class Module {
  constructor(application, definition) {
    this.application = application;
    this.definition = blessDefinition(definition);
    this.contextsByScope = new WeakMap;
    this.connectedContexts = new Set;
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
}

class ClassMap {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
}

class DataMap {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
}

class Guide {
  constructor(logger) {
    this.warnedKeysByObject = new WeakMap;
    this.logger = logger;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = new Set;
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
}
function attributeValueContainsToken(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
}

class TargetSet {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [
      ...targets,
      ...this.findAllTargets(targetName),
      ...this.findAllLegacyTargets(targetName)
    ], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const { identifier } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` + `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
}

class OutletSet {
  constructor(scope, controllerElement) {
    this.scope = scope;
    this.controllerElement = controllerElement;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(outletName) {
    return this.find(outletName) != null;
  }
  find(...outletNames) {
    return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
  }
  findAll(...outletNames) {
    return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
  }
  getSelectorForOutletName(outletName) {
    const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
    return this.controllerElement.getAttribute(attributeName);
  }
  findOutlet(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    if (selector)
      return this.findElement(selector, outletName);
  }
  findAllOutlets(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    return selector ? this.findAllElements(selector, outletName) : [];
  }
  findElement(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
  }
  findAllElements(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName));
  }
  matchesElement(element, selector, outletName) {
    const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
    return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
  }
}

class Scope {
  constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = (element2) => {
      return element2.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
    this.outlets = new OutletSet(this.documentScope, element);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [
      ...this.element.matches(selector) ? [this.element] : [],
      ...this.queryElements(selector).filter(this.containsElement)
    ];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
  get isDocumentScope() {
    return this.element === document.documentElement;
  }
  get documentScope() {
    return this.isDocumentScope ? this : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
  }
}

class ScopeObserver {
  constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = new WeakMap;
    this.scopeReferenceCounts = new WeakMap;
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const { element, content: identifier } = token;
    return this.parseValueForElementAndIdentifier(element, identifier);
  }
  parseValueForElementAndIdentifier(element, identifier) {
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = new Map;
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
}

class Router {
  constructor(application) {
    this.application = application;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap;
    this.modulesByIdentifier = new Map;
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
    const afterLoad = definition.controllerConstructor.afterLoad;
    if (afterLoad) {
      afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
    }
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find((context) => context.element == element);
    }
  }
  proposeToConnectScopeForElementAndIdentifier(element, identifier) {
    const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
    if (scope) {
      this.scopeObserver.elementMatchedValue(scope.element, scope);
    } else {
      console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
    }
  }
  handleError(error2, message, detail) {
    this.application.handleError(error2, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.disconnectContextForScope(scope));
  }
}
var defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: (identifier) => `data-${identifier}-target`,
  outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
  keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
};
function objectFromEntries(array) {
  return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
}

class Application {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
  }
  static start(element, schema) {
    const application = new this(element, schema);
    application.start();
    return application;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    this.load({ identifier, controllerConstructor });
  }
  registerActionOption(name, filter) {
    this.actionDescriptorFilters[name] = filter;
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach((definition) => {
      if (definition.controllerConstructor.shouldLoad) {
        this.router.loadDefinition(definition);
      }
    });
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map((context) => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error2, message, detail) {
    var _a;
    this.logger.error(`%s

%o

%o`, message, error2, detail);
    (_a = window.onerror) === null || _a === undefined || _a.call(window, message, "", 0, 0, error2);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({ application: this }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
}
function domReady() {
  return new Promise((resolve) => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve());
    } else {
      resolve();
    }
  });
}
function ClassPropertiesBlessing(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
}
function propertiesForClassDefinition(key) {
  return {
    [`${key}Class`]: {
      get() {
        const { classes } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
}
function OutletPropertiesBlessing(constructor) {
  const outlets = readInheritableStaticArrayValues(constructor, "outlets");
  return outlets.reduce((properties, outletDefinition) => {
    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
  }, {});
}
function getOutletController(controller, element, identifier) {
  return controller.application.getControllerForElementAndIdentifier(element, identifier);
}
function getControllerAndEnsureConnectedScope(controller, element, outletName) {
  let outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
  outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
}
function propertiesForOutletDefinition(name) {
  const camelizedName = namespaceCamelize(name);
  return {
    [`${camelizedName}Outlet`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
          if (outletController)
            return outletController;
          throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
        }
        throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
      }
    },
    [`${camelizedName}Outlets`]: {
      get() {
        const outlets = this.outlets.findAll(name);
        if (outlets.length > 0) {
          return outlets.map((outletElement) => {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
          }).filter((controller) => controller);
        }
        return [];
      }
    },
    [`${camelizedName}OutletElement`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          return outletElement;
        } else {
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      }
    },
    [`${camelizedName}OutletElements`]: {
      get() {
        return this.outlets.findAll(name);
      }
    },
    [`has${capitalize(camelizedName)}Outlet`]: {
      get() {
        return this.outlets.has(name);
      }
    }
  };
}
function TargetPropertiesBlessing(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
}
function propertiesForTargetDefinition(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
}
function ValuePropertiesBlessing(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, { [attributeName]: valueDescriptor });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
  const { key, name, reader: read, writer: write } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === undefined) {
          this.data.delete(key);
        } else {
          this.data.set(key, write(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
  return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition
  });
}
function parseValueTypeConstant(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
}
function parseValueTypeDefault(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue))
    return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]")
    return "object";
}
function parseValueTypeObject(payload) {
  const { controller, token, typeObject } = payload;
  const hasType = isSomething(typeObject.type);
  const hasDefault = isSomething(typeObject.default);
  const fullObject = hasType && hasDefault;
  const onlyType = hasType && !hasDefault;
  const onlyDefault = !hasType && hasDefault;
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
  if (onlyType)
    return typeFromObject;
  if (onlyDefault)
    return typeFromDefaultValue;
  if (typeFromObject !== typeFromDefaultValue) {
    const propertyPath = controller ? `${controller}.${token}` : token;
    throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
  }
  if (fullObject)
    return typeFromObject;
}
function parseValueTypeDefinition(payload) {
  const { controller, token, typeDefinition } = payload;
  const typeObject = { controller, token, typeObject: typeDefinition };
  const typeFromObject = parseValueTypeObject(typeObject);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type)
    return type;
  const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
  throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant)
    return defaultValuesByType[constant];
  const hasDefault = hasProperty(typeDefinition, "default");
  const hasType = hasProperty(typeDefinition, "type");
  const typeObject = typeDefinition;
  if (hasDefault)
    return typeObject.default;
  if (hasType) {
    const { type } = typeObject;
    const constantFromType = parseValueTypeConstant(type);
    if (constantFromType)
      return defaultValuesByType[constantFromType];
  }
  return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
  const { token, typeDefinition } = payload;
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(payload);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== undefined;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
}
var defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
var readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || String(value).toLowerCase() == "false");
  },
  number(value) {
    return Number(value.replace(/_/g, ""));
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
    }
    return object;
  },
  string(value) {
    return value;
  }
};
var writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};
function writeJSON(value) {
  return JSON.stringify(value);
}
function writeString(value) {
  return `${value}`;
}

class Controller {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  static afterLoad(_identifier, _application) {
    return;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get outlets() {
    return this.scope.outlets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {}
  connect() {}
  disconnect() {}
  dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, { detail, bubbles, cancelable });
    target.dispatchEvent(event);
    return event;
  }
}
Controller.blessings = [
  ClassPropertiesBlessing,
  TargetPropertiesBlessing,
  ValuePropertiesBlessing,
  OutletPropertiesBlessing
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};

// node_modules/@rails/activestorage/app/assets/javascripts/activestorage.esm.js
var sparkMd5 = {
  exports: {}
};
(function(module, exports) {
  (function(factory) {
    {
      module.exports = factory();
    }
  })(function(undefined$1) {
    var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function md5cycle(x, k) {
      var a = x[0], b = x[1], c = x[2], d = x[3];
      a += (b & c | ~b & d) + k[0] - 680876936 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[1] - 389564586 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[2] + 606105819 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[4] - 176418897 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[7] - 45705983 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[10] - 42063 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[13] - 40341101 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & d | c & ~d) + k[1] - 165796510 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[11] + 643717713 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[0] - 373897302 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[5] - 701558691 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[10] + 38016083 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[15] - 660478335 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[4] - 405537848 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[9] + 568446438 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[3] - 187363961 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[2] - 51403784 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b ^ c ^ d) + k[5] - 378558 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[14] - 35309556 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[7] - 155497632 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[13] + 681279174 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[0] - 358537222 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[3] - 722521979 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[6] + 76029189 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[9] - 640364487 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[12] - 421815835 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[15] + 530742520 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[2] - 995338651 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      x[0] = a + x[0] | 0;
      x[1] = b + x[1] | 0;
      x[2] = c + x[2] | 0;
      x[3] = d + x[3] | 0;
    }
    function md5blk(s) {
      var md5blks = [], i;
      for (i = 0;i < 64; i += 4) {
        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
      }
      return md5blks;
    }
    function md5blk_array(a) {
      var md5blks = [], i;
      for (i = 0;i < 64; i += 4) {
        md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
      }
      return md5blks;
    }
    function md51(s) {
      var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
      for (i = 64;i <= n; i += 64) {
        md5cycle(state, md5blk(s.substring(i - 64, i)));
      }
      s = s.substring(i - 64);
      length = s.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i = 0;i < length; i += 1) {
        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
      }
      tail[i >> 2] |= 128 << (i % 4 << 3);
      if (i > 55) {
        md5cycle(state, tail);
        for (i = 0;i < 16; i += 1) {
          tail[i] = 0;
        }
      }
      tmp = n * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function md51_array(a) {
      var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
      for (i = 64;i <= n; i += 64) {
        md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
      }
      a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
      length = a.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i = 0;i < length; i += 1) {
        tail[i >> 2] |= a[i] << (i % 4 << 3);
      }
      tail[i >> 2] |= 128 << (i % 4 << 3);
      if (i > 55) {
        md5cycle(state, tail);
        for (i = 0;i < 16; i += 1) {
          tail[i] = 0;
        }
      }
      tmp = n * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function rhex(n) {
      var s = "", j;
      for (j = 0;j < 4; j += 1) {
        s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
      }
      return s;
    }
    function hex(x) {
      var i;
      for (i = 0;i < x.length; i += 1) {
        x[i] = rhex(x[i]);
      }
      return x.join("");
    }
    if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592")
      ;
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
      (function() {
        function clamp(val, length) {
          val = val | 0 || 0;
          if (val < 0) {
            return Math.max(val + length, 0);
          }
          return Math.min(val, length);
        }
        ArrayBuffer.prototype.slice = function(from, to) {
          var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
          if (to !== undefined$1) {
            end = clamp(to, length);
          }
          if (begin > end) {
            return new ArrayBuffer(0);
          }
          num = end - begin;
          target = new ArrayBuffer(num);
          targetArray = new Uint8Array(target);
          sourceArray = new Uint8Array(this, begin, num);
          targetArray.set(sourceArray);
          return target;
        };
      })();
    }
    function toUtf8(str) {
      if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str));
      }
      return str;
    }
    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
      var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
      for (i = 0;i < length; i += 1) {
        arr[i] = str.charCodeAt(i);
      }
      return returnUInt8Array ? arr : buff;
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff));
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result = new Uint8Array(first.byteLength + second.byteLength);
      result.set(new Uint8Array(first));
      result.set(new Uint8Array(second), first.byteLength);
      return returnUInt8Array ? result : result.buffer;
    }
    function hexToBinaryString(hex2) {
      var bytes = [], length = hex2.length, x;
      for (x = 0;x < length - 1; x += 2) {
        bytes.push(parseInt(hex2.substr(x, 2), 16));
      }
      return String.fromCharCode.apply(String, bytes);
    }
    function SparkMD5() {
      this.reset();
    }
    SparkMD5.prototype.append = function(str) {
      this.appendBinary(toUtf8(str));
      return this;
    };
    SparkMD5.prototype.appendBinary = function(contents) {
      this._buff += contents;
      this._length += contents.length;
      var length = this._buff.length, i;
      for (i = 64;i <= length; i += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
      }
      this._buff = this._buff.substring(i - 64);
      return this;
    };
    SparkMD5.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
      for (i = 0;i < length; i += 1) {
        tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD5.prototype.reset = function() {
      this._buff = "";
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD5.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    };
    SparkMD5.prototype.setState = function(state) {
      this._buff = state.buff;
      this._length = state.length;
      this._hash = state.hash;
      return this;
    };
    SparkMD5.prototype.destroy = function() {
      delete this._hash;
      delete this._buff;
      delete this._length;
    };
    SparkMD5.prototype._finish = function(tail, length) {
      var i = length, tmp, lo, hi;
      tail[i >> 2] |= 128 << (i % 4 << 3);
      if (i > 55) {
        md5cycle(this._hash, tail);
        for (i = 0;i < 16; i += 1) {
          tail[i] = 0;
        }
      }
      tmp = this._length * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(this._hash, tail);
    };
    SparkMD5.hash = function(str, raw) {
      return SparkMD5.hashBinary(toUtf8(str), raw);
    };
    SparkMD5.hashBinary = function(content, raw) {
      var hash = md51(content), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    SparkMD5.ArrayBuffer = function() {
      this.reset();
    };
    SparkMD5.ArrayBuffer.prototype.append = function(arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
      this._length += arr.byteLength;
      for (i = 64;i <= length; i += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
      }
      this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
      return this;
    };
    SparkMD5.ArrayBuffer.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
      for (i = 0;i < length; i += 1) {
        tail[i >> 2] |= buff[i] << (i % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD5.ArrayBuffer.prototype.reset = function() {
      this._buff = new Uint8Array(0);
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD5.ArrayBuffer.prototype.getState = function() {
      var state = SparkMD5.prototype.getState.call(this);
      state.buff = arrayBuffer2Utf8Str(state.buff);
      return state;
    };
    SparkMD5.ArrayBuffer.prototype.setState = function(state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true);
      return SparkMD5.prototype.setState.call(this, state);
    };
    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
    SparkMD5.ArrayBuffer.hash = function(arr, raw) {
      var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    return SparkMD5;
  });
})(sparkMd5);
var SparkMD5 = sparkMd5.exports;
var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;

class FileChecksum {
  static create(file, callback) {
    const instance = new FileChecksum(file);
    instance.create(callback);
  }
  constructor(file) {
    this.file = file;
    this.chunkSize = 2097152;
    this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
    this.chunkIndex = 0;
  }
  create(callback) {
    this.callback = callback;
    this.md5Buffer = new SparkMD5.ArrayBuffer;
    this.fileReader = new FileReader;
    this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
    this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
    this.readNextChunk();
  }
  fileReaderDidLoad(event) {
    this.md5Buffer.append(event.target.result);
    if (!this.readNextChunk()) {
      const binaryDigest = this.md5Buffer.end(true);
      const base64digest = btoa(binaryDigest);
      this.callback(null, base64digest);
    }
  }
  fileReaderDidError(event) {
    this.callback(`Error reading ${this.file.name}`);
  }
  readNextChunk() {
    if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
      const start2 = this.chunkIndex * this.chunkSize;
      const end = Math.min(start2 + this.chunkSize, this.file.size);
      const bytes = fileSlice.call(this.file, start2, end);
      this.fileReader.readAsArrayBuffer(bytes);
      this.chunkIndex++;
      return true;
    } else {
      return false;
    }
  }
}
function getMetaValue(name) {
  const element = findElement(document.head, `meta[name="${name}"]`);
  if (element) {
    return element.getAttribute("content");
  }
}
function findElements(root, selector) {
  if (typeof root == "string") {
    selector = root;
    root = document;
  }
  const elements = root.querySelectorAll(selector);
  return toArray(elements);
}
function findElement(root, selector) {
  if (typeof root == "string") {
    selector = root;
    root = document;
  }
  return root.querySelector(selector);
}
function dispatchEvent2(element, type, eventInit = {}) {
  const { disabled } = element;
  const { bubbles, cancelable, detail } = eventInit;
  const event = document.createEvent("Event");
  event.initEvent(type, bubbles || true, cancelable || true);
  event.detail = detail || {};
  try {
    element.disabled = false;
    element.dispatchEvent(event);
  } finally {
    element.disabled = disabled;
  }
  return event;
}
function toArray(value) {
  if (Array.isArray(value)) {
    return value;
  } else if (Array.from) {
    return Array.from(value);
  } else {
    return [].slice.call(value);
  }
}

class BlobRecord {
  constructor(file, checksum, url, customHeaders = {}) {
    this.file = file;
    this.attributes = {
      filename: file.name,
      content_type: file.type || "application/octet-stream",
      byte_size: file.size,
      checksum
    };
    this.xhr = new XMLHttpRequest;
    this.xhr.open("POST", url, true);
    this.xhr.responseType = "json";
    this.xhr.setRequestHeader("Content-Type", "application/json");
    this.xhr.setRequestHeader("Accept", "application/json");
    this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    Object.keys(customHeaders).forEach((headerKey) => {
      this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
    });
    const csrfToken = getMetaValue("csrf-token");
    if (csrfToken != null) {
      this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
    }
    this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
    this.xhr.addEventListener("error", (event) => this.requestDidError(event));
  }
  get status() {
    return this.xhr.status;
  }
  get response() {
    const { responseType, response } = this.xhr;
    if (responseType == "json") {
      return response;
    } else {
      return JSON.parse(response);
    }
  }
  create(callback) {
    this.callback = callback;
    this.xhr.send(JSON.stringify({
      blob: this.attributes
    }));
  }
  requestDidLoad(event) {
    if (this.status >= 200 && this.status < 300) {
      const { response } = this;
      const { direct_upload } = response;
      delete response.direct_upload;
      this.attributes = response;
      this.directUploadData = direct_upload;
      this.callback(null, this.toJSON());
    } else {
      this.requestDidError(event);
    }
  }
  requestDidError(event) {
    this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
  }
  toJSON() {
    const result = {};
    for (const key in this.attributes) {
      result[key] = this.attributes[key];
    }
    return result;
  }
}

class BlobUpload {
  constructor(blob) {
    this.blob = blob;
    this.file = blob.file;
    const { url, headers } = blob.directUploadData;
    this.xhr = new XMLHttpRequest;
    this.xhr.open("PUT", url, true);
    this.xhr.responseType = "text";
    for (const key in headers) {
      this.xhr.setRequestHeader(key, headers[key]);
    }
    this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
    this.xhr.addEventListener("error", (event) => this.requestDidError(event));
  }
  create(callback) {
    this.callback = callback;
    this.xhr.send(this.file.slice());
  }
  requestDidLoad(event) {
    const { status, response } = this.xhr;
    if (status >= 200 && status < 300) {
      this.callback(null, response);
    } else {
      this.requestDidError(event);
    }
  }
  requestDidError(event) {
    this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
  }
}
var id = 0;

class DirectUpload {
  constructor(file, url, delegate, customHeaders = {}) {
    this.id = ++id;
    this.file = file;
    this.url = url;
    this.delegate = delegate;
    this.customHeaders = customHeaders;
  }
  create(callback) {
    FileChecksum.create(this.file, (error2, checksum) => {
      if (error2) {
        callback(error2);
        return;
      }
      const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);
      notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
      blob.create((error3) => {
        if (error3) {
          callback(error3);
        } else {
          const upload = new BlobUpload(blob);
          notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
          upload.create((error4) => {
            if (error4) {
              callback(error4);
            } else {
              callback(null, blob.toJSON());
            }
          });
        }
      });
    });
  }
}
function notify(object, methodName, ...messages) {
  if (object && typeof object[methodName] == "function") {
    return object[methodName](...messages);
  }
}

class DirectUploadController {
  constructor(input, file) {
    this.input = input;
    this.file = file;
    this.directUpload = new DirectUpload(this.file, this.url, this);
    this.dispatch("initialize");
  }
  start(callback) {
    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.name = this.input.name;
    this.input.insertAdjacentElement("beforebegin", hiddenInput);
    this.dispatch("start");
    this.directUpload.create((error2, attributes) => {
      if (error2) {
        hiddenInput.parentNode.removeChild(hiddenInput);
        this.dispatchError(error2);
      } else {
        hiddenInput.value = attributes.signed_id;
      }
      this.dispatch("end");
      callback(error2);
    });
  }
  uploadRequestDidProgress(event) {
    const progress = event.loaded / event.total * 100;
    if (progress) {
      this.dispatch("progress", {
        progress
      });
    }
  }
  get url() {
    return this.input.getAttribute("data-direct-upload-url");
  }
  dispatch(name, detail = {}) {
    detail.file = this.file;
    detail.id = this.directUpload.id;
    return dispatchEvent2(this.input, `direct-upload:${name}`, {
      detail
    });
  }
  dispatchError(error2) {
    const event = this.dispatch("error", {
      error: error2
    });
    if (!event.defaultPrevented) {
      alert(error2);
    }
  }
  directUploadWillCreateBlobWithXHR(xhr) {
    this.dispatch("before-blob-request", {
      xhr
    });
  }
  directUploadWillStoreFileWithXHR(xhr) {
    this.dispatch("before-storage-request", {
      xhr
    });
    xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
  }
}
var inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";

class DirectUploadsController {
  constructor(form) {
    this.form = form;
    this.inputs = findElements(form, inputSelector).filter((input) => input.files.length);
  }
  start(callback) {
    const controllers = this.createDirectUploadControllers();
    const startNextController = () => {
      const controller = controllers.shift();
      if (controller) {
        controller.start((error2) => {
          if (error2) {
            callback(error2);
            this.dispatch("end");
          } else {
            startNextController();
          }
        });
      } else {
        callback();
        this.dispatch("end");
      }
    };
    this.dispatch("start");
    startNextController();
  }
  createDirectUploadControllers() {
    const controllers = [];
    this.inputs.forEach((input) => {
      toArray(input.files).forEach((file) => {
        const controller = new DirectUploadController(input, file);
        controllers.push(controller);
      });
    });
    return controllers;
  }
  dispatch(name, detail = {}) {
    return dispatchEvent2(this.form, `direct-uploads:${name}`, {
      detail
    });
  }
}
var processingAttribute = "data-direct-uploads-processing";
var submitButtonsByForm = new WeakMap;
var started = false;
function start2() {
  if (!started) {
    started = true;
    document.addEventListener("click", didClick, true);
    document.addEventListener("submit", didSubmitForm, true);
    document.addEventListener("ajax:before", didSubmitRemoteElement);
  }
}
function didClick(event) {
  const button = event.target.closest("button, input");
  if (button && button.type === "submit" && button.form) {
    submitButtonsByForm.set(button.form, button);
  }
}
function didSubmitForm(event) {
  handleFormSubmissionEvent(event);
}
function didSubmitRemoteElement(event) {
  if (event.target.tagName == "FORM") {
    handleFormSubmissionEvent(event);
  }
}
function handleFormSubmissionEvent(event) {
  const form = event.target;
  if (form.hasAttribute(processingAttribute)) {
    event.preventDefault();
    return;
  }
  const controller = new DirectUploadsController(form);
  const { inputs } = controller;
  if (inputs.length) {
    event.preventDefault();
    form.setAttribute(processingAttribute, "");
    inputs.forEach(disable);
    controller.start((error2) => {
      form.removeAttribute(processingAttribute);
      if (error2) {
        inputs.forEach(enable);
      } else {
        submitForm(form);
      }
    });
  }
}
function submitForm(form) {
  let button = submitButtonsByForm.get(form) || findElement(form, "input[type=submit], button[type=submit]");
  if (button) {
    const { disabled } = button;
    button.disabled = false;
    button.focus();
    button.click();
    button.disabled = disabled;
  } else {
    button = document.createElement("input");
    button.type = "submit";
    button.style.display = "none";
    form.appendChild(button);
    button.click();
    form.removeChild(button);
  }
  submitButtonsByForm.delete(form);
}
function disable(input) {
  input.disabled = true;
}
function enable(input) {
  input.disabled = false;
}
function autostart() {
  if (window.ActiveStorage) {
    start2();
  }
}
setTimeout(autostart, 1);

// app/javascript/controllers/application.js
var application = Application.start();
start2();
document.querySelectorAll("[disabled]").forEach(function(obj) {
  return obj.classList.add("is-disabled");
});
window.addEventListener("click", function(t) {
  if (t.target.getAttribute("data-action") != "click->menu#open") {
    const e = document.querySelector("#cart_col.quickview"), c = document.querySelector("#filters_col.quickview"), mm = document.querySelector("#menu_col.quickview");
    mm == null || mm.contains(t.target) || mm.classList.remove("is-active"), e == null || e.contains(t.target) || e.classList.remove("is-active"), c == null || c.contains(t.target) || c.classList.remove("is-active");
  }
  t.stopPropagation();
});
window.addEventListener("turbo:load", function(t) {
  var _paq = window._paq = window._paq || [];
  _paq.push(["trackPageView"]);
  _paq.push(["enableLinkTracking"]);
  (function() {
    var u = "https://matomo.isprambiente.it/";
    _paq.push(["setTrackerUrl", u + "matomo.php"]);
    _paq.push(["setSiteId", "9"]);
    var d = document, g = d.createElement("script"), s = d.getElementsByTagName("script")[0];
    g.async = true;
    g.src = u + "matomo.js";
    s.parentNode.insertBefore(g, s);
  })();
  t.stopPropagation();
});
document.addEventListener("turbo:frame-missing", (event) => {
  const { detail: { response, visit: visit2 } } = event;
  event.preventDefault();
  visit2(response.url);
});
application.warning = false;
application.debug = false;
window.Stimulus = application;

// node_modules/@rails/request.js/src/fetch_response.js
class FetchResponse2 {
  constructor(response) {
    this.response = response;
  }
  get statusCode() {
    return this.response.status;
  }
  get redirected() {
    return this.response.redirected;
  }
  get ok() {
    return this.response.ok;
  }
  get unauthenticated() {
    return this.statusCode === 401;
  }
  get unprocessableEntity() {
    return this.statusCode === 422;
  }
  get authenticationURL() {
    return this.response.headers.get("WWW-Authenticate");
  }
  get contentType() {
    const contentType = this.response.headers.get("Content-Type") || "";
    return contentType.replace(/;.*$/, "");
  }
  get headers() {
    return this.response.headers;
  }
  get html() {
    if (this.contentType.match(/^(application|text)\/(html|xhtml\+xml)$/)) {
      return this.text;
    }
    return Promise.reject(new Error(`Expected an HTML response but got "${this.contentType}" instead`));
  }
  get json() {
    if (this.contentType.match(/^application\/.*json$/)) {
      return this.responseJson || (this.responseJson = this.response.json());
    }
    return Promise.reject(new Error(`Expected a JSON response but got "${this.contentType}" instead`));
  }
  get text() {
    return this.responseText || (this.responseText = this.response.text());
  }
  get isTurboStream() {
    return this.contentType.match(/^text\/vnd\.turbo-stream\.html/);
  }
  get isScript() {
    return this.contentType.match(/\b(?:java|ecma)script\b/);
  }
  async renderTurboStream() {
    if (this.isTurboStream) {
      if (window.Turbo) {
        await window.Turbo.renderStreamMessage(await this.text);
      } else {
        console.warn("You must set `window.Turbo = Turbo` to automatically process Turbo Stream events with request.js");
      }
    } else {
      return Promise.reject(new Error(`Expected a Turbo Stream response but got "${this.contentType}" instead`));
    }
  }
  async activeScript() {
    if (this.isScript) {
      const script = document.createElement("script");
      const metaTag = document.querySelector("meta[name=csp-nonce]");
      if (metaTag) {
        const nonce = metaTag.nonce === "" ? metaTag.content : metaTag.nonce;
        if (nonce) {
          script.setAttribute("nonce", nonce);
        }
      }
      script.innerHTML = await this.text;
      document.body.appendChild(script);
    } else {
      return Promise.reject(new Error(`Expected a Script response but got "${this.contentType}" instead`));
    }
  }
}

// node_modules/@rails/request.js/src/request_interceptor.js
class RequestInterceptor {
  static register(interceptor) {
    this.interceptor = interceptor;
  }
  static get() {
    return this.interceptor;
  }
  static reset() {
    this.interceptor = undefined;
  }
}

// node_modules/@rails/request.js/src/lib/utils.js
function getCookie(name) {
  const cookies = document.cookie ? document.cookie.split("; ") : [];
  const prefix = `${encodeURIComponent(name)}=`;
  const cookie = cookies.find((cookie2) => cookie2.startsWith(prefix));
  if (cookie) {
    const value = cookie.split("=").slice(1).join("=");
    if (value) {
      return decodeURIComponent(value);
    }
  }
}
function compact(object) {
  const result = {};
  for (const key in object) {
    const value = object[key];
    if (value !== undefined) {
      result[key] = value;
    }
  }
  return result;
}
function metaContent(name) {
  const element = document.head.querySelector(`meta[name="${name}"]`);
  return element && element.content;
}
function stringEntriesFromFormData(formData) {
  return [...formData].reduce((entries, [name, value]) => {
    return entries.concat(typeof value === "string" ? [[name, value]] : []);
  }, []);
}
function mergeEntries(searchParams, entries) {
  for (const [name, value] of entries) {
    if (value instanceof window.File)
      continue;
    if (searchParams.has(name) && !name.includes("[]")) {
      searchParams.delete(name);
      searchParams.set(name, value);
    } else {
      searchParams.append(name, value);
    }
  }
}

// node_modules/@rails/request.js/src/fetch_request.js
class FetchRequest2 {
  constructor(method, url, options = {}) {
    this.method = method;
    this.options = options;
    this.originalUrl = url.toString();
  }
  async perform() {
    try {
      const requestInterceptor = RequestInterceptor.get();
      if (requestInterceptor) {
        await requestInterceptor(this);
      }
    } catch (error2) {
      console.error(error2);
    }
    const fetch3 = this.responseKind === "turbo-stream" && window.Turbo ? window.Turbo.fetch : window.fetch;
    const response = new FetchResponse2(await fetch3(this.url, this.fetchOptions));
    if (response.unauthenticated && response.authenticationURL) {
      return Promise.reject(window.location.href = response.authenticationURL);
    }
    if (response.isScript) {
      await response.activeScript();
    }
    const responseStatusIsTurboStreamable = response.ok || response.unprocessableEntity;
    if (responseStatusIsTurboStreamable && response.isTurboStream) {
      await response.renderTurboStream();
    }
    return response;
  }
  addHeader(key, value) {
    const headers = this.additionalHeaders;
    headers[key] = value;
    this.options.headers = headers;
  }
  sameHostname() {
    if (!this.originalUrl.startsWith("http:") && !this.originalUrl.startsWith("https:")) {
      return true;
    }
    try {
      return new URL(this.originalUrl).hostname === window.location.hostname;
    } catch (_) {
      return true;
    }
  }
  get fetchOptions() {
    return {
      method: this.method.toUpperCase(),
      headers: this.headers,
      body: this.formattedBody,
      signal: this.signal,
      credentials: this.credentials,
      redirect: this.redirect,
      keepalive: this.keepalive
    };
  }
  get headers() {
    const baseHeaders = {
      "X-Requested-With": "XMLHttpRequest",
      "Content-Type": this.contentType,
      Accept: this.accept
    };
    if (this.sameHostname()) {
      baseHeaders["X-CSRF-Token"] = this.csrfToken;
    }
    return compact(Object.assign(baseHeaders, this.additionalHeaders));
  }
  get csrfToken() {
    return getCookie(metaContent("csrf-param")) || metaContent("csrf-token");
  }
  get contentType() {
    if (this.options.contentType) {
      return this.options.contentType;
    } else if (this.body == null || this.body instanceof window.FormData) {
      return;
    } else if (this.body instanceof window.File) {
      return this.body.type;
    }
    return "application/json";
  }
  get accept() {
    switch (this.responseKind) {
      case "html":
        return "text/html, application/xhtml+xml";
      case "turbo-stream":
        return "text/vnd.turbo-stream.html, text/html, application/xhtml+xml";
      case "json":
        return "application/json, application/vnd.api+json";
      case "script":
        return "text/javascript, application/javascript";
      default:
        return "*/*";
    }
  }
  get body() {
    return this.options.body;
  }
  get query() {
    const originalQuery = (this.originalUrl.split("?")[1] || "").split("#")[0];
    const params = new URLSearchParams(originalQuery);
    let requestQuery = this.options.query;
    if (requestQuery instanceof window.FormData) {
      requestQuery = stringEntriesFromFormData(requestQuery);
    } else if (requestQuery instanceof window.URLSearchParams) {
      requestQuery = requestQuery.entries();
    } else {
      requestQuery = Object.entries(requestQuery || {});
    }
    mergeEntries(params, requestQuery);
    const query = params.toString();
    return query.length > 0 ? `?${query}` : "";
  }
  get url() {
    return this.originalUrl.split("?")[0].split("#")[0] + this.query;
  }
  get responseKind() {
    return this.options.responseKind || "html";
  }
  get signal() {
    return this.options.signal;
  }
  get redirect() {
    return this.options.redirect || "follow";
  }
  get credentials() {
    return this.options.credentials || "same-origin";
  }
  get keepalive() {
    return this.options.keepalive || false;
  }
  get additionalHeaders() {
    return this.options.headers || {};
  }
  get formattedBody() {
    const bodyIsAString = Object.prototype.toString.call(this.body) === "[object String]";
    const contentTypeIsJson = this.headers["Content-Type"] === "application/json";
    if (contentTypeIsJson && !bodyIsAString) {
      return JSON.stringify(this.body);
    }
    return this.body;
  }
}

// node_modules/@rails/request.js/src/verbs.js
async function get(url, options) {
  const request = new FetchRequest2("get", url, options);
  return request.perform();
}
async function put(url, options) {
  const request = new FetchRequest2("put", url, options);
  return request.perform();
}
async function patch(url, options) {
  const request = new FetchRequest2("patch", url, options);
  return request.perform();
}

// node_modules/moment/dist/moment.js
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === undefined;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0;i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend3(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format, locale, strict) {
  return createLocalOrUTC(input, format, locale, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t = Object(this), len = t.length >>> 0, i;
    for (i = 0;i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m) {
  var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m);
    parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m)) {
    m._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend3(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [];
var updateInProgress = false;
function copyConfig(to, from) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from._isAMomentObject)) {
    to._isAMomentObject = from._isAMomentObject;
  }
  if (!isUndefined(from._i)) {
    to._i = from._i;
  }
  if (!isUndefined(from._f)) {
    to._f = from._f;
  }
  if (!isUndefined(from._l)) {
    to._l = from._l;
  }
  if (!isUndefined(from._strict)) {
    to._strict = from._strict;
  }
  if (!isUndefined(from._tzm)) {
    to._tzm = from._tzm;
  }
  if (!isUndefined(from._isUTC)) {
    to._isUTC = from._isUTC;
  }
  if (!isUndefined(from._offset)) {
    to._offset = from._offset;
  }
  if (!isUndefined(from._pf)) {
    to._pf = getParsingFlags(from);
  }
  if (!isUndefined(from._locale)) {
    to._locale = from._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0;i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from[prop];
      if (!isUndefined(val)) {
        to[prop] = val;
      }
    }
  }
  return to;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend3(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0;i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += `
[` + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(msg + `
Arguments: ` + Array.prototype.slice.call(args).join("") + `
` + new Error().stack);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config2) {
  var prop, i;
  for (i in config2) {
    if (hasOwnProp(config2, i)) {
      prop = config2[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend3({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend3(res[prop], parentConfig[prop]);
        extend3(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend3({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
  return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken(token, padded, ordinal, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token) {
    formatTokenFunctions[token] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal) {
    formatTokenFunctions[ordinal] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format) {
  var array = format.match(formattingTokens), i, length;
  for (i = 0, length = array.length;i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0;i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format = expandFormat(format, m.localeData());
  formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
  return formatFunctions[format](m);
}
function expandFormat(format, locale) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format)) {
    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format || !formatUpper) {
    return format;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d";
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff, output) {
  var format = this._relativeTime[diff > 0 ? "future" : "past"];
  return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}
var aliases = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match6 = /[+-]?\d{6}/;
var match1to2 = /\d\d?/;
var match3to4 = /\d\d\d\d?/;
var match5to6 = /\d\d\d\d\d\d?/;
var match1to3 = /\d{1,3}/;
var match1to4 = /\d{1,4}/;
var match1to6 = /[+-]?\d{1,6}/;
var matchUnsigned = /\d+/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var match1to2NoLeadingZero = /^[1-9]\d?/;
var match1to2HasZero = /^([1-9]\d|\d)/;
var regexes;
regexes = {};
function addRegexToken(token, regex, strictRegex) {
  regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token, config2) {
  if (!hasOwnProp(regexes, token)) {
    return new RegExp(unescapeFormat(token));
  }
  return regexes[token](config2._strict, config2._locale);
}
function unescapeFormat(s) {
  return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
    return p1 || p2 || p3 || p4;
  }));
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
var tokens = {};
function addParseToken(token, callback) {
  var i, func = callback, tokenLen;
  if (typeof token === "string") {
    token = [token];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token.length;
  for (i = 0;i < tokenLen; i++) {
    tokens[token[i]] = func;
  }
}
function addWeekParseToken(token, callback) {
  addParseToken(token, function(input, array, config2, token2) {
    config2._w = config2._w || {};
    callback(input, config2._w, config2, token2);
  });
}
function addTimeToArrayFromToken(token, input, config2) {
  if (input != null && hasOwnProp(tokens, token)) {
    tokens[token](input, config2._a, config2, token);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get2(this, unit);
    }
  };
}
function get2(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var { _d: d, _isUTC: isUTC } = mom;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
  isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date);
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0;i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n, x) {
  return (n % x + x) % x;
}
var indexOf2;
if (Array.prototype.indexOf) {
  indexOf2 = Array.prototype.indexOf;
} else {
  indexOf2 = function(o) {
    var i;
    for (i = 0;i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format) {
  return this.localeData().monthsShort(this, format);
});
addFormatToken("MMMM", 0, 0, function(format) {
  return this.localeData().months(this, format);
});
addRegexToken("M", match1to2, match1to2NoLeadingZero);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale) {
  return locale.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale) {
  return locale.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config2, token) {
  var month = config2._locale.monthsParse(input, token, config2._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultMonthsShortRegex = matchWord;
var defaultMonthsRegex = matchWord;
function localeMonths(m, format) {
  if (!m) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0;i < 12; ++i) {
      mom = createUTC([2000, i]);
      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format === "MMM") {
      ii = indexOf2.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format === "MMM") {
      ii = indexOf2.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0;i < 12; i++) {
    mom = createUTC([2000, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
  mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get2(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0;i < 12; i++) {
    mom = createUTC([2000, i]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}
function createDate(y, m, d, h, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addRegexToken("w", match1to2, match1to2NoLeadingZero);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2, match1to2NoLeadingZero);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config2, token) {
  week[token.substr(0, 1)] = toInt(input);
});
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format) {
  return this.localeData().weekdaysMin(this, format);
});
addFormatToken("ddd", 0, 0, function(format) {
  return this.localeData().weekdaysShort(this, format);
});
addFormatToken("dddd", 0, 0, function(format) {
  return this.localeData().weekdays(this, format);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale) {
  return locale.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale) {
  return locale.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale) {
  return locale.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token) {
  var weekday = config2._locale.weekdaysParse(input, token, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config2, token) {
  week[token] = toInt(input);
});
function parseWeekday(input, locale) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale) {
  if (typeof input === "string") {
    return locale.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
var defaultWeekdaysRegex = matchWord;
var defaultWeekdaysShortRegex = matchWord;
var defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0;i < 7; ++i) {
      mom = createUTC([2000, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format === "dddd") {
      ii = indexOf2.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format === "ddd") {
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format === "dddd") {
      ii = indexOf2.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format === "ddd") {
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf2.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf2.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0;i < 7; i++) {
    mom = createUTC([2000, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get2(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0;i < 7; i++) {
    mom = createUTC([2000, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token, lowercase) {
  addFormatToken(token, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
meridiem("a", true);
meridiem("A", false);
function matchMeridiem(isStrict, locale) {
  return locale._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2, match1to2HasZero);
addRegexToken("h", match1to2, match1to2NoLeadingZero);
addRegexToken("k", match1to2, match1to2NoLeadingZero);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config2) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config2) {
  config2._isPm = config2._locale.isPM(input);
  config2._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config2) {
  array[HOUR] = toInt(input);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input, array, config2) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input, array, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input, array, config2) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
var getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours, minutes, isLower) {
  if (hours > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {};
var localeFamilies = {};
var globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0;i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale, split;
  while (i < names.length) {
    split = normalizeLocale(names[i]).split("-");
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale = loadLocale(split.slice(0, j).join("-"));
      if (locale) {
        return locale;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === undefined && typeof module_moment !== "undefined" && module_moment && exports_moment && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("Locale " + key + " not found. Did you forget to load it?");
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config2) {
  if (config2 !== null) {
    var locale, parentConfig = baseConfig;
    config2.abbr = name;
    if (locales[name] != null) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale = loadLocale(config2.parentLocale);
        if (locale != null) {
          parentConfig = locale._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config2) {
  if (config2 != null) {
    var locale, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config2));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name;
      }
      locale = new Locale(config2);
      locale.parentLocale = locales[name];
      locales[name] = locale;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale = loadLocale(key);
    if (locale) {
      return locale;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
];
var isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
var obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i, l, string = config2._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config2).iso = true;
    for (i = 0, l = isoDatesLen;i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen;i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2000 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC2822(config2) {
  var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
    if (!checkWeekday(match[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match[8], match[9], match[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " + "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config2) {
  config2._d = new Date(config2._i + (config2._useUTC ? " UTC" : ""));
});
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date.getUTCMonth();
    config2._a[DATE] = date.getUTCDate();
  }
  for (i = 0;i < 3 && config2._a[i] == null; ++i) {
    config2._a[i] = input[i] = currentDate[i];
  }
  for (;i < 7; i++) {
    config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config2._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(w.GG, config2._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config2._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {};
hooks.RFC_2822 = function() {};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string = "" + config2._i, i, parsedInput, tokens2, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0;i < tokenLen; i++) {
    token = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token, config2)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token);
      }
      addTimeToArrayFromToken(token, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config2).unusedInput.push(string);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = undefined;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(config2._locale, config2._a[HOUR], config2._meridiem);
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale.meridiemHour != null) {
    return locale.meridiemHour(hour, meridiem2);
  } else if (locale.isPM != null) {
    isPm = locale.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = new Date(NaN);
    return;
  }
  for (i = 0;i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend3(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === undefined ? i.date : i.day;
  config2._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
    return obj && parseInt(obj, 10);
  });
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = undefined;
  }
  return res;
}
function prepareConfig(config2) {
  var { _i: input, _f: format } = config2;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format === undefined && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config2._d = input;
  } else if (isArray(format)) {
    configFromStringAndArray(config2);
  } else if (format) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray(input)) {
    config2._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject(input)) {
    configFromObject(config2);
  } else if (isNumber(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format, locale, strict, isUTC) {
  var c = {};
  if (format === true || format === false) {
    strict = format;
    format = undefined;
  }
  if (locale === true || locale === false) {
    strict = locale;
    locale = undefined;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = undefined;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale;
  c._i = input;
  c._f = format;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format, locale, strict) {
  return createLocalOrUTC(input, format, locale, strict, false);
}
var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other < this ? this : other;
  } else {
    return createInvalid();
  }
});
var prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other > this ? this : other;
  } else {
    return createInvalid();
  }
});
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1;i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now2 = function() {
  return Date.now ? Date.now() : +new Date;
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf2.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0;i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds + seconds * 1000 + minutes * 60000 + hours * 1000 * 60 * 60;
  this._days = +days + weeks * 7;
  this._months = +months + quarters * 3 + years * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0;i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token, separator) {
  addFormatToken(token, 0, 0, function() {
    var offset2 = this.utcOffset(), sign = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign = "-";
    }
    return sign + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes = +(parts[1] * 60) + toInt(parts[2]);
  return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
}
function cloneWithOffset(input, model) {
  var res, diff;
  if (model._isUTC) {
    res = model.clone();
    diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match = null, sign, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign,
      h: toInt(match[HOUR]) * sign,
      m: toInt(match[MINUTE]) * sign,
      s: toInt(match[SECOND]) * sign,
      ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign
    };
  } else if (match = isoRegex.exec(input)) {
    sign = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign),
      M: parseIso(match[3], sign),
      w: parseIso(match[4], sign),
      d: parseIso(match[5], sign),
      h: parseIso(match[6], sign),
      m: parseIso(match[7], sign),
      s: parseIso(match[8], sign)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && (("from" in duration) || ("to" in duration))) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months) {
    setMonth(mom, get2(mom, "Month") + months * isAdding);
  }
  if (days) {
    set$1(mom, "Date", get2(mom, "Date") + days * isAdding);
  }
  if (milliseconds) {
    mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days || months);
  }
}
var add2 = createAdder(1, "add");
var subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0;i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0;i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now3) {
  var diff = myMoment.diff(now3, "days", true);
  return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = undefined;
      formats = undefined;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = undefined;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = undefined;
    }
  }
  var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now3) : formats[format]);
  return this.format(output || this.localeData().calendar(format, this, createLocal(now3)));
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from, to, units, inclusivity) {
  var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 60000;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1000;
      break;
    case "minute":
      output = (this - that) / 60000;
      break;
    case "hour":
      output = (this - that) / 3600000;
      break;
    case "day":
      output = (this - that - zoneDelta) / 86400000;
      break;
    case "week":
      output = (this - that - zoneDelta) / 604800000;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === undefined) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
  if (key === undefined) {
    return this.localeData();
  } else {
    return this.locale(key);
  }
});
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1000;
var MS_PER_MINUTE = 60 * MS_PER_SECOND;
var MS_PER_HOUR = 60 * MS_PER_MINUTE;
var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === undefined || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === undefined || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 60000;
}
function unix() {
  return Math.floor(this.valueOf() / 1000);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray2() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend3({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config2, token) {
  var era = config2._locale.erasParse(input, token, config2._strict);
  if (era) {
    getParsingFlags(config2).era = era;
  } else {
    getParsingFlags(config2).invalidEra = input;
  }
});
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config2, token) {
  var match;
  if (config2._locale._eraYearOrdinalRegex) {
    match = input.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array[YEAR] = config2._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m, format2) {
  var i, l, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length;i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length;i < l; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === undefined) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length;i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length;i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length;i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length;i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l = eras.length;i < l; ++i) {
    erasName = regexEscape(eras[i].name);
    erasAbbr = regexEscape(eras[i].abbr);
    erasNarrow = regexEscape(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token, getter) {
  addFormatToken(0, [token, token.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config2, token) {
  week[token.substr(0, 2)] = toInt(input);
});
addWeekParseToken(["gg", "GG"], function(input, week, config2, token) {
  week[token] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addRegexToken("D", match1to2, match1to2NoLeadingZero);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config2) {
  config2._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 86400000) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addRegexToken("m", match1to2, match1to2HasZero);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addRegexToken("s", match1to2, match1to2HasZero);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1000;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token;
var getSetMillisecond;
for (token = "SSSS";token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1000);
}
for (token = "S";token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add2;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray2;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
function createUnix(input) {
  return createLocal(input * 1000);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber(format2)) {
    index = format2;
    format2 = undefined;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1(format2, index, field, "month");
  }
  var i, out = [];
  for (i = 0;i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index = format2;
      format2 = undefined;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index = format2;
      format2 = undefined;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index != null) {
    return get$1(format2, (index + shift) % 7, field, "day");
  }
  for (i = 0;i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;
  if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
    milliseconds += absCeil(monthsToDays(months) + days) * 86400000;
    days = 0;
    months = 0;
  }
  data.milliseconds = milliseconds % 1000;
  seconds = absFloor(milliseconds / 1000);
  data.seconds = seconds % 60;
  minutes = absFloor(seconds / 60);
  data.minutes = minutes % 60;
  hours = absFloor(minutes / 60);
  data.hours = hours % 24;
  days += absFloor(hours / 24);
  monthsFromDays = absFloor(daysToMonths(days));
  months += monthsFromDays;
  days -= absCeil(monthsToDays(monthsFromDays));
  years = absFloor(months / 12);
  months %= 12;
  data.days = days;
  data.months = months;
  data.years = years;
  return this;
}
function daysToMonths(days) {
  return days * 4800 / 146097;
}
function monthsToDays(months) {
  return months * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days, months, milliseconds = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days = this._days + milliseconds / 86400000;
    months = this._months + daysToMonths(days);
    switch (units) {
      case "month":
        return months;
      case "quarter":
        return months / 3;
      case "year":
        return months / 12;
    }
  } else {
    days = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days / 7 + milliseconds / 604800000;
      case "day":
        return days + milliseconds / 86400000;
      case "hour":
        return days * 24 + milliseconds / 3600000;
      case "minute":
        return days * 1440 + milliseconds / 60000;
      case "second":
        return days * 86400 + milliseconds / 1000;
      case "millisecond":
        return Math.floor(days * 86400000) + milliseconds;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms");
var asSeconds = makeAs("s");
var asMinutes = makeAs("m");
var asHours = makeAs("h");
var asDays = makeAs("d");
var asWeeks = makeAs("w");
var asMonths = makeAs("M");
var asQuarters = makeAs("Q");
var asYears = makeAs("y");
var valueOf$1 = asMilliseconds;
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds");
var seconds = makeGetter("seconds");
var minutes = makeGetter("minutes");
var hours = makeGetter("hours");
var days = makeGetter("days");
var months = makeGetter("months");
var years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round;
var thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === undefined) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === undefined) {
    return false;
  }
  if (limit === undefined) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1000, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config2) {
  config2._d = new Date(parseFloat(input) * 1000);
});
addParseToken("x", function(input, array, config2) {
  config2._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.30.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now2;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
var moment_default = hooks;

// app/javascript/controllers/audits_controller.js
var import_sweetalert2 = __toESM(require_sweetalert2_all(), 1);

class audits_controller_default extends Controller {
  static targets = ["container", "auditExpire"];
  editDateExpire(event) {
    var btnCanc, btnSave, container, editDiv, el, oldDate, target, control;
    target = event.target;
    container = target.parentNode;
    editDiv = document.createElement("DIV");
    editDiv.id = `${container.id}_editor`;
    editDiv.className = "editor field has-addons";
    container.appendChild(editDiv);
    oldDate = target.text;
    el = document.createElement("INPUT");
    el.type = "date";
    el.className = "input";
    el.value = moment_default(oldDate, "DD/MM/YYYY").format("YYYY-MM-DD");
    control = document.createElement("DIV");
    control.className = "control is-expanded";
    control.appendChild(el);
    editDiv.appendChild(control);
    btnSave = document.createElement("BUTTON");
    btnSave.innerHTML = "<i class='fa fa-save'></i>";
    btnSave.className = "button tooltip is-success";
    btnSave.dataset.tooltip = "Salva";
    btnSave.dataset.controller = "audits";
    btnSave.dataset.action = "click->audits#updateDateExpire";
    btnSave.dataset.userId = target.dataset.userId;
    control = document.createElement("DIV");
    control.className = "control py-0";
    control.appendChild(btnSave);
    editDiv.appendChild(control);
    btnCanc = document.createElement("BUTTON");
    btnCanc.innerHTML = "<i class='fa fa-times'></i>";
    btnCanc.className = "button tooltip is-danger my-0";
    btnCanc.dataset.tooltip = "Annulla";
    btnCanc.dataset.controller = "audits";
    btnCanc.dataset.action = "click->audits#abortDateExpire";
    control = document.createElement("DIV");
    control.className = "control";
    control.appendChild(btnCanc);
    editDiv.appendChild(control);
    return target.classList.add("is-hidden");
  }
  async updateDateExpire(event) {
    const target = event.currentTarget;
    const editor = target.closest(".editor");
    const container = editor.parentNode;
    const inputDate = container.querySelector("input[type=date]");
    const newDate = inputDate.value;
    const link = container.querySelector("a.expire_date");
    const url = link.dataset.auditsUrl;
    const user_id = target.dataset.userId;
    if (newDate !== "") {
      try {
        await patch(url, {
          body: JSON.stringify({ audit: { expire: newDate } })
        });
        this.send("Salvataggio avvenuto correttamente!");
        this.removeElement(target);
        link.text = moment_default(newDate).format("DD/MM/YYYY");
        if (user_id) {
          let userContainer = document.getElementById(`user_${user_id}`);
          const response = await get(`/utenti/${user_id}/utente`);
          if (userContainer) {
            userContainer.outerHTML = await response.text;
          }
        }
        let td = document.getElementById(`td_audit_${user_id}`);
        if (container) {
          if (moment_default().diff(moment_default(newDate), "days") >= 1) {
            container.classList.add("expired");
            container.classList.remove("active");
            link.closest("td").classList.add("expired");
          } else {
            container.classList.add("active");
            container.classList.remove("expired");
            link.closest("td").classList.remove("expired");
          }
        }
      } catch (error2) {
        this.send("Si  verificato un errore durante il salvataggio della data!", "error");
      }
    }
  }
  abortDateExpire(event) {
    var target;
    target = event.currentTarget;
    return this.removeElement(target);
  }
  removeElement(target) {
    var container, editor, link;
    editor = target.closest(".editor");
    container = editor.parentNode;
    editor.remove();
    link = container.querySelector("a.is-hidden");
    if (link) {
      return link.classList.remove("is-hidden");
    }
  }
  async manageAudit(event) {
    const target = event.currentTarget;
    const url = target.dataset.auditsUrl;
    const method = target.dataset.auditsMethod;
    const user_id = target.dataset.userId;
    try {
      const request = new FetchRequest2(method, url);
      const response = await request.perform();
      if (!response.ok) {
        throw new Error("Errore nella richiesta");
      }
      target.closest(".columns").outerHTML = await response.text;
      if (user_id) {
        const element = document.getElementById(`user_${user_id}`);
        const userRequest = new FetchRequest2("GET", `/utenti/${user_id}/utente`);
        const userResponse = await userRequest.perform();
        if (element) {
          element.outerHTML = await userResponse.text;
        }
      }
      this.send("Salvataggio avvenuto correttamente!");
    } catch (error2) {
      this.send("Si  verificato un errore durante il salvataggio!", "error");
    }
  }
  send(message, level = "success", force = false, timeout = 2000, toast = true) {
    var options;
    options = {
      toast: level === "error" ? false : toast,
      icon: level,
      timerProgressBar: true,
      position: level === "error" ? "center" : "top-end",
      text: message,
      timer: level === "error" ? false : timeout,
      showConfirmButton: level === "error" ? true : false,
      didOpen: (toast2) => {
        toast2.addEventListener("mouseenter", import_sweetalert2.default.stopTimer);
        return toast2.addEventListener("mouseleave", import_sweetalert2.default.resumeTimer);
      },
      showClass: {
        popup: level === "error" ? "" : "animate__animated animate__bounceInRight"
      },
      hideClass: {
        popup: level === "error" ? "" : "animate__animated animate__bounceOutRight"
      }
    };
    if (import_sweetalert2.default.isVisible() && force == "true") {
      import_sweetalert2.default.fire(options);
    } else if (!import_sweetalert2.default.isVisible()) {
      import_sweetalert2.default.fire(options);
    }
  }
}

// app/javascript/controllers/book_controller.js
class book_controller_default extends Controller {
  focus(event) {
    var target;
    if (event.currentTarget.dataset.bookId) {
      target = document.getElementById(event.currentTarget.dataset.bookId);
      if (target) {
        return target.scrollIntoView();
      }
    }
  }
}

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function v(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function y(l2, u2, i2) {
  var t2, r2, o2, f2 = {};
  for (o2 in u2)
    o2 == "key" ? t2 = u2[o2] : o2 == "ref" ? r2 = u2[o2] : f2[o2] = u2[o2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : i2), typeof l2 == "function" && l2.defaultProps != null)
    for (o2 in l2.defaultProps)
      f2[o2] === undefined && (f2[o2] = l2.defaultProps[o2]);
  return p(l2, f2, t2, r2, null);
}
function p(n2, i2, t2, r2, o2) {
  var f2 = { type: n2, props: i2, key: t2, ref: r2, __k: null, __: null, __b: 0, __e: null, __d: undefined, __c: null, __h: null, constructor: undefined, __v: o2 == null ? ++u : o2 };
  return o2 == null && l.vnode != null && l.vnode(f2), f2;
}
function d() {
  return { current: null };
}
function _(n2) {
  return n2.children;
}
function k(n2, l2, u2, i2, t2) {
  var r2;
  for (r2 in u2)
    r2 === "children" || r2 === "key" || r2 in l2 || g(n2, r2, null, u2[r2], i2);
  for (r2 in l2)
    t2 && typeof l2[r2] != "function" || r2 === "children" || r2 === "key" || r2 === "value" || r2 === "checked" || u2[r2] === l2[r2] || g(n2, r2, l2[r2], u2[r2], i2);
}
function b(n2, l2, u2) {
  l2[0] === "-" ? n2.setProperty(l2, u2 == null ? "" : u2) : n2[l2] = u2 == null ? "" : typeof u2 != "number" || a.test(l2) ? u2 : u2 + "px";
}
function g(n2, l2, u2, i2, t2) {
  var r2;
  n:
    if (l2 === "style")
      if (typeof u2 == "string")
        n2.style.cssText = u2;
      else {
        if (typeof i2 == "string" && (n2.style.cssText = i2 = ""), i2)
          for (l2 in i2)
            u2 && l2 in u2 || b(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            i2 && u2[l2] === i2[l2] || b(n2.style, l2, u2[l2]);
      }
    else if (l2[0] === "o" && l2[1] === "n")
      r2 = l2 !== (l2 = l2.replace(/Capture$/, "")), l2 = l2.toLowerCase() in n2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + r2] = u2, u2 ? i2 || n2.addEventListener(l2, r2 ? w : m, r2) : n2.removeEventListener(l2, r2 ? w : m, r2);
    else if (l2 !== "dangerouslySetInnerHTML") {
      if (t2)
        l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (l2 !== "width" && l2 !== "height" && l2 !== "href" && l2 !== "list" && l2 !== "form" && l2 !== "tabIndex" && l2 !== "download" && l2 in n2)
        try {
          n2[l2] = u2 == null ? "" : u2;
          break n;
        } catch (n3) {}
      typeof u2 == "function" || (u2 == null || u2 === false && l2.indexOf("-") == -1 ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
    }
}
function m(n2) {
  t = true;
  try {
    return this.l[n2.type + false](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function w(n2) {
  t = true;
  try {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function x(n2, l2) {
  this.props = n2, this.context = l2;
}
function A(n2, l2) {
  if (l2 == null)
    return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2;l2 < n2.__k.length; l2++)
    if ((u2 = n2.__k[l2]) != null && u2.__e != null)
      return u2.__e;
  return typeof n2.type == "function" ? A(n2) : null;
}
function P(n2) {
  var l2, u2;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l2 = 0;l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return P(n2);
  }
}
function C(n2) {
  t ? setTimeout(n2) : f(n2);
}
function T(n2) {
  (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
}
function $() {
  var n2, l2, u2, i2, t2, o2, f2, e2;
  for (r.sort(function(n3, l3) {
    return n3.__v.__b - l3.__v.__b;
  });n2 = r.shift(); )
    n2.__d && (l2 = r.length, i2 = undefined, t2 = undefined, f2 = (o2 = (u2 = n2).__v).__e, (e2 = u2.__P) && (i2 = [], (t2 = h({}, o2)).__v = o2.__v + 1, M(e2, o2, t2, u2.__n, e2.ownerSVGElement !== undefined, o2.__h != null ? [f2] : null, i2, f2 == null ? A(o2) : f2, o2.__h), N(i2, o2), o2.__e != f2 && P(o2)), r.length > l2 && r.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }));
  $.__r = 0;
}
function H(n2, l2, u2, i2, t2, r2, o2, f2, e2, a2) {
  var h2, v2, y2, d2, k2, b2, g2, m2 = i2 && i2.__k || s, w2 = m2.length;
  for (u2.__k = [], h2 = 0;h2 < l2.length; h2++)
    if ((d2 = u2.__k[h2] = (d2 = l2[h2]) == null || typeof d2 == "boolean" ? null : typeof d2 == "string" || typeof d2 == "number" || typeof d2 == "bigint" ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2) != null) {
      if (d2.__ = u2, d2.__b = u2.__b + 1, (y2 = m2[h2]) === null || y2 && d2.key == y2.key && d2.type === y2.type)
        m2[h2] = undefined;
      else
        for (v2 = 0;v2 < w2; v2++) {
          if ((y2 = m2[v2]) && d2.key == y2.key && d2.type === y2.type) {
            m2[v2] = undefined;
            break;
          }
          y2 = null;
        }
      M(n2, d2, y2 = y2 || c, t2, r2, o2, f2, e2, a2), k2 = d2.__e, (v2 = d2.ref) && y2.ref != v2 && (g2 || (g2 = []), y2.ref && g2.push(y2.ref, null, d2), g2.push(v2, d2.__c || k2, d2)), k2 != null ? (b2 == null && (b2 = k2), typeof d2.type == "function" && d2.__k === y2.__k ? d2.__d = e2 = I(d2, e2, n2) : e2 = z(n2, d2, y2, m2, k2, e2), typeof u2.type == "function" && (u2.__d = e2)) : e2 && y2.__e == e2 && e2.parentNode != n2 && (e2 = A(y2));
    }
  for (u2.__e = b2, h2 = w2;h2--; )
    m2[h2] != null && (typeof u2.type == "function" && m2[h2].__e != null && m2[h2].__e == u2.__d && (u2.__d = L(i2).nextSibling), q(m2[h2], m2[h2]));
  if (g2)
    for (h2 = 0;h2 < g2.length; h2++)
      S(g2[h2], g2[++h2], g2[++h2]);
}
function I(n2, l2, u2) {
  for (var i2, t2 = n2.__k, r2 = 0;t2 && r2 < t2.length; r2++)
    (i2 = t2[r2]) && (i2.__ = n2, l2 = typeof i2.type == "function" ? I(i2, l2, u2) : z(u2, i2, i2, t2, i2.__e, l2));
  return l2;
}
function j(n2, l2) {
  return l2 = l2 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    j(n3, l2);
  }) : l2.push(n2)), l2;
}
function z(n2, l2, u2, i2, t2, r2) {
  var o2, f2, e2;
  if (l2.__d !== undefined)
    o2 = l2.__d, l2.__d = undefined;
  else if (u2 == null || t2 != r2 || t2.parentNode == null)
    n:
      if (r2 == null || r2.parentNode !== n2)
        n2.appendChild(t2), o2 = null;
      else {
        for (f2 = r2, e2 = 0;(f2 = f2.nextSibling) && e2 < i2.length; e2 += 1)
          if (f2 == t2)
            break n;
        n2.insertBefore(t2, r2), o2 = r2;
      }
  return o2 !== undefined ? o2 : t2.nextSibling;
}
function L(n2) {
  var l2, u2, i2;
  if (n2.type == null || typeof n2.type == "string")
    return n2.__e;
  if (n2.__k) {
    for (l2 = n2.__k.length - 1;l2 >= 0; l2--)
      if ((u2 = n2.__k[l2]) && (i2 = L(u2)))
        return i2;
  }
  return null;
}
function M(n2, u2, i2, t2, r2, o2, f2, e2, c2) {
  var s2, a2, v2, y2, p2, d2, k2, b2, g2, m2, w2, A2, P2, C2, T2, $2 = u2.type;
  if (u2.constructor !== undefined)
    return null;
  i2.__h != null && (c2 = i2.__h, e2 = u2.__e = i2.__e, u2.__h = null, o2 = [e2]), (s2 = l.__b) && s2(u2);
  try {
    n:
      if (typeof $2 == "function") {
        if (b2 = u2.props, g2 = (s2 = $2.contextType) && t2[s2.__c], m2 = s2 ? g2 ? g2.props.value : s2.__ : t2, i2.__c ? k2 = (a2 = u2.__c = i2.__c).__ = a2.__E : (("prototype" in $2) && $2.prototype.render ? u2.__c = a2 = new $2(b2, m2) : (u2.__c = a2 = new x(b2, m2), a2.constructor = $2, a2.render = B), g2 && g2.sub(a2), a2.props = b2, a2.state || (a2.state = {}), a2.context = m2, a2.__n = t2, v2 = a2.__d = true, a2.__h = [], a2._sb = []), a2.__s == null && (a2.__s = a2.state), $2.getDerivedStateFromProps != null && (a2.__s == a2.state && (a2.__s = h({}, a2.__s)), h(a2.__s, $2.getDerivedStateFromProps(b2, a2.__s))), y2 = a2.props, p2 = a2.state, a2.__v = u2, v2)
          $2.getDerivedStateFromProps == null && a2.componentWillMount != null && a2.componentWillMount(), a2.componentDidMount != null && a2.__h.push(a2.componentDidMount);
        else {
          if ($2.getDerivedStateFromProps == null && b2 !== y2 && a2.componentWillReceiveProps != null && a2.componentWillReceiveProps(b2, m2), !a2.__e && a2.shouldComponentUpdate != null && a2.shouldComponentUpdate(b2, a2.__s, m2) === false || u2.__v === i2.__v) {
            for (u2.__v !== i2.__v && (a2.props = b2, a2.state = a2.__s, a2.__d = false), u2.__e = i2.__e, u2.__k = i2.__k, u2.__k.forEach(function(n3) {
              n3 && (n3.__ = u2);
            }), w2 = 0;w2 < a2._sb.length; w2++)
              a2.__h.push(a2._sb[w2]);
            a2._sb = [], a2.__h.length && f2.push(a2);
            break n;
          }
          a2.componentWillUpdate != null && a2.componentWillUpdate(b2, a2.__s, m2), a2.componentDidUpdate != null && a2.__h.push(function() {
            a2.componentDidUpdate(y2, p2, d2);
          });
        }
        if (a2.context = m2, a2.props = b2, a2.__P = n2, A2 = l.__r, P2 = 0, "prototype" in $2 && $2.prototype.render) {
          for (a2.state = a2.__s, a2.__d = false, A2 && A2(u2), s2 = a2.render(a2.props, a2.state, a2.context), C2 = 0;C2 < a2._sb.length; C2++)
            a2.__h.push(a2._sb[C2]);
          a2._sb = [];
        } else
          do {
            a2.__d = false, A2 && A2(u2), s2 = a2.render(a2.props, a2.state, a2.context), a2.state = a2.__s;
          } while (a2.__d && ++P2 < 25);
        a2.state = a2.__s, a2.getChildContext != null && (t2 = h(h({}, t2), a2.getChildContext())), v2 || a2.getSnapshotBeforeUpdate == null || (d2 = a2.getSnapshotBeforeUpdate(y2, p2)), T2 = s2 != null && s2.type === _ && s2.key == null ? s2.props.children : s2, H(n2, Array.isArray(T2) ? T2 : [T2], u2, i2, t2, r2, o2, f2, e2, c2), a2.base = u2.__e, u2.__h = null, a2.__h.length && f2.push(a2), k2 && (a2.__E = a2.__ = null), a2.__e = false;
      } else
        o2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = O(i2.__e, u2, i2, t2, r2, o2, f2, c2);
    (s2 = l.diffed) && s2(u2);
  } catch (n3) {
    u2.__v = null, (c2 || o2 != null) && (u2.__e = e2, u2.__h = !!c2, o2[o2.indexOf(e2)] = null), l.__e(n3, u2, i2);
  }
}
function N(n2, u2) {
  l.__c && l.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l.__e(n3, u3.__v);
    }
  });
}
function O(l2, u2, i2, t2, r2, o2, f2, e2) {
  var s2, a2, h2, y2 = i2.props, p2 = u2.props, d2 = u2.type, _2 = 0;
  if (d2 === "svg" && (r2 = true), o2 != null) {
    for (;_2 < o2.length; _2++)
      if ((s2 = o2[_2]) && "setAttribute" in s2 == !!d2 && (d2 ? s2.localName === d2 : s2.nodeType === 3)) {
        l2 = s2, o2[_2] = null;
        break;
      }
  }
  if (l2 == null) {
    if (d2 === null)
      return document.createTextNode(p2);
    l2 = r2 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p2.is && p2), o2 = null, e2 = false;
  }
  if (d2 === null)
    y2 === p2 || e2 && l2.data === p2 || (l2.data = p2);
  else {
    if (o2 = o2 && n.call(l2.childNodes), a2 = (y2 = i2.props || c).dangerouslySetInnerHTML, h2 = p2.dangerouslySetInnerHTML, !e2) {
      if (o2 != null)
        for (y2 = {}, _2 = 0;_2 < l2.attributes.length; _2++)
          y2[l2.attributes[_2].name] = l2.attributes[_2].value;
      (h2 || a2) && (h2 && (a2 && h2.__html == a2.__html || h2.__html === l2.innerHTML) || (l2.innerHTML = h2 && h2.__html || ""));
    }
    if (k(l2, p2, y2, r2, e2), h2)
      u2.__k = [];
    else if (_2 = u2.props.children, H(l2, Array.isArray(_2) ? _2 : [_2], u2, i2, t2, r2 && d2 !== "foreignObject", o2, f2, o2 ? o2[0] : i2.__k && A(i2, 0), e2), o2 != null)
      for (_2 = o2.length;_2--; )
        o2[_2] != null && v(o2[_2]);
    e2 || (("value" in p2) && (_2 = p2.value) !== undefined && (_2 !== l2.value || d2 === "progress" && !_2 || d2 === "option" && _2 !== y2.value) && g(l2, "value", _2, y2.value, false), ("checked" in p2) && (_2 = p2.checked) !== undefined && _2 !== l2.checked && g(l2, "checked", _2, y2.checked, false));
  }
  return l2;
}
function S(n2, u2, i2) {
  try {
    typeof n2 == "function" ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l.__e(n3, i2);
  }
}
function q(n2, u2, i2) {
  var t2, r2;
  if (l.unmount && l.unmount(n2), (t2 = n2.ref) && (t2.current && t2.current !== n2.__e || S(t2, null, u2)), (t2 = n2.__c) != null) {
    if (t2.componentWillUnmount)
      try {
        t2.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u2);
      }
    t2.base = t2.__P = null, n2.__c = undefined;
  }
  if (t2 = n2.__k)
    for (r2 = 0;r2 < t2.length; r2++)
      t2[r2] && q(t2[r2], u2, i2 || typeof n2.type != "function");
  i2 || n2.__e == null || v(n2.__e), n2.__ = n2.__e = n2.__d = undefined;
}
function B(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function D(u2, i2, t2) {
  var r2, o2, f2;
  l.__ && l.__(u2, i2), o2 = (r2 = typeof t2 == "function") ? null : t2 && t2.__k || i2.__k, f2 = [], M(i2, u2 = (!r2 && t2 || i2).__k = y(_, null, [u2]), o2 || c, c, i2.ownerSVGElement !== undefined, !r2 && t2 ? [t2] : o2 ? null : i2.firstChild ? n.call(i2.childNodes) : null, f2, !r2 && t2 ? t2 : o2 ? o2.__e : i2.firstChild, r2), N(f2, u2);
}
function G(n2, l2) {
  var u2 = { __c: l2 = "__cC" + e++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var u3, i2;
    return this.getChildContext || (u3 = [], (i2 = {})[l2] = this, this.getChildContext = function() {
      return i2;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u3.some(function(n5) {
        n5.__e = true, T(n5);
      });
    }, this.sub = function(n4) {
      u3.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Provider.__ = u2.Consumer.contextType = u2;
}
n = s.slice, l = { __e: function(n2, l2, u2, i2) {
  for (var t2, r2, o2;l2 = l2.__; )
    if ((t2 = l2.__c) && !t2.__)
      try {
        if ((r2 = t2.constructor) && r2.getDerivedStateFromError != null && (t2.setState(r2.getDerivedStateFromError(n2)), o2 = t2.__d), t2.componentDidCatch != null && (t2.componentDidCatch(n2, i2 || {}), o2 = t2.__d), o2)
          return t2.__E = t2;
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return n2 != null && n2.constructor === undefined;
}, t = false, x.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), typeof n2 == "function" && (n2 = n2(h({}, u2), this.props)), n2 && h(u2, n2), n2 != null && this.__v && (l2 && this._sb.push(l2), T(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
}, x.prototype.render = _, r = [], f = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;
// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function b2() {
  for (var t3;t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r3) {
        t3.__H.__h = [], l.__e(r3, t3.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = undefined;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o2 = t3.__c;
  o2 && o2.__H && (o2.__H.__h.length && (f2.push(o2) !== 1 && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = undefined, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = undefined, r3 && l.__e(r3, u3.__v));
};
var g2 = typeof requestAnimationFrame == "function";
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u3 = n2.__c;
  typeof u3 == "function" && (n2.__c = undefined, u3()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2)
    if (e3 !== "__source" && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if (r3 !== "__source" && n2[r3] !== t3[r3])
      return true;
  return false;
}
function w3(n2) {
  this.props = n2;
}
(w3.prototype = new x).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u3, o2 = t3;o2 = o2.__; )
      if ((u3 = o2.__c) && u3.__c)
        return t3.__e == null && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    typeof n3.__c == "function" && n3.__c();
  }), n2.__c.__H = null), (n2 = g3({}, n2)).__c != null && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && n2.__h === true && (n2.type = null), I2 && I2(n2);
}, (D2.prototype = new x).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  r3.t == null && (r3.t = []), r3.t.push(e3);
  var u3 = F3(r3.__v), o2 = false, i3 = function() {
    o2 || (o2 = true, e3.__R = null, u3 ? u3(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null });t4 = r3.t.pop(); )
        t4.forceUpdate();
    }
  }, c3 = t3.__h === true;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && y(_, null, n2.fallback);
  return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.o.size))
    for (e3 = n2.u;e3; ) {
      for (;e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.u = e3 = e3[2];
    }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = y($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new x).__a = function(n2) {
  var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u3) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
    };
    e3 ? e3(o2) : o2();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = new Map;
  var t3 = j(n2.children);
  n2.revealOrder && n2.revealOrder[0] === "b" && t3.reverse();
  for (var e3 = t3.length;e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z2 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = typeof document != "undefined";
var Z = function(n2) {
  return (typeof Symbol != "undefined" && typeof Symbol() == "symbol" ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G2 = l.event;
function J() {}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var { type: t3, props: e3 } = n2, u3 = e3;
  if (typeof t3 == "string") {
    var o2 = t3.indexOf("-") === -1;
    for (var i3 in u3 = {}, e3) {
      var l3 = e3[i3];
      H2 && i3 === "children" && t3 === "noscript" || i3 === "value" && "defaultValue" in e3 && l3 == null || (i3 === "defaultValue" && ("value" in e3) && e3.value == null ? i3 = "value" : i3 === "download" && l3 === true ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : l3 === null && (l3 = undefined), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
    }
    t3 == "select" && u3.multiple && Array.isArray(u3.value) && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u3.value.indexOf(n3.props.value) != -1;
    })), t3 == "select" && u3.defaultValue != null && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u3.multiple ? u3.defaultValue.indexOf(n3.props.value) != -1 : u3.defaultValue == n3.props.value;
    })), n2.props = u3, e3.class != e3.className && (nn.enumerable = ("className" in e3), e3.className != null && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
  }
  n2.$$typeof = z2, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = new Map;
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce = getNonceValue();
      if (nonce) {
        styleEl.nonce = nonce;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i3) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i3);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === undefined) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ":root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format(\"truetype\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\"\\e900\"}.fc-icon-chevron-right:before{content:\"\\e901\"}.fc-icon-chevrons-left:before{content:\"\\e902\"}.fc-icon-chevrons-right:before{content:\"\\e903\"}.fc-icon-minus-square:before{content:\"\\e904\"}.fc-icon-plus-square:before{content:\"\\e905\"}.fc-icon-x:before{content:\"\\e906\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\"\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\"\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\"\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}";
injectStyles(css_248z);

class DelayedRunner {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
}
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements2(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i3 = 0;i3 < containers.length; i3 += 1) {
    let matches = containers[i3].querySelectorAll(selector);
    for (let j4 = 0;j4 < matches.length; j4 += 1) {
      allMatches.push(matches[j4]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === undefined ? undefined : _a.call(ev)[0]) !== null && _b !== undefined ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback) {
  let realCallback = (ev) => {
    callback(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault);
}
function parseFieldSpecs(input) {
  let specs = [];
  let tokens2 = [];
  let i3;
  let token2;
  if (typeof input === "string") {
    tokens2 = input.split(/\s*,\s*/);
  } else if (typeof input === "function") {
    tokens2 = [input];
  } else if (Array.isArray(input)) {
    tokens2 = input;
  }
  for (i3 = 0;i3 < tokens2.length; i3 += 1) {
    token2 = tokens2[i3];
    if (typeof token2 === "string") {
      specs.push(token2.charAt(0) === "-" ? { field: token2.substring(1), order: -1 } : { field: token2, order: 1 });
    } else if (typeof token2 === "function") {
      specs.push({ func: token2 });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i3;
  let cmp;
  for (i3 = 0;i3 < fieldSpecs.length; i3 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a3, b3) {
  if (!a3 && !b3) {
    return 0;
  }
  if (b3 == null) {
    return -1;
  }
  if (a3 == null) {
    return 1;
  }
  if (typeof a3 === "string" || typeof b3 === "string") {
    return String(a3).localeCompare(String(b3));
  }
  return a3 - b3;
}
function padStart(val, len) {
  let s3 = String(val);
  return "000".substr(0, len - s3.length) + s3;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index) => str.replace("$" + index, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a3, b3) {
  return a3 - b3;
}
function isInt(n2) {
  return n2 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + contentWidthEl.getBoundingClientRect().width;
}
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration2(input, unit) {
  if (typeof input === "string") {
    return parseString(input);
  }
  if (typeof input === "object" && input) {
    return parseObject(input);
  }
  if (typeof input === "number") {
    return parseObject({ [unit || "milliseconds"]: input });
  }
  return null;
}
function parseString(s3) {
  let m3 = PARSE_RE.exec(s3);
  if (m3) {
    let sign2 = m3[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign2 * (m3[2] ? parseInt(m3[2], 10) : 0),
      milliseconds: sign2 * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1000 + (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1000 + (m3[5] ? parseInt(m3[5], 10) : 0) * 1000 + (m3[6] ? parseInt(m3[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + (obj.minutes || obj.minute || 0) * 60 * 1000 + (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0)
  };
  let weeks2 = obj.weeks || obj.week;
  if (weeks2) {
    duration.days += weeks2 * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 86400000;
}
function asRoughMs(dur) {
  return dur.years * (365 * 86400000) + dur.months * (30 * 86400000) + dur.days * 86400000 + dur.milliseconds;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1000 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1000 * 60) !== 0) {
      return { unit: "second", value: ms / 1000 };
    }
    if (ms % (1000 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1000 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1000 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i3;
  if (len !== a1.length) {
    return false;
  }
  for (i3 = 0;i3 < len; i3 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2 * 7;
  return arrayToUtcDate(a3);
}
function addDays(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2;
  return arrayToUtcDate(a3);
}
function addMs(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[6] += n2;
  return arrayToUtcDate(a3);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1000;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d2 = diffWholeDays(m0, m1);
  if (d2 !== null && d2 % 7 === 0) {
    return d2 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate()
  ]);
}
function startOfHour(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours()
  ]);
}
function startOfMinute(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes()
  ]);
}
function startOfSecond(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes(),
    m3.getUTCSeconds()
  ]);
}
function weekOfYear2(marker, dow, doy) {
  let y3 = marker.getUTCFullYear();
  let w4 = weekOfGivenYear(marker, y3, dow, doy);
  if (w4 < 1) {
    return weekOfGivenYear(marker, y3 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w4, nextW);
  }
  return w4;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset2(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days2 = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days2 / 7) + 1;
}
function firstWeekOffset2(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a3) {
  return new Date(a3[0], a3[1] || 0, a3[2] == null ? 1 : a3[2], a3[3] || 0, a3[4] || 0, a3[5] || 0);
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a3) {
  if (a3.length === 1) {
    a3 = a3.concat([0]);
  }
  return new Date(Date.UTC(...a3));
}
function isValidDate(m3) {
  return !isNaN(m3.valueOf());
}
function timeAsMs(m3) {
  return m3.getUTCHours() * 1000 * 60 * 60 + m3.getUTCMinutes() * 1000 * 60 + m3.getUTCSeconds() * 1000 + m3.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s3 = marker.toISOString();
  s3 = s3.replace(".000", "");
  if (stripZeroTime) {
    s3 = s3.replace("T00:00:00Z", "");
  }
  if (s3.length > 10) {
    if (timeZoneOffset == null) {
      s3 = s3.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s3;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatTimeZoneOffset(minutes2, doIso = false) {
  let sign2 = minutes2 < 0 ? "-" : "+";
  let abs2 = Math.abs(minutes2);
  let hours2 = Math.floor(abs2 / 60);
  let mins = Math.round(abs2 % 60);
  if (doIso) {
    return `${sign2 + padStart(hours2, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign2}${hours2}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 9,
  omitZeroMinute: 9,
  meridiem: 9,
  omitCommas: 9
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;

class NativeFormatter {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let smallestUnitNum = 9;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        const severity = EXTENDED_SETTINGS_AND_SEVERITIES[name];
        if (severity < 9) {
          smallestUnitNum = Math.min(EXTENDED_SETTINGS_AND_SEVERITIES[name], smallestUnitNum);
        }
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          smallestUnitNum = Math.min(STANDARD_DATE_PROP_SEVERITIES[name], smallestUnitNum);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.smallestUnitNum = smallestUnitNum;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  }
  formatRange(start3, end, context, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start3.marker, end.marker, context.calendarSystem);
    if (!diffSeverity) {
      return this.format(start3, context);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start3, context);
    let full1 = this.format(end, context);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    let partial0 = partialFormattingFunc(start3);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getSmallestUnit() {
    switch (this.smallestUnitNum) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
}
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format2;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format2 = zeroFormat;
    } else {
      format2 = normalFormat;
    }
    let s3 = format2.format(marker);
    return postProcess(s3, date, standardDateProps, extendedSettings, context);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s3, date, standardDateProps, extendedSettings, context) {
  s3 = s3.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s3 = injectTzoStr(s3, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : formatTimeZoneOffset(date.timeZoneOffset));
  }
  if (extendedSettings.omitCommas) {
    s3 = s3.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s3 = s3.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s3 = s3.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s3 = s3.replace(MULTI_SPACE_RE, " ");
  s3 = s3.trim();
  return s3;
}
function injectTzoStr(s3, tzoStr) {
  let replaced = false;
  s3 = s3.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s3 += ` ${tzoStr}`;
  }
  return s3;
}
function formatWeekNumber(num, weekText, weekTextLong, locale2, display) {
  let parts = [];
  if (display === "long") {
    parts.push(weekTextLong);
  } else if (display === "short" || display === "narrow") {
    parts.push(weekText);
  }
  if (display === "long" || display === "short") {
    parts.push(" ");
  }
  parts.push(locale2.simpleNumberFormat.format(num));
  if (locale2.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a3 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a3,
    year: a3[0],
    month: a3[1],
    day: a3[2],
    hour: a3[3],
    minute: a3[4],
    second: a3[5],
    millisecond: a3[6]
  };
}
function createVerboseFormattingArg(start3, end, context, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start3, context.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}

class CmdFormatter {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start3, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start3, end, context, betterDefaultSeparator));
  }
}

class FuncFormatter {
  constructor(func) {
    this.func = func;
  }
  format(date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start3, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start3, end, context, betterDefaultSeparator));
  }
}
function createFormatter(input) {
  if (typeof input === "object" && input) {
    return new NativeFormatter(input);
  }
  if (typeof input === "string") {
    return new CmdFormatter(input);
  }
  if (typeof input === "function") {
    return new FuncFormatter(input);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration2,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration2,
  defaultTimedEventDuration: createDuration2,
  nextDayThreshold: createDuration2,
  scrollTime: createDuration2,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration2,
  slotMaxTime: createDuration2,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration2,
  snapDuration: createDuration2,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration2,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration2,
  hiddenDays: identity,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity,
  monthStartFormat: createFormatter,
  handleCustomRendering: identity,
  customRenderingMetaMap: identity,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: "  ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1000,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a3, b3) {
  if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
    return isPropsEqual(a3, b3);
  }
  return a3 === b3;
}
function isMaybeArraysEqual(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    return isArraysEqual(a3, b3);
  }
  return a3 === b3;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }
  for (let propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }
  return { refined, extra };
}
function identity(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i3 = propObjs.length - 1;i3 >= 0; i3 -= 1) {
          let val = propObjs[i3][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== undefined) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i3 = propObjs.length - 1;i3 >= 0; i3 -= 1) {
    let props = propObjs[i3];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a3) {
  let hash = {};
  for (let item of a3) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a3 = [];
  for (let key in obj) {
    a3.push(obj[key]);
  }
  return a3;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys2 = getUnequalProps(obj0, obj1);
  for (let key of keys2) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys2 = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys2.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys2.push(key);
      }
    }
  }
  return keys2;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key]))
      ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i3 = startIndex;i3 < endIndex; i3 += step) {
    let val = hash[i3];
    if (val !== undefined) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name];
}

class GregorianCalendarSystem {
  getMarkerYear(d2) {
    return d2.getUTCFullYear();
  }
  getMarkerMonth(d2) {
    return d2.getUTCMonth();
  }
  getMarkerDay(d2) {
    return d2.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
}
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m3 = ISO_RE.exec(str);
  if (m3) {
    let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1000 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m3[13]) {
        timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m3[6],
        timeZoneOffset
      };
    }
  }
  return null;
}

class DateEnv {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  createMarker(input) {
    let meta = this.createMarkerMeta(input);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker(new Date().valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(new Date));
  }
  createMarkerMeta(input) {
    if (typeof input === "string") {
      return this.parse(input);
    }
    let marker = null;
    if (typeof input === "number") {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();
      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s3) {
    let parts = parse(s3);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  add(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += dur.years;
    a3[1] += dur.months;
    a3[2] += dur.days;
    a3[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  subtract(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] -= dur.years;
    a3[1] -= dur.months;
    a3[2] -= dur.days;
    a3[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addYears(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addMonths(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[1] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  greatestWholeUnit(m0, m1) {
    let n2 = this.diffWholeYears(m0, m1);
    if (n2 !== null) {
      return { unit: "year", value: n2 };
    }
    n2 = this.diffWholeMonths(m0, m1);
    if (n2 !== null) {
      return { unit: "month", value: n2 };
    }
    n2 = diffWholeWeeks(m0, m1);
    if (n2 !== null) {
      return { unit: "week", value: n2 };
    }
    n2 = diffWholeDays(m0, m1);
    if (n2 !== null) {
      return { unit: "day", value: n2 };
    }
    n2 = diffHours(m0, m1);
    if (isInt(n2)) {
      return { unit: "hour", value: n2 };
    }
    n2 = diffMinutes(m0, m1);
    if (isInt(n2)) {
      return { unit: "minute", value: n2 };
    }
    n2 = diffSeconds(m0, m1);
    if (isInt(n2)) {
      return { unit: "second", value: n2 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d2) {
    let diff2;
    if (d2.years) {
      diff2 = this.diffWholeYears(m0, m1);
      if (diff2 !== null) {
        return diff2 / asRoughYears(d2);
      }
    }
    if (d2.months) {
      diff2 = this.diffWholeMonths(m0, m1);
      if (diff2 !== null) {
        return diff2 / asRoughMonths(d2);
      }
    }
    if (d2.days) {
      diff2 = diffWholeDays(m0, m1);
      if (diff2 !== null) {
        return diff2 / asRoughDays(d2);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
  }
  startOf(m3, unit) {
    if (unit === "year") {
      return this.startOfYear(m3);
    }
    if (unit === "month") {
      return this.startOfMonth(m3);
    }
    if (unit === "week") {
      return this.startOfWeek(m3);
    }
    if (unit === "day") {
      return startOfDay(m3);
    }
    if (unit === "hour") {
      return startOfHour(m3);
    }
    if (unit === "minute") {
      return startOfMinute(m3);
    }
    if (unit === "second") {
      return startOfSecond(m3);
    }
    return null;
  }
  startOfYear(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3)
    ]);
  }
  startOfMonth(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3)
    ]);
  }
  startOfWeek(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3),
      m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear2(marker, this.weekDow, this.weekDoy);
  }
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start3, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start3,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start3)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m3) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
    }
    return null;
  }
  toDate(m3, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m3));
    }
    if (this.timeZone === "UTC") {
      return new Date(m3.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m3.valueOf() - (forcedTzo || 0));
    }
    return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1000 * 60);
  }
}

class Theme {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className.indexOf(prefix) !== 0) {
      className = prefix + className;
    }
    return className;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className;
    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }
    if (className) {
      return `${this.baseIconClass} ${className}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className;
    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
      }
    }
    return "";
  }
}
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback) {
    callbackQ.push(callback);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}

class FakeComponent extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
}
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c3) => {
            c3.context = _props.value;
            c3.forceUpdate();
          });
        }
      };
      this.sub = (c3) => {
        subs.push(c3);
        let old = c3.componentWillUnmount;
        c3.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c3), 1);
          old && old.call(c3);
        };
      };
    }
    return children;
  };
  return ContextType;
}

class ScrollResponder {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
}
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, nowManager, theme, pluginHooks, dispatch2, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    nowManager,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch: dispatch2,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration2(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}

class PureComponent extends x {
  shouldComponentUpdate(nextProps, nextState) {
    const shouldUpdate = !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
    return shouldUpdate;
  }
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
}
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};

class BaseComponent extends PureComponent {
}
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}

class ContentInjector extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject2 && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject2 && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== undefined ? _a : customRenderingMetaMap === null || customRenderingMetaMap === undefined ? undefined : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
}
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === undefined ? undefined : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);

class ContentContainer extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(undefined, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === undefined || _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === undefined || _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
}
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}

class ViewContainer extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = { view: context.viewApi };
    return y(ContentContainer, { elRef: props.elRef, elTag: props.elTag || "div", elAttrs: props.elAttrs, elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], elStyle: props.elStyle, renderProps, classNameGenerator: options.viewClassNames, generatorName: undefined, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }, () => props.children);
  }
}
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input, dateEnv) {
  let start3 = null;
  let end = null;
  if (input.start) {
    start3 = dateEnv.createMarker(input.start);
  }
  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }
  if (!start3 && !end) {
    return null;
  }
  if (start3 && end && end < start3) {
    return null;
  }
  return { start: start3, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start: start3 } = constraintRange;
  let i3;
  let dateRange;
  ranges.sort(compareRanges);
  for (i3 = 0;i3 < ranges.length; i3 += 1) {
    dateRange = ranges[i3];
    if (dateRange.start > start3) {
      invertedRanges.push({ start: start3, end: dateRange.start });
    }
    if (dateRange.end > start3) {
      start3 = dateRange.end;
    }
  }
  if (start3 < constraintRange.end) {
    invertedRanges.push({ start: start3, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start: start3, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start3 === null) {
      start3 = range1.start;
    } else {
      start3 = new Date(Math.max(start3.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start3 === null || end === null || start3 < end) {
    newRange = { start: start3, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range, date) {
  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
}
function constrainMarkerToRange(date, range) {
  if (range.start != null && date < range.start) {
    return range.start;
  }
  if (range.end != null && date >= range.end) {
    return new Date(range.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start3 = startOfDay(timedRange.start);
  let end = addDays(start3, dayCnt);
  return { start: start3, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration2(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration2(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration2(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}

class DateProfileGenerator {
  constructor(props) {
    this.props = props;
    this.initHiddenDays();
  }
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);
    return this.build(prevDate, -1, forceToValid);
  }
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);
    return this.build(nextDate, 1, forceToValid);
  }
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid2;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid2 = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      validRange,
      currentRange: currentInfo.range,
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      activeRange,
      renderRange,
      slotMinTime: props.slotMinTime,
      slotMaxTime: props.slotMaxTime,
      isValid: isValid2,
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
    };
  }
  buildValidRange() {
    let input = this.props.validRangeInput;
    let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.props.dateEnv.toDate(this.props.nowManager.getDateMarker())) : input;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range };
  }
  getFallbackDuration() {
    return createDuration2({ day: 1 });
  }
  adjustActiveRange(range) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start: start3, end } = range;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start3 = startOfDay(start3);
        start3 = dateEnv.add(start3, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start: start3, end };
  }
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start3;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start3)) {
        start3 = this.skipHiddenDays(start3, direction);
        start3 = startOfDay(start3);
      }
    }
    function computeRes() {
      start3 = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start3, duration);
      res = { start: start3, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start3 = date;
    let end;
    if (dateAlignment) {
      start3 = dateEnv.startOf(start3, dateAlignment);
    }
    start3 = startOfDay(start3);
    start3 = this.skipHiddenDays(start3, direction);
    end = start3;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start: start3, end };
  }
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input = props.visibleRangeInput;
    let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    let range = this.refineRange(simpleInput);
    if (range && (range.start == null || range.end == null)) {
      return null;
    }
    return range;
  }
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration2(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration2({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range = parseRange(rangeInput, this.props.dateEnv);
      if (range) {
        range = computeVisibleDayRange(range);
      }
      return range;
    }
    return null;
  }
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i3;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i3 = 0;i3 < 7; i3 += 1) {
      if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  trimHiddenDays(range) {
    let { start: start3, end } = range;
    if (start3) {
      start3 = this.skipHiddenDays(start3);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start3 == null || end == null || start3 < end) {
      return { start: start3, end };
    }
    return null;
  }
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
}
function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i3 = 0;i3 < recurringTypes.length; i3 += 1) {
    let parsed = recurringTypes[i3].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i3
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context) {
  let { dateEnv, pluginHooks, options } = context;
  let { defs, instances } = eventStore;
  instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start3 of starts) {
        let instance = createEventInstance(defId, {
          start: start3,
          end: dateEnv.add(start3, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances) {
    if (!sub.instances[instanceId] && filteredDefs[instances[instanceId].defId]) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true);
  }
  if (typeof input === "object" && input) {
    return parseEvents([input], null, context, true);
  }
  if (input != null) {
    return String(input);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context) {
  let constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  success: identity,
  failure: identity
};
function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  for (let i3 = defs.length - 1;i3 >= 0; i3 -= 1) {
    let def = defs[i3];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i3, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
    case "ADD_EVENTS":
      return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context);
}
function transformRawEvents(rawEvents, eventSource, context) {
  let calEachTransform = context.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances) {
    const instance = instances[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}

class Emitter {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
}
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
};
function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
  let rawDefs;
  if (input === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input)) {
    rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input === "object" && input) {
    rawDefs = [input];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
}
function triggerDateUnselect(pev, context) {
  context.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context) {
  let { dateEnv, options } = context;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context);
  }
  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
  let { dateEnv } = context;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }
  return copy;
}

class EventSourceImpl {
  constructor(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
}

class EventImpl {
  constructor(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui = { startEditable: val, durationEditable: val };
      } else {
        ui = { [name]: val };
      }
      this.mutate({
        standardProps: { ui }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start3 = dateEnv.createMarker(startInput);
    if (start3 && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start3, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start3 = dateEnv.createMarker(startInput);
    let end;
    if (!start3) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start3, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration2(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration2(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration2(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context = this._context;
      let { eventStore } = context.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
      let oldEvent = new EventImpl(context, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context, instance),
        revert() {
          context.dispatch({
            type: "RESET_EVENTS",
            eventStore
          });
        }
      });
    }
  }
  remove() {
    let context = this._context;
    let asStore = eventApiToStore(this);
    context.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui.display && ui.display !== "auto") {
      res.display = ui.display;
    }
    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.textColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
}
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context, excludeInstance) {
  let { defs, instances } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id2 in instances) {
    let instance = instances[id2];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui = eventUis[def.defId];
    if (ui.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== "none") {
        (ui.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui = eventUis[def.defId];
      bgRanges.push({
        def,
        ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c3) => c3._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start3 = range.start ? range.start.valueOf() : 0;
  let end = range.end ? range.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start: start3,
    end,
    duration: end - start3,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context) {
  let { pluginHooks } = context;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui } = seg.eventRange;
  let val = ui.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui, context);
  }
  return val;
}
function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range } = span;
  if (!range.start) {
    return null;
  }
  if (!range.end) {
    if (defaultDuration == null) {
      return null;
    }
    range.end = dateEnv.add(range.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range.start),
    end: dateEnv.toDate(range.end),
    startStr: dateEnv.formatIso(range.start, { omitTime }),
    endStr: dateEnv.formatIso(range.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
  let res = refineEventDef({ editable: false }, context);
  let def = parseEventDef(res.refined, res.extra, "", dateSpan.allDay, true, context);
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error2) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error2);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}

class JsonRequestError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}

class CalendarRoot extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
}

class Interaction {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {}
}
function parseInteractionSettings(component, input) {
  return {
    component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};

class NowTimer extends x {
  constructor(props, context) {
    super(props, context);
    this.handleRefresh = () => {
      let timing = this.computeTiming();
      if (timing.state.nowDate.valueOf() !== this.state.nowDate.valueOf()) {
        this.setState(timing.state);
      }
      this.clearTimeout();
      this.setTimeout(timing.waitMs);
    };
    this.handleVisibilityChange = () => {
      if (!document.hidden) {
        this.handleRefresh();
      }
    };
    this.state = this.computeTiming().state;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
    this.context.nowManager.addResetListener(this.handleRefresh);
    document.addEventListener("visibilitychange", this.handleVisibilityChange);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
    this.context.nowManager.removeResetListener(this.handleRefresh);
    document.removeEventListener("visibilitychange", this.handleVisibilityChange);
  }
  computeTiming() {
    let { props, context } = this;
    let unroundedNow = context.nowManager.getDateMarker();
    let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration2(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);
    return {
      state: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      waitMs
    };
  }
  setTimeout(waitMs = this.computeTiming().waitMs) {
    this.timeoutId = setTimeout(() => {
      const timing = this.computeTiming();
      this.setState(timing.state, () => {
        this.setTimeout(timing.waitMs);
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
}
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start3 = startOfDay(date);
  let end = addDays(start3, 1);
  return { start: start3, end };
}

class CalendarImpl {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback) {
    callback();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i3;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i3 = 0;i3 < viewTypes.length; i3 += 1) {
      spec = viewSpecs[viewTypes[i3]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.nowManager.getDateMarker()
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration2(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  formatDate(d2, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
  }
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d2, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
  }
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration2({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  getEventById(id2) {
    let state = this.getCurrentData();
    let { defs, instances } = state.eventStore;
    id2 = String(id2);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id2) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances) {
          let instance = instances[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id2) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id2 = String(id2);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id2) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  scrollToTime(timeInput) {
    let time = createDuration2(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
}
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && (!dateProfile.activeRange || !rangeContainsMarker(dateProfile.activeRange, date))),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1000,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}

class PositionCache {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i3;
    for (i3 = 0;i3 < len; i3 += 1) {
      if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
        return i3;
      }
    }
    return;
  }
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i3;
    for (i3 = 0;i3 < len; i3 += 1) {
      if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
        return i3;
      }
    }
    return;
  }
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
}
function similarNumArrays(a3, b3) {
  const len = a3.length;
  if (len !== b3.length) {
    return false;
  }
  for (let i3 = 0;i3 < len; i3++) {
    if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
      return false;
    }
  }
  return true;
}

class ScrollController {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
}

class ElementScrollController extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
}

class WindowScrollController extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n2) {
    window.scroll(window.scrollX, n2);
  }
  setScrollLeft(n2) {
    window.scroll(n2, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
}

class DateComponent extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  prepareHits() {}
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  isValidSegDownEl(el) {
    return !this.props.eventDrag && !this.props.eventResize && !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && !elementClosest(el, "a[data-navlink]") && !elementClosest(el, ".fc-popover");
  }
}
class SegHierarchy {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input of inputs) {
      this.insertEntry(input, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0;trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while ((trackingEntry = trackingEntries[lateralIndex]) && trackingEntry.span.start < newEntry.span.end) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0;level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
}
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function intersectSpans(span0, span1) {
  let start3 = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start3 < end) {
    return { start: start3, end };
  }
  return null;
}
function insertAt(arr, index, item) {
  arr.splice(index, 0, item);
}
function binarySearch(a3, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a3.length;
  if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a3[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a3[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}

class ElementDragging {
  constructor(el, selector) {
    this.emitter = new Emitter;
  }
  destroy() {}
  setMirrorIsVisible(bool) {}
  setMirrorNeedsRevert(bool) {}
  setAutoScrollEnabled(bool) {}
}
var config2 = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}

class TableDateCell extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let publicDate = dateEnv.toDate(date);
    if (dateEnv.namedTimeZoneImpl) {
      publicDate = addMs(publicDate, 3600000);
    }
    let renderProps = Object.assign(Object.assign(Object.assign({ date: publicDate, view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : undefined }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
}
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });

class TableDowCell extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(new Date(259200000), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y("div", { className: "fc-scrollgrid-sync-inner" }, y(InnerContent, { elTag: "a", elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ], elAttrs: {
      "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
    } })));
  }
}

class DayHeader extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y("tr", { role: "row" }, renderIntro && renderIntro("day"), dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))));
  }
}
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}

class DaySeriesModel {
  constructor(range, dateProfileGenerator) {
    let date = range.start;
    let { end } = range;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range) {
    let firstIndex = this.getDateDayIndex(range.start);
    let lastIndex = this.getDateDayIndex(addDays(range.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
}

class DayTableModel {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1;daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0;row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0;col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0;col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index = firstIndex;
      while (index <= lastIndex) {
        let row = Math.floor(index / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index = nextIndex;
      }
    }
    return segs;
  }
}

class Slicer {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
    return this._sliceDateSpan({ range: { start: date, end: addMs(date, 1) }, allDay: false }, dateProfile, nextDayThreshold, {}, context, ...extraArgs);
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
}
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range;
  }
  return {
    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 86400000)
  };
}
function isInteractionValid(interaction, dateProfile, context) {
  let { instances } = interaction.mutatedEvents;
  for (let instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context);
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context);
}
function isNewPropsValid(newProps, context) {
  let calendarState = context.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let currentState = context.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    }
    let { eventOverlap } = context.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), new EventImpl(context, subjectDef, subjectInstance))) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  }
  let { selectOverlap } = context.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances } = eventStore;
  let ranges = [];
  for (let instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;

class Scroller extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className.push("fc-scroller-liquid-absolute");
      } else {
        className.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i3 = 0;i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i3 = 0;i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
}

class RefMap {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
}
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements2(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i3 = 0;i3 < span; i3 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context) {
  let classNames = [
    "fc-scrollgrid",
    context.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}

class SimpleScrollGrid extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a3) => a3, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap;
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {}
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y("div", { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` }, y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
}
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}

class EventContainer extends BaseComponent {
  constructor() {
    super(...arguments);
    this.buildPublicEvent = memoize((context, eventDef, eventInstance) => new EventImpl(context, eventDef, eventInstance));
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui } = eventRange;
    const renderProps = {
      event: this.buildPublicEvent(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, { elRef: this.handleEl, elTag: props.elTag, elAttrs: props.elAttrs, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], elStyle: props.elStyle, renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }, props.children);
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
}

class StandardEvent extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let { ui } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui.borderColor,
      backgroundColor: ui.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(_, null, y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }), Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }), Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })));
  }
}
StandardEvent.addPropsEquality({
  seg: isPropsEqual
});
function renderInnerContent$1(innerProps) {
  return y("div", { className: "fc-event-main-frame" }, innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText), y("div", { className: "fc-event-title-container" }, y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, ""))));
}
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });

class DayCellContainer extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, { elRef: props.elRef, elTag: props.elTag, elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), elClasses: [
      ...getDayClassNames(renderProps, context.theme),
      ...props.elClasses || []
    ], elStyle: props.elStyle, renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: renderProps.isDisabled ? undefined : options.dayCellClassNames, didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }, props.children);
  }
}
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}

class BgEvent extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
}
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { dateEnv, options } = context;
  let { date } = props;
  let format2 = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format2);
  let renderProps = { num, text, date };
  return y(ContentContainer, { elRef: props.elRef, elTag: props.elTag, elAttrs: props.elAttrs, elClasses: props.elClasses, elStyle: props.elStyle, renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount }, props.children);
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;

class Popover extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y("div", Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }), y("div", { className: "fc-popover-header " + theme.getClass("popoverHeader") }, y("span", { className: "fc-popover-title", id: state.titleId }, props.title), y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })), y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
}

class MorePopover extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(Popover, { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose }, hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }), props.children));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
      };
    }
    return null;
  }
}

class MoreLinkContainer extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context } = this;
      let { moreLinkClick } = context.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range } = seg.eventRange;
        return {
          event: new EventImpl(context, def, instance),
          start: context.dateEnv.toDate(range.start),
          end: context.dateEnv.toDate(range.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { viewApi, options, calendarApi } = context;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(_, null, Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
        ...props.elClasses || [],
        "fc-more-link"
      ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children), state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent()));
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
}
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i3 = 0;i3 < codes.length; i3 += 1) {
    let parts = codes[i3].toLocaleLowerCase().split("-");
    for (let j4 = parts.length;j4 > 0; j4 -= 1) {
      let simpleId = parts.slice(0, j4).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input) {
  return {
    id: guid(),
    name: input.name,
    premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || "",
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks3 = {
    premiumReleaseDate: undefined,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === undefined) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks3 = combineHooks(hooks3, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks3;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === undefined) {
    return date1;
  }
  if (date1 === undefined) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}

class StandardTheme extends Theme {
}
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
  let rawOptions = typeof input === "function" ? { component: input } : input;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: undefined, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === undefined) {
    res = createDuration2(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv, nowManager) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return nowManager.getDateMarker();
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }
  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
  let { options, calendarApi } = context;
  let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error2) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error2);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error2);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error2.message, error2);
    }
    context.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error: error2
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
}
function parseInitialSources(rawOptions, context) {
  let refiners = buildEventSourceRefiners(context);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [textFallback, buttonName], textFallback);
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}

class ViewImpl {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
}
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range.start);
  params[endParam] = dateEnv.formatIso(range.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration2,
  endTime: createDuration2,
  duration: createDuration2,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,
        dateEnv
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, typeData.dateEnv, dateEnv, clippedFramingRange);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek, startTime, eventDateEnv, calendarDateEnv, framingRange) {
  let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = calendarDateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(calendarDateEnv.createMarker(eventDateEnv.toDate(instanceStart)));
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context) {
      handleEventSources([events], context);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context) {
  let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input of inputs) {
    let inputFound = false;
    for (let i3 = 0;i3 < unfoundSources.length; i3 += 1) {
      if (unfoundSources[i3]._raw === input) {
        unfoundSources.splice(i3, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context) {
  context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
}
function handleEventStore(eventStore, context) {
  let { emitter } = context;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];

class TaskRunner {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
}
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range = dateProfile.currentRange;
  } else {
    range = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days2 = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days2 !== null && days2 > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}

class CalendarNowManager {
  constructor() {
    this.resetListeners = new Set;
  }
  handleInput(dateEnv, nowInput) {
    const oldDateEnv = this.dateEnv;
    if (dateEnv !== oldDateEnv) {
      if (typeof nowInput === "function") {
        this.nowFn = nowInput;
      } else if (!oldDateEnv) {
        this.nowAnchorDate = dateEnv.toDate(nowInput ? dateEnv.createMarker(nowInput) : dateEnv.createNowMarker());
        this.nowAnchorQueried = Date.now();
      }
      this.dateEnv = dateEnv;
      if (oldDateEnv) {
        for (const resetListener of this.resetListeners.values()) {
          resetListener();
        }
      }
    }
  }
  getDateMarker() {
    return this.nowAnchorDate ? this.dateEnv.timestampToMarker(this.nowAnchorDate.valueOf() + (Date.now() - this.nowAnchorQueried)) : this.dateEnv.createMarker(this.nowFn());
  }
  addResetListener(handler) {
    this.resetListeners.add(handler);
  }
  removeResetListener(handler) {
    this.resetListeners.delete(handler);
  }
}

class CalendarDataManager {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.nowManager = new CalendarNowManager;
    this.emitter = new Emitter;
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    this.nowManager = new CalendarNowManager;
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let calendarContext = {
      nowManager: this.nowManager,
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv, this.nowManager);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    for (let callback of optionsData.pluginHooks.contextInit) {
      callback(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === undefined) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === undefined || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      nowManager: this.nowManager,
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || action.type === "NEXT" || !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ nowManager: this.nowManager, viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales: locales2, locale: locale2 } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales2);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale2 || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && (optionName in currentRaw) && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    this.nowManager.handleInput(optionsData.dateEnv, refinedOptions.now);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      nowManager: this.nowManager,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
}
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale2 = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale: locale2,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : undefined,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : undefined,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context) {
  for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}

class ToolbarSection extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
}

class Toolbar extends BaseComponent {
  render() {
    let { model, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y("div", { className: classNames.join(" ") }, this.renderSection("start", startContent || []), this.renderSection("center", centerContent || []), this.renderSection("end", endContent || []));
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
}

class ViewHarness extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
}

class EventClicking extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (seg && component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(settings.el, "click", ".fc-event", this.handleSegClick);
  }
}

class EventHovering extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(settings.el, ".fc-event", this.handleSegEnter, this.handleSegLeave);
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  }
}

class CalendarContent extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.nowManager, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : undefined;
    return y(ViewContextType.Provider, { value: viewContext }, y(NowTimer, { unit: "day" }, (nowDate) => {
      let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, nowDate, props.viewTitle);
      return y(_, null, toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)), y(ViewHarness, { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps)));
    }));
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
}
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now3, title) {
  let todayInfo = dateProfileGenerator.build(now3, undefined, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now3),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass);
}

class Calendar extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(RenderId.Provider, { value: this.customContentRenderId }, y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData)));
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className of this.currentClassNames) {
        classList.remove(className);
      }
      for (let className of classNames) {
        classList.add(className);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
}

// node_modules/@fullcalendar/core/locales/af.js
var l0 = {
  code: "af",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Vorige",
    next: "Volgende",
    today: "Vandag",
    year: "Jaar",
    month: "Maand",
    week: "Week",
    day: "Dag",
    list: "Agenda"
  },
  allDayText: "Heeldag",
  moreLinkText: "Addisionele",
  noEventsText: "Daar is geen gebeurtenisse nie"
};

// node_modules/@fullcalendar/core/locales/ar-dz.js
var l1 = {
  code: "ar-dz",
  week: {
    dow: 0,
    doy: 4
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/ar-kw.js
var l22 = {
  code: "ar-kw",
  week: {
    dow: 0,
    doy: 12
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/ar-ly.js
var l3 = {
  code: "ar-ly",
  week: {
    dow: 6,
    doy: 12
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/ar-ma.js
var l4 = {
  code: "ar-ma",
  week: {
    dow: 6,
    doy: 12
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/ar-sa.js
var l5 = {
  code: "ar-sa",
  week: {
    dow: 0,
    doy: 6
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/ar-tn.js
var l6 = {
  code: "ar-tn",
  week: {
    dow: 1,
    doy: 4
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/ar.js
var l7 = {
  code: "ar",
  week: {
    dow: 6,
    doy: 12
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/az.js
var l8 = {
  code: "az",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "vvl",
    next: "Sonra",
    today: "Bu Gn",
    year: "Il",
    month: "Ay",
    week: "Hft",
    day: "Gn",
    list: "Gndm"
  },
  weekText: "Hft",
  allDayText: "Btn Gn",
  moreLinkText(n2) {
    return "+ daha ox " + n2;
  },
  noEventsText: "Gstrmk n hadis yoxdur"
};

// node_modules/@fullcalendar/core/locales/bg.js
var l9 = {
  code: "bg",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  allDayText: " ",
  moreLinkText(n2) {
    return "+ " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/bn.js
var l10 = {
  code: "bn",
  week: {
    dow: 0,
    doy: 6
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText(n2) {
    return "+ " + n2;
  },
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/bs.js
var l11 = {
  code: "bs",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "Proli",
    next: "Sljedei",
    today: "Danas",
    year: "Godina",
    month: "Mjesec",
    week: "Sedmica",
    day: "Dan",
    list: "Raspored"
  },
  weekText: "Sed",
  allDayText: "Cijeli dan",
  moreLinkText(n2) {
    return "+ jo " + n2;
  },
  noEventsText: "Nema dogaaja za prikazivanje"
};

// node_modules/@fullcalendar/core/locales/ca.js
var l12 = {
  code: "ca",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Anterior",
    next: "Segent",
    today: "Avui",
    year: "Any",
    month: "Mes",
    week: "Setmana",
    day: "Dia",
    list: "Agenda"
  },
  weekText: "Set",
  allDayText: "Tot el dia",
  moreLinkText: "ms",
  noEventsText: "No hi ha esdeveniments per mostrar"
};

// node_modules/@fullcalendar/core/locales/cs.js
var l13 = {
  code: "cs",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Dve",
    next: "Pozdji",
    today: "Nyn",
    year: "Rok",
    month: "Msc",
    week: "Tden",
    day: "Den",
    list: "Agenda"
  },
  weekText: "Td",
  allDayText: "Cel den",
  moreLinkText(n2) {
    return "+dal: " + n2;
  },
  noEventsText: "dn akce k zobrazen"
};

// node_modules/@fullcalendar/core/locales/cy.js
var l14 = {
  code: "cy",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Blaenorol",
    next: "Nesaf",
    today: "Heddiw",
    year: "Blwyddyn",
    month: "Mis",
    week: "Wythnos",
    day: "Dydd",
    list: "Rhestr"
  },
  weekText: "Wythnos",
  allDayText: "Trwy'r dydd",
  moreLinkText: "Mwy",
  noEventsText: "Dim digwyddiadau"
};

// node_modules/@fullcalendar/core/locales/da.js
var l15 = {
  code: "da",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Forrige",
    next: "Nste",
    today: "I dag",
    year: "r",
    month: "Mned",
    week: "Uge",
    day: "Dag",
    list: "Agenda"
  },
  weekText: "Uge",
  allDayText: "Hele dagen",
  moreLinkText: "flere",
  noEventsText: "Ingen arrangementer at vise"
};

// node_modules/@fullcalendar/core/locales/de-at.js
function affix(buttonText) {
  return buttonText === "Tag" || buttonText === "Monat" ? "r" : buttonText === "Jahr" ? "s" : "";
}
var l16 = {
  code: "de-at",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Zurck",
    next: "Vor",
    today: "Heute",
    year: "Jahr",
    month: "Monat",
    week: "Woche",
    day: "Tag",
    list: "Terminbersicht"
  },
  weekText: "KW",
  weekTextLong: "Woche",
  allDayText: "Ganztgig",
  moreLinkText(n2) {
    return "+ weitere " + n2;
  },
  noEventsText: "Keine Ereignisse anzuzeigen",
  buttonHints: {
    prev(buttonText) {
      return `Vorherige${affix(buttonText)} ${buttonText}`;
    },
    next(buttonText) {
      return `Nchste${affix(buttonText)} ${buttonText}`;
    },
    today(buttonText) {
      if (buttonText === "Tag") {
        return "Heute";
      }
      return `Diese${affix(buttonText)} ${buttonText}`;
    }
  },
  viewHint(buttonText) {
    const glue = buttonText === "Woche" ? "n" : buttonText === "Monat" ? "s" : "es";
    return buttonText + glue + "ansicht";
  },
  navLinkHint: "Gehe zu $0",
  moreLinkHint(eventCnt) {
    return "Zeige " + (eventCnt === 1 ? "ein weiteres Ereignis" : eventCnt + " weitere Ereignisse");
  },
  closeHint: "Schlieen",
  timeHint: "Uhrzeit",
  eventHint: "Ereignis"
};

// node_modules/@fullcalendar/core/locales/de.js
function affix2(buttonText) {
  return buttonText === "Tag" || buttonText === "Monat" ? "r" : buttonText === "Jahr" ? "s" : "";
}
var l17 = {
  code: "de",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Zurck",
    next: "Vor",
    today: "Heute",
    year: "Jahr",
    month: "Monat",
    week: "Woche",
    day: "Tag",
    list: "Terminbersicht"
  },
  weekText: "KW",
  weekTextLong: "Woche",
  allDayText: "Ganztgig",
  moreLinkText(n2) {
    return "+ weitere " + n2;
  },
  noEventsText: "Keine Ereignisse anzuzeigen",
  buttonHints: {
    prev(buttonText) {
      return `Vorherige${affix2(buttonText)} ${buttonText}`;
    },
    next(buttonText) {
      return `Nchste${affix2(buttonText)} ${buttonText}`;
    },
    today(buttonText) {
      if (buttonText === "Tag") {
        return "Heute";
      }
      return `Diese${affix2(buttonText)} ${buttonText}`;
    }
  },
  viewHint(buttonText) {
    const glue = buttonText === "Woche" ? "n" : buttonText === "Monat" ? "s" : "es";
    return buttonText + glue + "ansicht";
  },
  navLinkHint: "Gehe zu $0",
  moreLinkHint(eventCnt) {
    return "Zeige " + (eventCnt === 1 ? "ein weiteres Ereignis" : eventCnt + " weitere Ereignisse");
  },
  closeHint: "Schlieen",
  timeHint: "Uhrzeit",
  eventHint: "Ereignis"
};

// node_modules/@fullcalendar/core/locales/el.js
var l18 = {
  code: "el",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: "",
  noEventsText: "    "
};

// node_modules/@fullcalendar/core/locales/en-au.js
var l19 = {
  code: "en-au",
  week: {
    dow: 1,
    doy: 4
  },
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today: "This $0"
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
};

// node_modules/@fullcalendar/core/locales/en-gb.js
var l20 = {
  code: "en-gb",
  week: {
    dow: 1,
    doy: 4
  },
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today: "This $0"
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
};

// node_modules/@fullcalendar/core/locales/en-nz.js
var l21 = {
  code: "en-nz",
  week: {
    dow: 1,
    doy: 4
  },
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today: "This $0"
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
};

// node_modules/@fullcalendar/core/locales/eo.js
var l222 = {
  code: "eo",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Antaa",
    next: "Sekva",
    today: "Hodia",
    year: "Jaro",
    month: "Monato",
    week: "Semajno",
    day: "Tago",
    list: "Tagordo"
  },
  weekText: "Sm",
  allDayText: "Tuta tago",
  moreLinkText: "pli",
  noEventsText: "Neniuj eventoj por montri"
};

// node_modules/@fullcalendar/core/locales/es-us.js
var l23 = {
  code: "es",
  week: {
    dow: 0,
    doy: 6
  },
  buttonText: {
    prev: "Ant",
    next: "Sig",
    today: "Hoy",
    year: "Ao",
    month: "Mes",
    week: "Semana",
    day: "Da",
    list: "Agenda"
  },
  weekText: "Sm",
  allDayText: "Todo el da",
  moreLinkText: "ms",
  noEventsText: "No hay eventos para mostrar"
};

// node_modules/@fullcalendar/core/locales/es.js
var l24 = {
  code: "es",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Ant",
    next: "Sig",
    today: "Hoy",
    year: "Ao",
    month: "Mes",
    week: "Semana",
    day: "Da",
    list: "Agenda"
  },
  buttonHints: {
    prev: "$0 antes",
    next: "$0 siguiente",
    today(buttonText) {
      return buttonText === "Da" ? "Hoy" : (buttonText === "Semana" ? "Esta" : "Este") + " " + buttonText.toLocaleLowerCase();
    }
  },
  viewHint(buttonText) {
    return "Vista " + (buttonText === "Semana" ? "de la" : "del") + " " + buttonText.toLocaleLowerCase();
  },
  weekText: "Sm",
  weekTextLong: "Semana",
  allDayText: "Todo el da",
  moreLinkText: "ms",
  moreLinkHint(eventCnt) {
    return `Mostrar ${eventCnt} eventos ms`;
  },
  noEventsText: "No hay eventos para mostrar",
  navLinkHint: "Ir al $0",
  closeHint: "Cerrar",
  timeHint: "La hora",
  eventHint: "Evento"
};

// node_modules/@fullcalendar/core/locales/et.js
var l25 = {
  code: "et",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Eelnev",
    next: "Jrgnev",
    today: "Tna",
    year: "Aasta",
    month: "Kuu",
    week: "Ndal",
    day: "Pev",
    list: "Pevakord"
  },
  weekText: "nd",
  allDayText: "Kogu pev",
  moreLinkText(n2) {
    return "+ veel " + n2;
  },
  noEventsText: "Kuvamiseks puuduvad sndmused"
};

// node_modules/@fullcalendar/core/locales/eu.js
var l26 = {
  code: "eu",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "Aur",
    next: "Hur",
    today: "Gaur",
    year: "Urtea",
    month: "Hilabetea",
    week: "Astea",
    day: "Eguna",
    list: "Agenda"
  },
  weekText: "As",
  allDayText: "Egun osoa",
  moreLinkText: "gehiago",
  noEventsText: "Ez dago ekitaldirik erakusteko"
};

// node_modules/@fullcalendar/core/locales/fa.js
var l27 = {
  code: "fa",
  week: {
    dow: 6,
    doy: 12
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "  " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/fi.js
var l28 = {
  code: "fi",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Edellinen",
    next: "Seuraava",
    today: "Tnn",
    year: "Vuosi",
    month: "Kuukausi",
    week: "Viikko",
    day: "Piv",
    list: "Tapahtumat"
  },
  weekText: "Vk",
  allDayText: "Koko piv",
  moreLinkText: "lis",
  noEventsText: "Ei nytettvi tapahtumia"
};

// node_modules/@fullcalendar/core/locales/fr-ca.js
var l29 = {
  code: "fr",
  buttonText: {
    prev: "Prcdent",
    next: "Suivant",
    today: "Aujourd'hui",
    year: "Anne",
    month: "Mois",
    week: "Semaine",
    day: "Jour",
    list: "Mon planning"
  },
  weekText: "Sem.",
  allDayText: "Toute la journe",
  moreLinkText: "en plus",
  noEventsText: "Aucun vnement  afficher"
};

// node_modules/@fullcalendar/core/locales/fr-ch.js
var l30 = {
  code: "fr-ch",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Prcdent",
    next: "Suivant",
    today: "Courant",
    year: "Anne",
    month: "Mois",
    week: "Semaine",
    day: "Jour",
    list: "Mon planning"
  },
  weekText: "Sm",
  allDayText: "Toute la journe",
  moreLinkText: "en plus",
  noEventsText: "Aucun vnement  afficher"
};

// node_modules/@fullcalendar/core/locales/fr.js
var l31 = {
  code: "fr",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Prcdent",
    next: "Suivant",
    today: "Aujourd'hui",
    year: "Anne",
    month: "Mois",
    week: "Semaine",
    day: "Jour",
    list: "Planning"
  },
  weekText: "Sem.",
  weekTextLong: "Semaine",
  allDayText: "Toute la journe",
  moreLinkText: "en plus",
  noEventsText: "Aucun vnement  afficher"
};

// node_modules/@fullcalendar/core/locales/gl.js
var l32 = {
  code: "gl",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Ant",
    next: "Seg",
    today: "Hoxe",
    year: "Ano",
    month: "Mes",
    week: "Semana",
    day: "Da",
    list: "Axenda"
  },
  buttonHints: {
    prev: "$0 antes",
    next: "$0 seguinte",
    today(buttonText) {
      return buttonText === "Da" ? "Hoxe" : (buttonText === "Semana" ? "Esta" : "Este") + " " + buttonText.toLocaleLowerCase();
    }
  },
  viewHint(buttonText) {
    return "Vista " + (buttonText === "Semana" ? "da" : "do") + " " + buttonText.toLocaleLowerCase();
  },
  weekText: "Sm",
  weekTextLong: "Semana",
  allDayText: "Todo o da",
  moreLinkText: "mis",
  moreLinkHint(eventCnt) {
    return `Amosar ${eventCnt} eventos mis`;
  },
  noEventsText: "Non hai eventos para amosar",
  navLinkHint: "Ir ao $0",
  closeHint: "Pechar",
  timeHint: "A hora",
  eventHint: "Evento"
};

// node_modules/@fullcalendar/core/locales/he.js
var l33 = {
  code: "he",
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  ",
  weekText: ""
};

// node_modules/@fullcalendar/core/locales/hi.js
var l34 = {
  code: "hi",
  week: {
    dow: 0,
    doy: 6
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+ " + n2;
  },
  noEventsText: "      "
};

// node_modules/@fullcalendar/core/locales/hr.js
var l35 = {
  code: "hr",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "Prijanji",
    next: "Sljedei",
    today: "Danas",
    year: "Godina",
    month: "Mjesec",
    week: "Tjedan",
    day: "Dan",
    list: "Raspored"
  },
  weekText: "Tje",
  allDayText: "Cijeli dan",
  moreLinkText(n2) {
    return "+ jo " + n2;
  },
  noEventsText: "Nema dogaaja za prikaz"
};

// node_modules/@fullcalendar/core/locales/hu.js
var l36 = {
  code: "hu",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "vissza",
    next: "elre",
    today: "ma",
    year: "v",
    month: "Hnap",
    week: "Ht",
    day: "Nap",
    list: "Lista"
  },
  weekText: "Ht",
  allDayText: "Egsz nap",
  moreLinkText: "tovbbi",
  noEventsText: "Nincs megjelenthet esemny"
};

// node_modules/@fullcalendar/core/locales/hy-am.js
var l37 = {
  code: "hy-am",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/id.js
var l38 = {
  code: "id",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "mundur",
    next: "maju",
    today: "hari ini",
    year: "Tahun",
    month: "Bulan",
    week: "Minggu",
    day: "Hari",
    list: "Agenda"
  },
  weekText: "Mg",
  allDayText: "Sehari penuh",
  moreLinkText: "lebih",
  noEventsText: "Tidak ada acara untuk ditampilkan"
};

// node_modules/@fullcalendar/core/locales/is.js
var l39 = {
  code: "is",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Fyrri",
    next: "Nsti",
    today: " dag",
    year: "r",
    month: "Mnuur",
    week: "Vika",
    day: "Dagur",
    list: "Dagskr"
  },
  weekText: "Vika",
  allDayText: "Allan daginn",
  moreLinkText: "meira",
  noEventsText: "Engir viburir til a sna"
};

// node_modules/@fullcalendar/core/locales/it.js
var l40 = {
  code: "it",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Prec",
    next: "Succ",
    today: "Oggi",
    year: "Anno",
    month: "Mese",
    week: "Settimana",
    day: "Giorno",
    list: "Agenda"
  },
  weekText: "Sm",
  allDayText: "Tutto il giorno",
  moreLinkText(n2) {
    return "+altri " + n2;
  },
  noEventsText: "Non ci sono eventi da visualizzare"
};

// node_modules/@fullcalendar/core/locales/ja.js
var l41 = {
  code: "ja",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText(n2) {
    return " " + n2 + " ";
  },
  noEventsText: ""
};

// node_modules/@fullcalendar/core/locales/ka.js
var l42 = {
  code: "ka",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/kk.js
var l43 = {
  code: "kk",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/km.js
var l44 = {
  code: "km",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: "",
  noEventsText: ""
};

// node_modules/@fullcalendar/core/locales/ko.js
var l45 = {
  code: "ko",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: "",
  noEventsText: " "
};

// node_modules/@fullcalendar/core/locales/ku.js
var l46 = {
  code: "ku",
  week: {
    dow: 6,
    doy: 12
  },
  direction: "rtl",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText: "",
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/lb.js
var l47 = {
  code: "lb",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Zrck",
    next: "Weider",
    today: "Haut",
    year: "Joer",
    month: "Mount",
    week: "Woch",
    day: "Dag",
    list: "Terminiwwersiicht"
  },
  weekText: "W",
  allDayText: "Ganzen Dag",
  moreLinkText: "mi",
  noEventsText: "Nee Evenementer ze affichieren"
};

// node_modules/@fullcalendar/core/locales/lt.js
var l48 = {
  code: "lt",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Atgal",
    next: "Pirmyn",
    today: "iandien",
    year: "Metai",
    month: "Mnuo",
    week: "Savait",
    day: "Diena",
    list: "Darbotvark"
  },
  weekText: "SAV",
  allDayText: "Vis dien",
  moreLinkText: "daugiau",
  noEventsText: "Nra vyki rodyti"
};

// node_modules/@fullcalendar/core/locales/lv.js
var l49 = {
  code: "lv",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Iepr.",
    next: "Nk.",
    today: "odien",
    year: "Gads",
    month: "Mnesis",
    week: "Neda",
    day: "Diena",
    list: "Dienas krtba"
  },
  weekText: "Ned.",
  allDayText: "Visu dienu",
  moreLinkText(n2) {
    return "+vl " + n2;
  },
  noEventsText: "Nav notikumu"
};

// node_modules/@fullcalendar/core/locales/mk.js
var l50 = {
  code: "mk",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+ " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/ms.js
var l51 = {
  code: "ms",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "Sebelum",
    next: "Selepas",
    today: "hari ini",
    year: "Tahun",
    month: "Bulan",
    week: "Minggu",
    day: "Hari",
    list: "Agenda"
  },
  weekText: "Mg",
  allDayText: "Sepanjang hari",
  moreLinkText(n2) {
    return "masih ada " + n2 + " acara";
  },
  noEventsText: "Tiada peristiwa untuk dipaparkan"
};

// node_modules/@fullcalendar/core/locales/nb.js
var l52 = {
  code: "nb",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Forrige",
    next: "Neste",
    today: "I dag",
    year: "r",
    month: "Mned",
    week: "Uke",
    day: "Dag",
    list: "Agenda"
  },
  weekText: "Uke",
  weekTextLong: "Uke",
  allDayText: "Hele dagen",
  moreLinkText: "til",
  noEventsText: "Ingen hendelser  vise",
  buttonHints: {
    prev: "Forrige $0",
    next: "Neste $0",
    today: "Nvrende $0"
  },
  viewHint: "$0 visning",
  navLinkHint: "G til $0",
  moreLinkHint(eventCnt) {
    return `Vis ${eventCnt} flere hendelse${eventCnt === 1 ? "" : "r"}`;
  }
};

// node_modules/@fullcalendar/core/locales/ne.js
var l53 = {
  code: "ne",
  week: {
    dow: 7,
    doy: 1
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: " ",
  noEventsText: "    "
};

// node_modules/@fullcalendar/core/locales/nl.js
var l54 = {
  code: "nl",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Vorige",
    next: "Volgende",
    today: "Vandaag",
    year: "Jaar",
    month: "Maand",
    week: "Week",
    day: "Dag",
    list: "Lijst"
  },
  allDayText: "Hele dag",
  moreLinkText: "extra",
  noEventsText: "Geen evenementen om te laten zien"
};

// node_modules/@fullcalendar/core/locales/nn.js
var l55 = {
  code: "nn",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Frre",
    next: "Neste",
    today: "I dag",
    year: "r",
    month: "Mnad",
    week: "Veke",
    day: "Dag",
    list: "Agenda"
  },
  weekText: "Veke",
  allDayText: "Heile dagen",
  moreLinkText: "til",
  noEventsText: "Ingen hendelser  vise"
};

// node_modules/@fullcalendar/core/locales/pl.js
var l56 = {
  code: "pl",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Poprzedni",
    next: "Nastpny",
    today: "Dzi",
    year: "Rok",
    month: "Miesic",
    week: "Tydzie",
    day: "Dzie",
    list: "Plan dnia"
  },
  weekText: "Tydz",
  allDayText: "Cay dzie",
  moreLinkText: "wicej",
  noEventsText: "Brak wydarze do wywietlenia"
};

// node_modules/@fullcalendar/core/locales/pt-br.js
var l57 = {
  code: "pt-br",
  buttonText: {
    prev: "Anterior",
    next: "Prximo",
    prevYear: "Ano anterior",
    nextYear: "Prximo ano",
    year: "Ano",
    today: "Hoje",
    month: "Ms",
    week: "Semana",
    day: "Dia",
    list: "Lista"
  },
  buttonHints: {
    prev: "$0 Anterior",
    next: "Prximo $0",
    today(buttonText) {
      return buttonText === "Dia" ? "Hoje" : (buttonText === "Semana" ? "Esta" : "Este") + " " + buttonText.toLocaleLowerCase();
    }
  },
  viewHint(buttonText) {
    return "Visualizar " + (buttonText === "Semana" ? "a" : "o") + " " + buttonText.toLocaleLowerCase();
  },
  weekText: "Sm",
  weekTextLong: "Semana",
  allDayText: "dia inteiro",
  moreLinkText(n2) {
    return "mais +" + n2;
  },
  moreLinkHint(eventCnt) {
    return `Mostrar mais ${eventCnt} eventos`;
  },
  noEventsText: "No h eventos para mostrar",
  navLinkHint: "Ir para $0",
  closeHint: "Fechar",
  timeHint: "A hora",
  eventHint: "Evento"
};

// node_modules/@fullcalendar/core/locales/pt.js
var l58 = {
  code: "pt",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Anterior",
    next: "Seguinte",
    today: "Hoje",
    year: "Ano",
    month: "Ms",
    week: "Semana",
    day: "Dia",
    list: "Agenda"
  },
  weekText: "Sem",
  allDayText: "Todo o dia",
  moreLinkText: "mais",
  noEventsText: "No h eventos para mostrar"
};

// node_modules/@fullcalendar/core/locales/ro.js
var l59 = {
  code: "ro",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "precedent",
    next: "urmtoare",
    today: "Azi",
    year: "An",
    month: "Lun",
    week: "Sptmn",
    day: "Zi",
    list: "Agend"
  },
  weekText: "Spt",
  allDayText: "Toat ziua",
  moreLinkText(n2) {
    return "+alte " + n2;
  },
  noEventsText: "Nu exist evenimente de afiat"
};

// node_modules/@fullcalendar/core/locales/ru.js
var l60 = {
  code: "ru",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/si-lk.js
var l61 = {
  code: "si-lk",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: "",
  noEventsText: " "
};

// node_modules/@fullcalendar/core/locales/sk.js
var l62 = {
  code: "sk",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Predchdzajci",
    next: "Nasledujci",
    today: "Dnes",
    year: "Rok",
    month: "Mesiac",
    week: "Tde",
    day: "De",
    list: "Rozvrh"
  },
  weekText: "Ty",
  allDayText: "Cel de",
  moreLinkText(n2) {
    return "+alie: " + n2;
  },
  noEventsText: "iadne akcie na zobrazenie"
};

// node_modules/@fullcalendar/core/locales/sl.js
var l63 = {
  code: "sl",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "Prejnji",
    next: "Naslednji",
    today: "Trenutni",
    year: "Leto",
    month: "Mesec",
    week: "Teden",
    day: "Dan",
    list: "Dnevni red"
  },
  weekText: "Teden",
  allDayText: "Ves dan",
  moreLinkText: "ve",
  noEventsText: "Ni dogodkov za prikaz"
};

// node_modules/@fullcalendar/core/locales/sm.js
var l64 = {
  code: "sm",
  buttonText: {
    prev: "Talu ai",
    next: "Mulimuli atu",
    today: "Aso nei",
    year: "Tausaga",
    month: "Masina",
    week: "Vaiaso",
    day: "Aso",
    list: "Faasologa"
  },
  weekText: "Vaiaso",
  allDayText: "Aso atoa",
  moreLinkText: "sili atu",
  noEventsText: "Leai ni mea na tutupu"
};

// node_modules/@fullcalendar/core/locales/sq.js
var l65 = {
  code: "sq",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "mbrapa",
    next: "Prpara",
    today: "Sot",
    year: "Viti",
    month: "Muaj",
    week: "Jav",
    day: "Dit",
    list: "List"
  },
  weekText: "Ja",
  allDayText: "Gjith ditn",
  moreLinkText(n2) {
    return "+m tepr " + n2;
  },
  noEventsText: "Nuk ka evente pr t shfaqur"
};

// node_modules/@fullcalendar/core/locales/sr-cyrl.js
var l66 = {
  code: "sr-cyrl",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/sr.js
var l67 = {
  code: "sr",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "Prethodna",
    next: "Sledeci",
    today: "Danas",
    year: "Godina",
    month: "Msc",
    week: "Ndlja",
    day: "Dan",
    list: "Planr"
  },
  weekText: "Sed",
  allDayText: "Co dan",
  moreLinkText(n2) {
    return "+ jo " + n2;
  },
  noEventsText: "Nma dogaaja za prikaz"
};

// node_modules/@fullcalendar/core/locales/sv.js
var l68 = {
  code: "sv",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Frra",
    next: "Nsta",
    today: "Idag",
    year: "r",
    month: "Mnad",
    week: "Vecka",
    day: "Dag",
    list: "Program"
  },
  buttonHints: {
    prev(buttonText) {
      return `Fregende ${buttonText.toLocaleLowerCase()}`;
    },
    next(buttonText) {
      return `Nsta ${buttonText.toLocaleLowerCase()}`;
    },
    today(buttonText) {
      return (buttonText === "Program" ? "Detta" : "Denna") + " " + buttonText.toLocaleLowerCase();
    }
  },
  viewHint: "$0 vy",
  navLinkHint: "G till $0",
  moreLinkHint(eventCnt) {
    return `Visa ytterligare ${eventCnt} hndelse${eventCnt === 1 ? "" : "r"}`;
  },
  weekText: "v.",
  weekTextLong: "Vecka",
  allDayText: "Heldag",
  moreLinkText: "till",
  noEventsText: "Inga hndelser att visa",
  closeHint: "Stng",
  timeHint: "Klockan",
  eventHint: "Hndelse"
};

// node_modules/@fullcalendar/core/locales/ta-in.js
var l69 = {
  code: "ta-in",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "  "
};

// node_modules/@fullcalendar/core/locales/th.js
var l70 = {
  code: "th",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    prevYear: "",
    nextYear: "",
    year: "",
    today: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: "",
  noEventsText: ""
};

// node_modules/@fullcalendar/core/locales/tr.js
var l71 = {
  code: "tr",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "geri",
    next: "ileri",
    today: "bugn",
    year: "Yl",
    month: "Ay",
    week: "Hafta",
    day: "Gn",
    list: "Ajanda"
  },
  weekText: "Hf",
  allDayText: "Tm gn",
  moreLinkText: "daha fazla",
  noEventsText: "Gsterilecek etkinlik yok"
};

// node_modules/@fullcalendar/core/locales/ug.js
var l72 = {
  code: "ug",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  allDayText: " "
};

// node_modules/@fullcalendar/core/locales/uk.js
var l73 = {
  code: "uk",
  week: {
    dow: 1,
    doy: 7
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+ " + n2 + "...";
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/uz-cy.js
var l74 = {
  code: "uz-cy",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    month: "",
    week: "",
    day: "",
    list: " "
  },
  weekText: "",
  allDayText: " ",
  moreLinkText(n2) {
    return "+  " + n2;
  },
  noEventsText: "   "
};

// node_modules/@fullcalendar/core/locales/uz.js
var l75 = {
  code: "uz",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Oldingi",
    next: "Keyingi",
    today: "Bugun",
    year: "Yil",
    month: "Oy",
    week: "Xafta",
    day: "Kun",
    list: "Kun tartibi"
  },
  allDayText: "Kun bo'yi",
  moreLinkText(n2) {
    return "+ yana " + n2;
  },
  noEventsText: "Ko'rsatish uchun voqealar yo'q"
};

// node_modules/@fullcalendar/core/locales/vi.js
var l76 = {
  code: "vi",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "Trc",
    next: "Tip",
    today: "Hm nay",
    year: "Nm",
    month: "Thng",
    week: "Tun",
    day: "Ngy",
    list: "Lch biu"
  },
  weekText: "Tu",
  allDayText: "C ngy",
  moreLinkText(n2) {
    return "+ thm " + n2;
  },
  noEventsText: "Khng c s kin  hin th"
};

// node_modules/@fullcalendar/core/locales/zh-cn.js
var l77 = {
  code: "zh-cn",
  week: {
    dow: 1,
    doy: 4
  },
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText(n2) {
    return " " + n2 + " ";
  },
  noEventsText: ""
};

// node_modules/@fullcalendar/core/locales/zh-tw.js
var l78 = {
  code: "zh-tw",
  buttonText: {
    prev: "",
    next: "",
    today: "",
    year: "",
    month: "",
    week: "",
    day: "",
    list: ""
  },
  weekText: "",
  allDayText: "",
  moreLinkText: "",
  noEventsText: ""
};

// node_modules/@fullcalendar/core/locales-all.js
var localesAll = [
  l0,
  l1,
  l22,
  l3,
  l4,
  l5,
  l6,
  l7,
  l8,
  l9,
  l10,
  l11,
  l12,
  l13,
  l14,
  l15,
  l16,
  l17,
  l18,
  l19,
  l20,
  l21,
  l222,
  l23,
  l24,
  l25,
  l26,
  l27,
  l28,
  l29,
  l30,
  l31,
  l32,
  l33,
  l34,
  l35,
  l36,
  l37,
  l38,
  l39,
  l40,
  l41,
  l42,
  l43,
  l44,
  l45,
  l46,
  l47,
  l48,
  l49,
  l50,
  l51,
  l52,
  l53,
  l54,
  l55,
  l56,
  l57,
  l58,
  l59,
  l60,
  l61,
  l62,
  l63,
  l64,
  l65,
  l66,
  l67,
  l68,
  l69,
  l70,
  l71,
  l72,
  l73,
  l74,
  l75,
  l76,
  l77,
  l78
];
// node_modules/@fullcalendar/interaction/index.js
config2.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;

class PointerDragging {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter;
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
}
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config2.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}

class ElementMirror {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  stop(needsRevertAnimation, callback) {
    let done = () => {
      this.cleanup();
      callback();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms," + "left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
}

class ScrollGeomCache extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {}
}

class ElementScrollGeomCache extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
}

class WindowScrollGeomCache extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController, doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
}
var getTime = typeof performance === "function" ? performance.now : Date.now;

class AutoScroller {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now3 = getTime();
          this.handleSide(edge, (now3 - this.msSinceRequest) / 1000);
          this.requestAnimation(now3);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now3) {
    this.msSinceRequest = now3;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds2) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * this.maxVelocity * seconds2;
    let sign2 = 1;
    switch (edge.name) {
      case "left":
        sign2 = -1;
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign2);
        break;
      case "top":
        sign2 = -1;
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign2);
        break;
    }
  }
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
}

class FeaturefulElementDragging extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror;
    this.autoScroller = new AutoScroller;
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
}

class OffsetTracker {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
}
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}

class HitDragging {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter;
  }
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id2 in offsetTrackers) {
      offsetTrackers[id2].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id2 in droppableStore) {
      let component = droppableStore[id2].component;
      let offsetTracker = offsetTrackers[id2];
      if (offsetTracker && offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(positionLeft + originLeft - window.scrollX, positionTop + originTop - window.scrollY))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id2;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
}
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}

class DateClicking extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
          context.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
}

class DateSelecting extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
}
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}

class EventDragging extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid2 = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid2);
      this.isDragging = isValid2 && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
}
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}

class EventResizing extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert() {
            context.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
            });
          }
        };
        context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration2(0), endDelta: this.validMutation.endDelta || createDuration2(0), jsEvent: ev.origEvent, view: context.viewApi }));
        context.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
}
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}

class UnselectAuto {
  constructor(context) {
    this.context = context;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context2 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context2.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && !this.isRecentPointerDateSelect) {
          let unselectAuto = context2.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context2.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && !this.matchesEvent) {
          context2.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
}
var OPTION_REFINERS = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
config2.dataAttrPrefix = "";
var index = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS,
  listenerRefiners: LISTENER_REFINERS
});

// node_modules/@fullcalendar/daygrid/internal.js
class TableView extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(ViewContainer, { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec }, y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections }));
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(ViewContainer, { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec }, y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections }));
  }
}
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i3 = 0;i3 < rowCnt; i3 += 1) {
    byRow[i3] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i3 = 0;i3 < colCnt; i3 += 1) {
    byCol[i3] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0;i3 < rowCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0;i3 < rowCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display } = seg.eventRange.ui;
  return display === "list-item" || display === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && seg.isStart && seg.isEnd;
}

class TableBlockEvent extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
}

class TableListItemEvent extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
}
function renderInnerContent2(renderProps) {
  return y(_, null, y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }), renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText), y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "")));
}

class TableCellMoreLink extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
}
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });

class TableCell extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context, props, state, rootElRef } = this;
    let { options, dateEnv } = context;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y("div", { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } }, props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }), !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y("div", { className: "fc-daygrid-day-top" }, y(InnerContent, { elTag: "a", elClasses: [
      "fc-daygrid-day-number",
      isMonthStart && "fc-daygrid-month-start"
    ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })) : props.showDayNumber ? y("div", { className: "fc-daygrid-day-top", style: { visibility: "hidden" } }, y("a", { className: "fc-daygrid-day-number" }, "")) : undefined, y("div", { className: "fc-daygrid-day-events", ref: props.fgContentElRef }, props.fgContent, y("div", { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } }, y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange }))), y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)));
  }
}
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(date.valueOf() === currentStart.valueOf() || dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf());
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i3 = 0;i3 < segs.length; i3 += 1) {
    let seg = segs[i3];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i3,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol;col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0;col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start;col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0;col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0;col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0;col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start;col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}

class DayGridSegHierarchy extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0;level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
}

class TableRow extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap;
    this.frameElRefs = new RefMap;
    this.fgElRefs = new RefMap;
    this.segHarnessRefs = new RefMap;
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};
    return y("tr", { ref: this.rootElRef, role: "row" }, props.renderIntro && props.renderIntro(), props.cells.map((cell, col) => {
      let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
      let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
      return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: y(_, null, y(_, null, normalFgNodes), y(_, null, mirrorFgNodes)), bgContent: y(_, null, this.renderFillSegs(highlightSegsByCol[col], "highlight"), this.renderFillSegs(businessHoursByCol[col], "non-business"), this.renderFillSegs(bgEventSegsByCol[col], "bg-event")), minHeight: props.cellMinHeight });
    }));
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(originEl, frameEls, true, false);
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(originEl, frameEls, true, false)
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
}
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}

class TableRows extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitAllDaySegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap;
  }
  render() {
    let { props, context } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row],
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  prepareHits() {
    this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]), false, true);
    this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start3 = this.props.cells[row][col].date;
    let end = addDays(start3, 1);
    return { start: start3, end };
  }
}
function splitAllDaySegsByRow(segs, rowCnt) {
  return splitSegsByRow(segs.filter(isSegAllDay), rowCnt);
}
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}

class Table extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
    ];
    return y("div", { ref: this.elRef, className: classNames.join(" "), style: {
      width: props.clientWidth,
      minWidth: props.tableMinWidth
    } }, y("table", { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
      width: props.clientWidth,
      minWidth: props.tableMinWidth,
      height: expandRows ? props.clientHeight : ""
    } }, props.colGroupNode, y("tbody", { role: "presentation" }, y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed }))));
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
}
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}

class DayTableSlicer extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
}

class DayTable extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer;
    this.tableRef = d();
  }
  render() {
    let { props, context } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
}

class DayTableView extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
}
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}

class TableDateProfileGenerator extends DateProfileGenerator {
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
}
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start: start3, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start3 = dateEnv.startOfWeek(start3);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(diffWeeks(lastMonthRenderStart, end));
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start: start3, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index2 = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// app/javascript/controllers/calendar_controller.js
var import_sweetalert22 = __toESM(require_sweetalert2_all(), 1);

class calendar_controller_default extends Controller {
  static targets = ["calendar"];
  connect() {
    if (this.hasCalendarTarget) {
      var calendar2 = this.Calendar();
      calendar2.render();
    }
  }
  Calendar(target = this.calendarTarget) {
    const url = target.dataset.calendarUrl;
    const cal = new Calendar(target, {
      plugins: [index, index2],
      selectable: target.classList.contains("editable"),
      editable: target.classList.contains("editable"),
      aspectRatio: 1.5,
      locales: localesAll,
      locale: document.documentElement.lang,
      events: `${url}/agenda.json`,
      eventClick: async (info) => {
        info.jsEvent.preventDefault();
        if (info.event.url) {
          const response = await get(`${info.event.url}`);
          if (!response.ok)
            throw new Error("Errore nella richiesta");
          this.send(await response.text);
        }
      }
    });
    return cal;
  }
  reload(event) {
    var calendar2;
    if (this.hasCalendarTarget) {
      calendar2 = this.calendarTarget;
    } else {
      calendar2 = document.getElementById("calendar");
    }
    calendar2.innerHTML = "";
    calendar2 = this.Calendar(calendar2);
    return calendar2.render();
  }
  send(body = "") {
    var options;
    options = {
      width: "70%",
      heightAuto: true,
      height: true,
      toast: false,
      icon: false,
      timerProgressBar: false,
      position: "center",
      title: false,
      html: body,
      footer: false,
      timer: false,
      showConfirmButton: false,
      showCloseButton: true,
      showCancelButton: false,
      cancelButtonText: "Chiudi",
      showClass: {
        popup: "animated fadeIn"
      },
      hideClass: {
        popup: ""
      }
    };
    if (import_sweetalert22.default.isVisible()) {
      import_sweetalert22.default.update(options);
    } else {
      import_sweetalert22.default.fire(options);
    }
  }
}

// app/javascript/controllers/form_controller.js
var import_smart_timeout = __toESM(require_smart_timeout(), 1);
var import_sweetalert23 = __toESM(require_sweetalert2_all(), 1);

// node_modules/dual-listbox/dist/dual-listbox.js
var MAIN_BLOCK = "dual-listbox";
var CONTAINER_ELEMENT = "dual-listbox__container";
var AVAILABLE_ELEMENT = "dual-listbox__available";
var SELECTED_ELEMENT = "dual-listbox__selected";
var TITLE_ELEMENT = "dual-listbox__title";
var ITEM_ELEMENT = "dual-listbox__item";
var BUTTONS_ELEMENT = "dual-listbox__buttons";
var BUTTON_ELEMENT = "dual-listbox__button";
var SEARCH_ELEMENT = "dual-listbox__search";
var SELECTED_MODIFIER = "dual-listbox__item--selected";
var DIRECTION_UP = "up";
var DIRECTION_DOWN = "down";

class DualListbox {
  constructor(selector, options = {}) {
    this.setDefaults();
    this.dragged = null;
    this.options = [];
    this.selectedItems = new Set;
    this.lastSelected = null;
    this.searchTermLeft = "";
    this.searchTermRight = "";
    if (DualListbox.isDomElement(selector)) {
      this.select = selector;
    } else {
      this.select = document.querySelector(selector);
    }
    this._initOptions(options);
    this._initReusableElements();
    if (options.options !== undefined) {
      this.options = options.options;
    } else {
      this._splitOptions(this.select.options);
    }
    this._buildDualListbox(this.select.parentNode);
    this._addActions();
    if (this.showSortButtons) {
      this._initializeSortButtons();
    }
    this.redraw();
  }
  setDefaults() {
    this.availableTitle = "Available options";
    this.selectedTitle = "Selected options";
    this.showAddButton = true;
    this.addButtonText = "add";
    this.showRemoveButton = true;
    this.removeButtonText = "remove";
    this.showAddAllButton = true;
    this.addAllButtonText = "add all";
    this.showRemoveAllButton = true;
    this.removeAllButtonText = "remove all";
    this.searchPlaceholder = "Search";
    this.showSortButtons = false;
    this.sortFunction = (a3, b3) => 0;
    this.upButtonText = "up";
    this.downButtonText = "down";
    this.enableDoubleClick = true;
    this.draggable = true;
    this.multiSelect = true;
  }
  changeOrder(items, newPosition) {
    if (!Array.isArray(items)) {
      items = [items];
    }
    const itemsWithIndices = items.map((item) => ({
      item,
      index: this.options.findIndex((opt) => opt.value === item.dataset.id)
    })).sort((a3, b3) => a3.index - b3.index);
    const removedItems = itemsWithIndices.map(({ item, index: index3 }) => this.options.splice(index3, 1)[0]);
    this.options.splice(newPosition, 0, ...removedItems);
  }
  addOptions(options) {
    options.forEach((option) => {
      this.addOption(option);
    });
  }
  addOption(option, index3 = null) {
    if (index3 !== null) {
      this.options.splice(index3, 0, option);
    } else {
      this.options.push(option);
    }
  }
  addEventListener(eventName, callback) {
    this.dualListbox.addEventListener(eventName, callback);
  }
  toggleSelection(listItem, event) {
    if (this.multiSelect && (event.ctrlKey || event.metaKey)) {
      if (this.selectedItems.has(listItem)) {
        this.selectedItems.delete(listItem);
        listItem.classList.remove(SELECTED_MODIFIER);
      } else {
        this.selectedItems.add(listItem);
        listItem.classList.add(SELECTED_MODIFIER);
      }
    } else if (this.multiSelect && event.shiftKey && this.lastSelected) {
      const items = Array.from(listItem.parentElement.children);
      const currentIndex = items.indexOf(listItem);
      const lastIndex = items.indexOf(this.lastSelected);
      const [start3, end] = [Math.min(currentIndex, lastIndex), Math.max(currentIndex, lastIndex)];
      this.selectedItems.clear();
      items.forEach((item) => item.classList.remove(SELECTED_MODIFIER));
      for (let i3 = start3;i3 <= end; i3++) {
        this.selectedItems.add(items[i3]);
        items[i3].classList.add(SELECTED_MODIFIER);
      }
    } else {
      this.selectedItems.clear();
      listItem.parentElement.querySelectorAll(`.${ITEM_ELEMENT}`).forEach((item) => {
        item.classList.remove(SELECTED_MODIFIER);
      });
      this.selectedItems.add(listItem);
      listItem.classList.add(SELECTED_MODIFIER);
    }
    this.lastSelected = listItem;
  }
  changeSelected(items) {
    if (!Array.isArray(items)) {
      items = [items];
    }
    items = items.filter((item) => item != null);
    if (items.length === 0) {
      return;
    }
    const isSelecting = items[0].parentElement?.classList.contains(AVAILABLE_ELEMENT) ?? false;
    items.forEach((listItem) => {
      const changeOption = this.options.find((option) => option.value === listItem.dataset.id);
      if (changeOption) {
        changeOption.selected = !changeOption.selected;
      }
    });
    this.redraw();
    setTimeout(() => {
      let event = document.createEvent("HTMLEvents");
      event.initEvent(isSelecting ? "added" : "removed", false, true);
      event.affectedElements = items;
      this.dualListbox.dispatchEvent(event);
    }, 0);
  }
  _getVisibleItems(list) {
    return Array.from(list.querySelectorAll(`.${ITEM_ELEMENT}`)).filter((item) => item.style.display !== "none").map((item) => item.dataset.id);
  }
  actionAllSelected(event) {
    if (event) {
      event.preventDefault();
    }
    const visibleIds = this._getVisibleItems(this.availableList);
    this.options.forEach((option) => {
      if (visibleIds.includes(option.value)) {
        option.selected = true;
      }
    });
    this.redraw();
  }
  actionAllDeselected(event) {
    if (event) {
      event.preventDefault();
    }
    const visibleIds = this._getVisibleItems(this.selectedList);
    this.options.forEach((option) => {
      if (visibleIds.includes(option.value)) {
        option.selected = false;
      }
    });
    this.redraw();
  }
  actionItemSelected(event) {
    event.preventDefault();
    const selected = Array.from(this.selectedItems).filter((item) => item.parentElement.classList.contains(AVAILABLE_ELEMENT));
    if (selected.length > 0) {
      this.changeSelected(selected);
    }
  }
  actionItemDeselected(event) {
    event.preventDefault();
    const selected = Array.from(this.selectedItems).filter((item) => item.parentElement.classList.contains(SELECTED_ELEMENT));
    if (selected.length > 0) {
      this.changeSelected(selected);
    }
  }
  redraw() {
    this.updateAvailableListbox();
    this.updateSelectedListbox();
    this._reapplySearchFilters();
    this.syncSelect();
  }
  searchLists(searchString, dualListbox) {
    let items = dualListbox.querySelectorAll(`.${ITEM_ELEMENT}`);
    let lowerCaseSearchString = searchString.toLowerCase();
    if (dualListbox === this.availableList) {
      this.searchTermLeft = searchString;
    } else if (dualListbox === this.selectedList) {
      this.searchTermRight = searchString;
    }
    this._applySearchFilter(items, lowerCaseSearchString);
  }
  _applySearchFilter(items, searchString) {
    for (let i3 = 0;i3 < items.length; i3++) {
      let item = items[i3];
      if (searchString && item.textContent.toLowerCase().indexOf(searchString) === -1) {
        item.style.display = "none";
      } else {
        item.style.display = "list-item";
      }
    }
  }
  _reapplySearchFilters() {
    if (this.searchTermLeft) {
      this._applySearchFilter(this.availableList.querySelectorAll(`.${ITEM_ELEMENT}`), this.searchTermLeft.toLowerCase());
    }
    if (this.searchTermRight) {
      this._applySearchFilter(this.selectedList.querySelectorAll(`.${ITEM_ELEMENT}`), this.searchTermRight.toLowerCase());
    }
  }
  updateAvailableListbox() {
    this._updateListbox(this.availableList, this.options.filter((option) => !option.selected));
  }
  updateSelectedListbox() {
    this._updateListbox(this.selectedList, this.options.filter((option) => option.selected));
  }
  syncSelect() {
    while (this.select.firstChild) {
      this.select.removeChild(this.select.lastChild);
    }
    this.options.forEach((option) => {
      let optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.innerText = option.text;
      if (option.selected) {
        optionElement.setAttribute("selected", "selected");
      }
      this.select.appendChild(optionElement);
    });
  }
  _updateListbox(list, options) {
    while (list.firstChild) {
      list.removeChild(list.firstChild);
    }
    options.forEach((option) => {
      list.appendChild(this._createListItem(option));
    });
  }
  _addActions() {
    this._addButtonActions();
    this._addSearchActions();
  }
  _addButtonActions() {
    this.add_all_button.addEventListener("click", (event) => this.actionAllSelected(event));
    this.add_button.addEventListener("click", (event) => this.actionItemSelected(event));
    this.remove_button.addEventListener("click", (event) => this.actionItemDeselected(event));
    this.remove_all_button.addEventListener("click", (event) => this.actionAllDeselected(event));
  }
  _addSearchActions() {
    this.search_left.addEventListener("input", (event) => this.searchLists(event.target.value, this.availableList));
    this.search_right.addEventListener("input", (event) => this.searchLists(event.target.value, this.selectedList));
  }
  _addClickActions(listItem) {
    listItem.addEventListener("dblclick", (event) => {
      if (this.enableDoubleClick) {
        event.preventDefault();
        event.stopPropagation();
        this.changeSelected([listItem]);
      }
    });
    listItem.addEventListener("click", (event) => {
      event.preventDefault();
      this.toggleSelection(listItem, event);
    });
    return listItem;
  }
  _buildDualListbox(container) {
    this.select.style.display = "none";
    const leftSearch = this._createSearchLeft();
    const rightSearch = this._createSearchRight();
    this.dualListBoxContainer.appendChild(this._createList(leftSearch, this.availableListTitle, this.availableList));
    this.dualListBoxContainer.appendChild(this.buttons);
    this.dualListBoxContainer.appendChild(this._createList(rightSearch, this.selectedListTitle, this.selectedList));
    this.dualListbox.appendChild(this.dualListBoxContainer);
    container.insertBefore(this.dualListbox, this.select);
  }
  _createList(search, header, list) {
    let result = document.createElement("div");
    result.appendChild(search);
    result.appendChild(header);
    result.appendChild(list);
    return result;
  }
  _createButtons() {
    this.buttons = document.createElement("div");
    this.buttons.classList.add(BUTTONS_ELEMENT);
    this.add_all_button = document.createElement("button");
    this.add_all_button.innerHTML = this.addAllButtonText;
    this.add_button = document.createElement("button");
    this.add_button.innerHTML = this.addButtonText;
    this.remove_button = document.createElement("button");
    this.remove_button.innerHTML = this.removeButtonText;
    this.remove_all_button = document.createElement("button");
    this.remove_all_button.innerHTML = this.removeAllButtonText;
    const options = {
      showAddAllButton: this.add_all_button,
      showAddButton: this.add_button,
      showRemoveButton: this.remove_button,
      showRemoveAllButton: this.remove_all_button
    };
    for (let optionName in options) {
      if (optionName) {
        const option = this[optionName];
        const button = options[optionName];
        button.setAttribute("type", "button");
        button.classList.add(BUTTON_ELEMENT);
        if (option) {
          this.buttons.appendChild(button);
        }
      }
    }
  }
  _createListItem(option) {
    let listItem = document.createElement("li");
    listItem.classList.add(ITEM_ELEMENT);
    listItem.innerHTML = option.text;
    listItem.dataset.id = option.value;
    this._liListeners(listItem);
    this._addClickActions(listItem);
    if (this.draggable) {
      listItem.setAttribute("draggable", "true");
    }
    return listItem;
  }
  _liListeners(li) {
    li.addEventListener("dragstart", (event) => {
      this.dragged = event.currentTarget;
      event.currentTarget.classList.add("dragging");
      if (!this.selectedItems.has(this.dragged)) {
        this.selectedItems.clear();
        this.toggleSelection(this.dragged, { ctrlKey: false });
      }
    });
    li.addEventListener("dragend", (event) => {
      event.currentTarget.classList.remove("dragging");
    });
    li.addEventListener("dragover", (event) => {
      event.preventDefault();
    });
    li.addEventListener("dragenter", (event) => {
      event.target.classList.add("drop-above");
    });
    li.addEventListener("dragleave", (event) => {
      event.target.classList.remove("drop-above");
    });
    li.addEventListener("drop", (event) => {
      event.preventDefault();
      event.stopPropagation();
      event.target.classList.remove("drop-above");
      const newIndex = this.options.findIndex((option) => option.value === event.target.dataset.id);
      const selectedItems = Array.from(this.selectedItems);
      if (event.target.parentElement === this.dragged.parentElement) {
        this.changeOrder(selectedItems, newIndex);
      } else {
        this.changeSelected(selectedItems);
        this.changeOrder(selectedItems, newIndex);
      }
      this.redraw();
    });
  }
  _createDragListeners() {
    [this.availableList, this.selectedList].forEach((dropzone) => {
      dropzone.addEventListener("dragover", (event) => {
        event.preventDefault();
      }, false);
      dropzone.addEventListener("dragenter", (event) => {
        event.target.classList.add("drop-in");
      });
      dropzone.addEventListener("dragleave", (event) => {
        event.target.classList.remove("drop-in");
      });
      dropzone.addEventListener("drop", (event) => {
        event.preventDefault();
        event.target.classList.remove("drop-in");
        if (dropzone.classList.contains(SELECTED_ELEMENT) || dropzone.classList.contains(AVAILABLE_ELEMENT)) {
          const selectedItems = Array.from(this.selectedItems);
          this.changeSelected(selectedItems);
        }
      });
    });
  }
  _createSearchWithReset(side) {
    const searchContainer = document.createElement("div");
    searchContainer.classList.add("dual-listbox__search-container");
    searchContainer.style.display = "flex";
    searchContainer.style.alignItems = "center";
    searchContainer.style.gap = "4px";
    const searchInput = document.createElement("input");
    searchInput.classList.add(SEARCH_ELEMENT);
    searchInput.placeholder = this.searchPlaceholder;
    searchInput.style.flex = "1";
    const resetButton = document.createElement("button");
    resetButton.type = "button";
    resetButton.classList.add("dual-listbox__search-reset");
    resetButton.innerHTML = "";
    resetButton.style.padding = "2px 6px";
    resetButton.style.border = "1px solid #ccc";
    resetButton.style.borderRadius = "3px";
    resetButton.style.cursor = "pointer";
    resetButton.style.backgroundColor = "#fff";
    resetButton.title = "Clear search";
    resetButton.addEventListener("click", () => {
      searchInput.value = "";
      if (side === "left") {
        this.searchTermLeft = "";
        this.searchLists("", this.availableList);
      } else {
        this.searchTermRight = "";
        this.searchLists("", this.selectedList);
      }
      searchInput.focus();
    });
    searchContainer.appendChild(searchInput);
    searchContainer.appendChild(resetButton);
    return {
      container: searchContainer,
      input: searchInput
    };
  }
  _createSearchLeft() {
    const { container, input } = this._createSearchWithReset("left");
    this.search_left = input;
    return container;
  }
  _createSearchRight() {
    const { container, input } = this._createSearchWithReset("right");
    this.search_right = input;
    return container;
  }
  _initOptions(options) {
    for (let key in options) {
      if (options.hasOwnProperty(key)) {
        this[key] = options[key];
      }
    }
  }
  _initReusableElements() {
    this.dualListbox = document.createElement("div");
    this.dualListbox.classList.add(MAIN_BLOCK);
    if (this.select.id) {
      this.dualListbox.classList.add(this.select.id);
    }
    this.dualListBoxContainer = document.createElement("div");
    this.dualListBoxContainer.classList.add(CONTAINER_ELEMENT);
    this.availableList = document.createElement("ul");
    this.availableList.classList.add(AVAILABLE_ELEMENT);
    this.selectedList = document.createElement("ul");
    this.selectedList.classList.add(SELECTED_ELEMENT);
    this.availableListTitle = document.createElement("div");
    this.availableListTitle.classList.add(TITLE_ELEMENT);
    this.availableListTitle.innerText = this.availableTitle;
    this.selectedListTitle = document.createElement("div");
    this.selectedListTitle.classList.add(TITLE_ELEMENT);
    this.selectedListTitle.innerText = this.selectedTitle;
    this._createButtons();
    this._createSearchLeft();
    this._createSearchRight();
    if (this.draggable) {
      setTimeout(() => {
        this._createDragListeners();
      }, 10);
    }
  }
  _initializeSortButtons() {
    const sortUpButton = document.createElement("button");
    sortUpButton.classList.add(BUTTON_ELEMENT);
    sortUpButton.innerText = this.upButtonText;
    sortUpButton.addEventListener("click", (event) => this._onSortButtonClick(event, DIRECTION_UP));
    const sortDownButton = document.createElement("button");
    sortDownButton.classList.add(BUTTON_ELEMENT);
    sortDownButton.innerText = this.downButtonText;
    sortDownButton.addEventListener("click", (event) => this._onSortButtonClick(event, DIRECTION_DOWN));
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add(BUTTONS_ELEMENT);
    buttonContainer.appendChild(sortUpButton);
    buttonContainer.appendChild(sortDownButton);
    this.dualListBoxContainer.appendChild(buttonContainer);
  }
  _onSortButtonClick(event, direction) {
    event.preventDefault();
    const selectedItems = Array.from(this.selectedItems);
    if (selectedItems.length > 0) {
      const indices = selectedItems.map((item) => this.options.findIndex((option) => option.value === item.dataset.id));
      const minIndex = Math.min(...indices);
      const maxIndex = Math.max(...indices);
      let newIndex = direction === DIRECTION_UP ? Math.max(0, minIndex - 1) : Math.min(this.options.length - selectedItems.length, maxIndex + 1);
      this.changeOrder(selectedItems, newIndex);
      this.redraw();
    }
  }
  _splitOptions(options) {
    [...options].forEach((option, index3) => {
      this.addOption({
        text: option.innerHTML,
        value: option.value,
        selected: option.hasAttribute("selected"),
        order: index3
      });
    });
  }
  static isDomElement(o2) {
    return typeof HTMLElement === "object" ? o2 instanceof HTMLElement : o2 && typeof o2 === "object" && o2 !== null && o2.nodeType === 1 && typeof o2.nodeName === "string";
  }
}
window.DualListbox = DualListbox;
var dual_listbox_default = DualListbox;

// app/javascript/controllers/form_controller.js
class form_controller_default extends Controller {
  static targets = ["listbox"];
  static values = {
    details: { type: String, default: "info" },
    status: { type: String, default: "close" }
  };
  connect() {
    document.querySelectorAll("[disabled]").forEach(function(obj) {
      return obj.classList.add("is-disabled");
    });
    if (this.hasListboxTarget) {
      const select = this.listboxTarget;
      return new dual_listbox_default(select, {
        availableTitle: "Categorie disponibili",
        selectedTitle: "Categorie selezionate",
        addButtonText: ">",
        removeButtonText: "<",
        addAllButtonText: ">>",
        removeAllButtonText: "<<"
      });
    }
  }
  send(event) {
    const form = event.target.closest("form");
    if (form) {
      form.requestSubmit();
    }
  }
  delayedSend(event) {
    if (import_smart_timeout.default.exists("textDelay"))
      import_smart_timeout.default.set("textDelay", true);
    return import_smart_timeout.default.set("textDelay", () => {
      return this.send(event);
    }, 750);
  }
  reset(event) {
    event.target.closest("form").reset();
  }
  close() {
    if (import_sweetalert23.default.isVisible())
      return import_sweetalert23.default.close();
  }
  toggleVisible(event) {
    document.getElementById(event.currentTarget.dataset.id).classList.toggle("is-hidden");
    if (event.currentTarget.querySelector("i.fas"))
      return event.currentTarget.querySelector("i.fas").classList.toggle("fa-chevron-down");
  }
  details(event) {
    const target = document.getElementById(this.detailsValue);
    const button = event.target;
    this.statusValue = this.statusValue === "close" ? "open" : "close";
    target?.classList.toggle("is-hidden");
    const icon = button.closest("a")?.querySelector("[data-icon]");
    if (icon) {
      const icons = ["circle-plus", "circle-minus"];
      icon.dataset.icon = icons.find((i3) => i3 !== icon.dataset.icon);
    }
  }
  async sendValue(event) {
    const target = event.target;
    const url = target.dataset.formUrl;
    const param_data = new URLSearchParams({ [target.name]: target.value });
    try {
      const response = await get(`${url}?${param_data}`);
      if (!response.ok)
        throw new Error("Errore nella richiesta");
      target.closest(".container").outerHTML = await response.text;
    } catch (error2) {
      console.error("Si  verificato un errore:", error2);
    }
  }
  focus(event) {
    if (event.currentTarget.dataset.formId) {
      const target = document.getElementById(event.currentTarget.dataset.formId);
      if (target)
        return target.scrollIntoView();
    }
  }
  async confirmation(event) {
    const target = event.target;
    const confirmation = target.dataset.formConfirmation || "";
    const url = target.dataset.formUrl;
    const icon = target.dataset.icon || "question";
    const title = target.dataset.title || "";
    const deletable = target.dataset.deletable || false;
    const form = target.closest("form");
    const options = {
      icon,
      timerProgressBar: false,
      position: "center",
      title,
      html: confirmation,
      showConfirmButton: true,
      showCancelButton: true,
      confirmButtonText: "Si",
      cancelButtonText: "No",
      showClass: {
        popup: "swal2-noanimation"
      },
      hideClass: {
        popup: ""
      }
    };
    const result = await import_sweetalert23.default.fire(options);
    if (result.isConfirmed)
      return window.location.href = url;
  }
  confirm_before_send(event) {
    const target = event.currentTarget;
    if (target.dataset.force !== "true") {
      event.preventDefault();
      event.stopPropagation();
      const icon = target.dataset.icon || "question";
      const title = target.dataset.title || "";
      const confirmation = target.dataset.confirmation;
      const deletable = target.dataset.deletable || false;
      const form = target.closest("form");
      const options = {
        icon,
        timerProgressBar: false,
        position: "center",
        title,
        html: confirmation,
        showConfirmButton: true,
        showCancelButton: true,
        confirmButtonText: "Si",
        cancelButtonText: "No",
        showClass: {
          popup: "swal2-noanimation"
        },
        hideClass: {
          popup: ""
        }
      };
      return import_sweetalert23.default.fire(options).then((result) => {
        if (result.isConfirmed) {
          if (form && form.nodeName === "FORM") {
            if (deletable)
              this.removeRow(event);
            return this.send(event);
          }
        }
      });
    }
  }
}

// app/javascript/controllers/menu_controller.js
class menu_controller_default extends Controller {
  open(event) {
    var menu, menuId;
    menuId = event.target.dataset.menuId;
    if (menuId) {
      menu = document.getElementById(menuId);
      if (menu) {
        return menu.classList.toggle("is-active");
      }
    }
  }
  close(event) {
    var menu, menuId;
    menuId = event.target.dataset.menuId;
    if (menuId) {
      menu = document.getElementById(menuId);
      if (menu) {
        return menu.classList.remove("is-active");
      }
    }
  }
}

// app/javascript/controllers/message_controller.js
var import_sweetalert24 = __toESM(require_sweetalert2_all(), 1);

class message_controller_default extends Controller {
  static targets = ["text"];
  connect() {
    if (this.hasTextTarget) {
      this.send(this.textTarget.innerHTML, this.element.dataset.messageStatus || "success", this.element.dataset.messageForce || false);
      return this.element.outerHTML = "";
    }
  }
  disconnect() {
    return this.outerHTML = "";
  }
  hidden(event) {
    var container = event.target.closest("article.message");
    if (container) {
      container.remove();
    }
  }
  send(message, level = "success", force = false, timeout = 2000, toast = true) {
    var options;
    options = {
      toast: level === "error" ? false : toast,
      theme: "bulma",
      icon: level,
      timerProgressBar: true,
      position: level === "error" ? "center" : "top-end",
      text: message,
      timer: level === "error" ? false : timeout,
      showConfirmButton: level === "error" ? true : false,
      didOpen: (toast2) => {
        toast2.addEventListener("mouseenter", import_sweetalert24.default.stopTimer);
        return toast2.addEventListener("mouseleave", import_sweetalert24.default.resumeTimer);
      },
      showClass: {
        popup: level === "error" ? "" : "animate__animated animate__bounceInRight"
      },
      hideClass: {
        popup: level === "error" ? "" : "animate__animated animate__bounceOutRight"
      }
    };
    if (import_sweetalert24.default.isVisible() && force == "true") {
      import_sweetalert24.default.fire(options);
    } else if (!import_sweetalert24.default.isVisible()) {
      import_sweetalert24.default.fire(options);
    }
  }
}

// app/javascript/controllers/modal_controller.js
var import_sweetalert25 = __toESM(require_sweetalert2_all(), 1);

class modal_controller_default extends Controller {
  connect() {
    var body;
    body = this.element.innerHTML;
    if (body) {
      this.send(body);
    }
    return this.element.outerHTML = "";
  }
  close() {
    if (import_sweetalert25.default.isVisible()) {
      return import_sweetalert25.default.close();
    }
  }
  disconnect() {
    return this.outerHTML = "";
  }
  send(body = "") {
    var options;
    options = {
      width: "70%",
      heightAuto: true,
      height: true,
      toast: false,
      icon: false,
      timerProgressBar: false,
      position: "center",
      title: false,
      html: body,
      footer: false,
      timer: false,
      showConfirmButton: false,
      showCloseButton: true,
      showCancelButton: false,
      cancelButtonText: "Chiudi",
      showClass: {
        popup: "animated fadeIn"
      },
      hideClass: {
        popup: ""
      }
    };
    if (import_sweetalert25.default.isVisible()) {
      import_sweetalert25.default.update(options);
    } else {
      import_sweetalert25.default.fire(options);
    }
  }
}

// app/javascript/controllers/users_controller.js
var import_sweetalert26 = __toESM(require_sweetalert2_all(), 1);

class users_controller_default extends Controller {
  static targets = ["container"];
  async renderUser(event, user_id = "") {
    let target, container;
    if (!user_id) {
      target = event.currentTarget;
      user_id = target.dataset.userId;
    }
    container = document.getElementById(`user_${user_id}`);
    try {
      const response = await get(`/utenti/${user_id}/utente`);
      if (!response.ok)
        throw new Error("Errore nella richiesta");
      if (container) {
        container.outerHTML = await response.text;
      }
    } catch (error2) {
      this.send("Si  verificato un errore durante il caricamento! Si prega di provare pi tardi.", "error");
    }
  }
  edit(event) {
    var btnCanc, btnSave, buttons, container, editDiv, el, form, i3, len, oldDate, opt, option, option_splitted, options, target, userId, user_id;
    target = event.target;
    if (target.classList.contains("editable")) {
      container = target.parentNode;
      userId = target.dataset.userId;
      editDiv = document.createElement("DIV");
      editDiv.id = `${userId}_editor`;
      editDiv.className = "editor";
      container.appendChild(editDiv);
      oldDate = target.text;
      if (target.dataset.hasOwnProperty("fieldType")) {
        if (target.dataset.fieldType === "textarea") {
          el = document.createElement("TEXTAREA");
          el.className = "textarea editor is-radiusless";
          el.style = "width:80%;";
          el.innerHTML = target.dataset.fieldValue;
        } else if (target.dataset.fieldType === "select") {
          el = document.createElement("SELECT");
          el.className = "select editor is-radiusless";
          el.style = "width:60%;";
          options = target.dataset.fieldOptions.split(",");
          if (target.dataset.fieldPrompt) {
            opt = document.createElement("option");
            opt.value = "";
            opt.text = target.dataset.fieldPrompt;
            if (target.dataset.fieldValue === "") {
              opt.selected = true;
            }
            el.appendChild(opt);
          }
          for (i3 = 0, len = options.length;i3 < len; i3++) {
            option = options[i3];
            opt = document.createElement("option");
            if (option.indexOf("||") >= 0) {
              option_splitted = option.split("||");
              opt.value = option_splitted[0];
              opt.text = option_splitted[1];
            } else {
              opt.value = option;
              opt.text = option;
            }
            if (option === target.dataset.fieldValue) {
              opt.selected = true;
            }
            el.appendChild(opt);
          }
        } else if (target.dataset.fieldType === "file") {
          user_id = target.dataset.userId;
          form = document.createElement("FORM");
          form.method = "post";
          form.action = `/utenti/${user_id}`;
          form.dataset.multipart = "true";
          form.dataset.remote = "";
          form.acceptCharset = "UTF-8";
          form.dataset.action = "users";
          form.dataset.controller = "users";
          form.dataset.action = "ajax:success->users#abort";
          el = document.createElement("INPUT");
          el.type = "hidden";
          el.name = "_method";
          el.value = "put";
          form.appendChild(el);
          el = document.createElement("INPUT");
          el.name = target.dataset.fieldName;
          el.type = target.dataset.fieldType;
          el.className = `input ${target.dataset.fieldType} editor is-radiusless`;
          el.style = "width:60%;";
          el.accept = target.dataset.fieldAccept || "";
          form.appendChild(el);
        } else {
          el = document.createElement("INPUT");
          el.type = target.dataset.fieldType;
          el.className = `input ${target.dataset.fieldType} editor is-radiusless`;
          el.style = "width:60%;";
          el.value = target.dataset.fieldValue;
        }
      } else {
        el = document.createElement("INPUT");
        el.className = "input editor is-radiusless";
        el.style = "width:60%;";
        el.value = target.dataset.fieldValue;
      }
      if (target.dataset.hasOwnProperty("fieldPattern")) {
        el.pattern = target.dataset.fieldPattern;
        el.addEventListener("change", (event2) => {
          if (el.validity.typeMismatch) {
            return el.setCustomValidity("Valore inserito non valido!");
          } else {
            return el.setCustomValidity("");
          }
        });
      }
      if (target.dataset.hasOwnProperty("fieldRequired")) {
        el.required = "required";
      }
      if (target.dataset.fieldType !== "file") {
        el.placeholder = target.dataset.fieldPlaceholder;
        el.name = target.dataset.fieldName;
        editDiv.appendChild(el);
        btnSave = document.createElement("BUTTON");
        btnSave.innerHTML = `<i class='fa fa-save' style=${target.dataset.fieldType === "textarea" ? "" : "padding-right:0px"}></i>${target.dataset.fieldType === "textarea" ? " Salva" : ""}`;
        btnSave.className = "button tooltip is-transparent is-borderless is-radiusless";
        btnSave.dataset.tooltip = "Salva";
        btnSave.dataset.controller = "users";
        btnSave.dataset.action = "click->users#update";
        btnSave.dataset.userId = userId;
        editDiv.appendChild(btnSave);
        btnCanc = document.createElement("BUTTON");
        btnCanc.innerHTML = `<i class='fa fa-times' style=${target.dataset.fieldType === "textarea" ? "" : "padding-right:0px"}></i>${target.dataset.fieldType === "textarea" ? " Annulla" : ""}`;
        btnCanc.className = "button tooltip is-transparent is-borderless is-radiusless";
        btnCanc.dataset.tooltip = "Annulla";
        btnCanc.dataset.controller = "users";
        btnCanc.dataset.action = "click->users#abort";
        editDiv.appendChild(btnCanc);
      } else {
        if (form) {
          buttons = document.createElement("DIV");
          buttons.className = "buttons";
          btnSave = document.createElement("BUTTON");
          btnSave.innerHTML = `<i class='fa fa-save' style=${target.dataset.fieldType === "textarea" ? "" : "padding-right:0px"}></i>${target.dataset.fieldType === "textarea" ? " Salva" : ""}`;
          btnSave.className = "button tooltip is-transparent is-borderless is-radiusless";
          btnSave.dataset.tooltip = "Salva";
          btnSave.type = "submit";
          btnSave.dataset.userId = userId;
          buttons.appendChild(btnSave);
          btnCanc = document.createElement("BUTTON");
          btnCanc.innerHTML = `<i class='fa fa-times' style=${target.dataset.fieldType === "textarea" ? "" : "padding-right:0px"}></i>${target.dataset.fieldType === "textarea" ? " Annulla" : ""}`;
          btnCanc.className = "button tooltip is-transparent is-borderless is-radiusless";
          btnCanc.dataset.tooltip = "Annulla";
          btnCanc.dataset.controller = "users";
          btnCanc.dataset.action = "click->users#abort";
          buttons.appendChild(btnCanc);
          form.appendChild(buttons);
          editDiv.appendChild(form);
        }
      }
      return target.classList.add("is-hidden");
    }
  }
  async update(event) {
    var container, editor, input, link, target, url, user_id, value;
    target = event.currentTarget;
    editor = target.parentNode;
    container = editor.parentNode;
    link = container.querySelector(".editable");
    input = editor.querySelector(".editor");
    value = input.value;
    user_id = target.dataset.userId;
    url = `/utenti/${user_id}`;
    if (input.checkValidity()) {
      try {
        const body = new URLSearchParams({ [input.name]: value }).toString();
        const response = await put(url, { body, contentType: "application/x-www-form-urlencoded; charset=UTF-8" });
        if (!response.ok)
          throw response;
        this.send("Salvataggio avvenuto correttamente!");
        this.removeElement(target);
        if (link.dataset.fieldType === "date") {
          value = new Date(value).toLocaleDateString(window.navigator.language || "it", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric"
          });
        } else if (link.dataset.fieldType === "password") {
          value = "*********";
        }
        return link.innerHTML = value !== "" ? value : link.dataset.fieldPlaceholder ? link.dataset.fieldPlaceholder : "aggiungi";
      } catch (error2) {
        var text = "Si  verificato un errore durante il salvataggio!";
        try {
          if (error2 instanceof Response) {
            const bodyText = await error2.text();
            try {
              const parsed = JSON.parse(bodyText);
              text = parsed.error || bodyText;
            } catch (e3) {
              text = bodyText || text;
            }
          } else if (error2 && error2.message) {
            text = error2.message;
          }
        } catch (e3) {}
        this.send(text, "error");
        return this.removeElement(target);
      }
    } else {
      if (input.hasAttribute("pattern")) {
        return this.send(`Immettere un valore compreso tra ${input.pattern}!`, "error");
      } else {
        return this.send("Valore immesso non valido!", "error");
      }
    }
  }
  abort(event) {
    return this.removeElement(event.currentTarget);
  }
  removeElement(target) {
    var container, editor, link;
    if (target.closest(".editor")) {
      editor = target.closest(".editor");
      container = editor.parentNode;
      editor.remove();
      if (container) {
        link = container.querySelector(".editable.is-hidden");
      }
      if (link) {
        return link.classList.remove("is-hidden");
      }
    }
  }
  send(message, level = "success", force = false, timeout = 2000, toast = true) {
    var options;
    options = {
      toast: level === "error" ? false : toast,
      icon: level,
      timerProgressBar: true,
      position: level === "error" ? "center" : "top-end",
      text: message,
      timer: level === "error" ? false : timeout,
      showConfirmButton: level === "error" ? true : false,
      didOpen: (toast2) => {
        toast2.addEventListener("mouseenter", import_sweetalert26.default.stopTimer);
        return toast2.addEventListener("mouseleave", import_sweetalert26.default.resumeTimer);
      },
      showClass: {
        popup: level === "error" ? "" : "animate__animated animate__bounceInRight"
      },
      hideClass: {
        popup: level === "error" ? "" : "animate__animated animate__bounceOutRight"
      }
    };
    if (import_sweetalert26.default.isVisible() && force == "true") {
      import_sweetalert26.default.fire(options);
    } else if (!import_sweetalert26.default.isVisible()) {
      import_sweetalert26.default.fire(options);
    }
  }
}

// app/javascript/controllers/index.js
application.register("audits", audits_controller_default);
application.register("book", book_controller_default);
application.register("calendar", calendar_controller_default);
application.register("form", form_controller_default);
application.register("menu", menu_controller_default);
application.register("message", message_controller_default);
application.register("modal", modal_controller_default);
application.register("users", users_controller_default);

// node_modules/trix/dist/trix.esm.min.js
var t3 = "2.1.15";
var e3 = "[data-trix-attachment]";
var i3 = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
var n2 = { default: { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, htmlAttributes: ["language"], text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test(t4) {
  return r3(t4.parentNode) === n2[this.listAttribute].tagName;
} }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test(t4) {
  return r3(t4.parentNode) === n2[this.listAttribute].tagName;
} }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
var r3 = (t4) => {
  var e4;
  return t4 == null || (e4 = t4.tagName) === null || e4 === undefined ? undefined : e4.toLowerCase();
};
var o2 = navigator.userAgent.match(/android\s([0-9]+.*Chrome)/i);
var s3 = o2 && parseInt(o2[1]);
var a3 = { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), recentAndroid: s3 && s3 > 12, samsungAndroid: s3 && navigator.userAgent.match(/Android.*SM-/), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: typeof InputEvent != "undefined" && ["data", "getTargetRanges", "inputType"].every((t4) => (t4 in InputEvent.prototype)) };
var l79 = { ADD_ATTR: ["language"], SAFE_FOR_XML: false, RETURN_DOM: true };
var c3 = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
var u3 = [c3.bytes, c3.KB, c3.MB, c3.GB, c3.TB, c3.PB];
var h3 = { prefix: "IEC", precision: 2, formatter(t4) {
  switch (t4) {
    case 0:
      return "0 ".concat(c3.bytes);
    case 1:
      return "1 ".concat(c3.byte);
    default:
      let e4;
      this.prefix === "SI" ? e4 = 1000 : this.prefix === "IEC" && (e4 = 1024);
      const i4 = Math.floor(Math.log(t4) / Math.log(e4)), n3 = (t4 / Math.pow(e4, i4)).toFixed(this.precision).replace(/0*$/, "").replace(/\.$/, "");
      return "".concat(n3, " ").concat(u3[i4]);
  }
} };
var d2 = "\uFEFF";
var g4 = "";
var m3 = function(t4) {
  for (const e4 in t4) {
    const i4 = t4[e4];
    this[e4] = i4;
  }
  return this;
};
var p3 = document.documentElement;
var f3 = p3.matches;
var b3 = function(t4) {
  let { onElement: e4, matchingSelector: i4, withCallback: n3, inPhase: r4, preventDefault: o3, times: s4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const a4 = e4 || p3, l80 = i4, c4 = r4 === "capturing", u4 = function(t5) {
    s4 != null && --s4 == 0 && u4.destroy();
    const e5 = y3(t5.target, { matchingSelector: l80 });
    e5 != null && (n3 == null || n3.call(e5, t5, e5), o3 && t5.preventDefault());
  };
  return u4.destroy = () => a4.removeEventListener(t4, u4, c4), a4.addEventListener(t4, u4, c4), u4;
};
var v3 = function(t4) {
  let { onElement: e4, bubbles: i4, cancelable: n3, attributes: r4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const o3 = e4 != null ? e4 : p3;
  i4 = i4 !== false, n3 = n3 !== false;
  const s4 = document.createEvent("Events");
  return s4.initEvent(t4, i4, n3), r4 != null && m3.call(s4, r4), o3.dispatchEvent(s4);
};
var A3 = function(t4, e4) {
  if ((t4 == null ? undefined : t4.nodeType) === 1)
    return f3.call(t4, e4);
};
var y3 = function(t4) {
  let { matchingSelector: e4, untilNode: i4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  for (;t4 && t4.nodeType !== Node.ELEMENT_NODE; )
    t4 = t4.parentNode;
  if (t4 != null) {
    if (e4 == null)
      return t4;
    if (t4.closest && i4 == null)
      return t4.closest(e4);
    for (;t4 && t4 !== i4; ) {
      if (A3(t4, e4))
        return t4;
      t4 = t4.parentNode;
    }
  }
};
var x4 = (t4) => document.activeElement !== t4 && C3(t4, document.activeElement);
var C3 = function(t4, e4) {
  if (t4 && e4)
    for (;e4; ) {
      if (e4 === t4)
        return true;
      e4 = e4.parentNode;
    }
};
var E2 = function(t4) {
  var e4;
  if ((e4 = t4) === null || e4 === undefined || !e4.parentNode)
    return;
  let i4 = 0;
  for (t4 = t4.previousSibling;t4; )
    i4++, t4 = t4.previousSibling;
  return i4;
};
var S2 = (t4) => {
  var e4;
  return t4 == null || (e4 = t4.parentNode) === null || e4 === undefined ? undefined : e4.removeChild(t4);
};
var R = function(t4) {
  let { onlyNodesOfType: e4, usingFilter: i4, expandEntityReferences: n3 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const r4 = (() => {
    switch (e4) {
      case "element":
        return NodeFilter.SHOW_ELEMENT;
      case "text":
        return NodeFilter.SHOW_TEXT;
      case "comment":
        return NodeFilter.SHOW_COMMENT;
      default:
        return NodeFilter.SHOW_ALL;
    }
  })();
  return document.createTreeWalker(t4, r4, i4 != null ? i4 : null, n3 === true);
};
var k3 = (t4) => {
  var e4;
  return t4 == null || (e4 = t4.tagName) === null || e4 === undefined ? undefined : e4.toLowerCase();
};
var T4 = function(t4) {
  let e4, i4, n3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  typeof t4 == "object" ? (n3 = t4, t4 = n3.tagName) : n3 = { attributes: n3 };
  const r4 = document.createElement(t4);
  if (n3.editable != null && (n3.attributes == null && (n3.attributes = {}), n3.attributes.contenteditable = n3.editable), n3.attributes)
    for (e4 in n3.attributes)
      i4 = n3.attributes[e4], r4.setAttribute(e4, i4);
  if (n3.style)
    for (e4 in n3.style)
      i4 = n3.style[e4], r4.style[e4] = i4;
  if (n3.data)
    for (e4 in n3.data)
      i4 = n3.data[e4], r4.dataset[e4] = i4;
  return n3.className && n3.className.split(" ").forEach((t5) => {
    r4.classList.add(t5);
  }), n3.textContent && (r4.textContent = n3.textContent), n3.childNodes && [].concat(n3.childNodes).forEach((t5) => {
    r4.appendChild(t5);
  }), r4;
};
var w4;
var L3 = function() {
  if (w4 != null)
    return w4;
  w4 = [];
  for (const t4 in n2) {
    const e4 = n2[t4];
    e4.tagName && w4.push(e4.tagName);
  }
  return w4;
};
var D3 = (t4) => I3(t4 == null ? undefined : t4.firstChild);
var N3 = function(t4) {
  let { strict: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { strict: true };
  return e4 ? I3(t4) : I3(t4) || !I3(t4.firstChild) && function(t5) {
    return L3().includes(k3(t5)) && !L3().includes(k3(t5.firstChild));
  }(t4);
};
var I3 = (t4) => O2(t4) && (t4 == null ? undefined : t4.data) === "block";
var O2 = (t4) => (t4 == null ? undefined : t4.nodeType) === Node.COMMENT_NODE;
var F4 = function(t4) {
  let { name: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (t4)
    return B3(t4) ? t4.data === d2 ? !e4 || t4.parentNode.dataset.trixCursorTarget === e4 : undefined : F4(t4.firstChild);
};
var P3 = (t4) => A3(t4, e3);
var M2 = (t4) => B3(t4) && (t4 == null ? undefined : t4.data) === "";
var B3 = (t4) => (t4 == null ? undefined : t4.nodeType) === Node.TEXT_NODE;
var _3 = { level2Enabled: true, getLevel() {
  return this.level2Enabled && a3.supportsInputEvents ? 2 : 0;
}, pickFiles(t4) {
  const e4 = T4("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId });
  e4.addEventListener("change", () => {
    t4(e4.files), S2(e4);
  }), S2(document.getElementById(this.fileInputId)), document.body.appendChild(e4), e4.click();
} };
var j4 = { removeBlankTableCells: false, tableCellSeparator: " | ", tableRowSeparator: `
` };
var W2 = { bold: { tagName: "strong", inheritable: true, parser(t4) {
  const e4 = window.getComputedStyle(t4);
  return e4.fontWeight === "bold" || e4.fontWeight >= 600;
} }, italic: { tagName: "em", inheritable: true, parser: (t4) => window.getComputedStyle(t4).fontStyle === "italic" }, href: { groupTagName: "a", parser(t4) {
  const i4 = "a:not(".concat(e3, ")"), n3 = t4.closest(i4);
  if (n3)
    return n3.getAttribute("href");
} }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
var U2 = { getDefaultHTML: () => `<div class="trix-button-row">
      <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">
        <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="`.concat(c3.bold, '" tabindex="-1">').concat(c3.bold, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="`).concat(c3.italic, '" tabindex="-1">').concat(c3.italic, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="`).concat(c3.strike, '" tabindex="-1">').concat(c3.strike, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="`).concat(c3.link, '" tabindex="-1">').concat(c3.link, `</button>
      </span>

      <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">
        <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="`).concat(c3.heading1, '" tabindex="-1">').concat(c3.heading1, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="`).concat(c3.quote, '" tabindex="-1">').concat(c3.quote, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="`).concat(c3.code, '" tabindex="-1">').concat(c3.code, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="`).concat(c3.bullets, '" tabindex="-1">').concat(c3.bullets, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="`).concat(c3.numbers, '" tabindex="-1">').concat(c3.numbers, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="`).concat(c3.outdent, '" tabindex="-1">').concat(c3.outdent, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="`).concat(c3.indent, '" tabindex="-1">').concat(c3.indent, `</button>
      </span>

      <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">
        <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="`).concat(c3.attachFiles, '" tabindex="-1">').concat(c3.attachFiles, `</button>
      </span>

      <span class="trix-button-group-spacer"></span>

      <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">
        <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="`).concat(c3.undo, '" tabindex="-1">').concat(c3.undo, `</button>
        <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="`).concat(c3.redo, '" tabindex="-1">').concat(c3.redo, `</button>
      </span>
    </div>

    <div class="trix-dialogs" data-trix-dialogs>
      <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">
        <div class="trix-dialog__link-fields">
          <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="`).concat(c3.urlPlaceholder, '" aria-label="').concat(c3.url, `" data-trix-validate-href required data-trix-input>
          <div class="trix-button-group">
            <input type="button" class="trix-button trix-button--dialog" value="`).concat(c3.link, `" data-trix-method="setAttribute">
            <input type="button" class="trix-button trix-button--dialog" value="`).concat(c3.unlink, `" data-trix-method="removeAttribute">
          </div>
        </div>
      </div>
    </div>`) };
var V3 = { interval: 5000 };
var z3 = Object.freeze({ __proto__: null, attachments: i3, blockAttributes: n2, browser: a3, css: { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" }, dompurify: l79, fileSize: h3, input: _3, keyNames: { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" }, lang: c3, parser: j4, textAttributes: W2, toolbar: U2, undo: V3 });

class q3 {
  static proxyMethod(t4) {
    const { name: e4, toMethod: i4, toProperty: n3, optional: r4 } = H3(t4);
    this.prototype[e4] = function() {
      let t5, o3;
      var s4, a4;
      i4 ? o3 = r4 ? (s4 = this[i4]) === null || s4 === undefined ? undefined : s4.call(this) : this[i4]() : n3 && (o3 = this[n3]);
      return r4 ? (t5 = (a4 = o3) === null || a4 === undefined ? undefined : a4[e4], t5 ? J2.call(t5, o3, arguments) : undefined) : (t5 = o3[e4], J2.call(t5, o3, arguments));
    };
  }
}
var H3 = function(t4) {
  const e4 = t4.match(K2);
  if (!e4)
    throw new Error("can't parse @proxyMethod expression: ".concat(t4));
  const i4 = { name: e4[4] };
  return e4[2] != null ? i4.toMethod = e4[1] : i4.toProperty = e4[1], e4[3] != null && (i4.optional = true), i4;
};
var { apply: J2 } = Function.prototype;
var K2 = new RegExp("^(.+?)(\\(\\))?(\\?)?\\.(.+?)$");
var G3;
var Y;
var X2;

class $3 extends q3 {
  static box() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return t4 instanceof this ? t4 : this.fromUCS2String(t4 == null ? undefined : t4.toString());
  }
  static fromUCS2String(t4) {
    return new this(t4, et(t4));
  }
  static fromCodepoints(t4) {
    return new this(it(t4), t4);
  }
  constructor(t4, e4) {
    super(...arguments), this.ucs2String = t4, this.codepoints = e4, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
  }
  offsetToUCS2Offset(t4) {
    return it(this.codepoints.slice(0, Math.max(0, t4))).length;
  }
  offsetFromUCS2Offset(t4) {
    return et(this.ucs2String.slice(0, Math.max(0, t4))).length;
  }
  slice() {
    return this.constructor.fromCodepoints(this.codepoints.slice(...arguments));
  }
  charAt(t4) {
    return this.slice(t4, t4 + 1);
  }
  isEqualTo(t4) {
    return this.constructor.box(t4).ucs2String === this.ucs2String;
  }
  toJSON() {
    return this.ucs2String;
  }
  getCacheKey() {
    return this.ucs2String;
  }
  toString() {
    return this.ucs2String;
  }
}
var Z2 = ((G3 = Array.from) === null || G3 === undefined ? undefined : G3.call(Array, "\uD83D\uDC7C").length) === 1;
var Q2 = ((Y = " ".codePointAt) === null || Y === undefined ? undefined : Y.call(" ", 0)) != null;
var tt = ((X2 = String.fromCodePoint) === null || X2 === undefined ? undefined : X2.call(String, 32, 128124)) === " \uD83D\uDC7C";
var et;
var it;
et = Z2 && Q2 ? (t4) => Array.from(t4).map((t5) => t5.codePointAt(0)) : function(t4) {
  const e4 = [];
  let i4 = 0;
  const { length: n3 } = t4;
  for (;i4 < n3; ) {
    let r4 = t4.charCodeAt(i4++);
    if (55296 <= r4 && r4 <= 56319 && i4 < n3) {
      const e5 = t4.charCodeAt(i4++);
      (64512 & e5) == 56320 ? r4 = ((1023 & r4) << 10) + (1023 & e5) + 65536 : i4--;
    }
    e4.push(r4);
  }
  return e4;
}, it = tt ? (t4) => String.fromCodePoint(...Array.from(t4 || [])) : function(t4) {
  return (() => {
    const e4 = [];
    return Array.from(t4).forEach((t5) => {
      let i4 = "";
      t5 > 65535 && (t5 -= 65536, i4 += String.fromCharCode(t5 >>> 10 & 1023 | 55296), t5 = 56320 | 1023 & t5), e4.push(i4 + String.fromCharCode(t5));
    }), e4;
  })().join("");
};
var nt = 0;

class rt extends q3 {
  static fromJSONString(t4) {
    return this.fromJSON(JSON.parse(t4));
  }
  constructor() {
    super(...arguments), this.id = ++nt;
  }
  hasSameConstructorAs(t4) {
    return this.constructor === (t4 == null ? undefined : t4.constructor);
  }
  isEqualTo(t4) {
    return this === t4;
  }
  inspect() {
    const t4 = [], e4 = this.contentsForInspection() || {};
    for (const i4 in e4) {
      const n3 = e4[i4];
      t4.push("".concat(i4, "=").concat(n3));
    }
    return "#<".concat(this.constructor.name, ":").concat(this.id).concat(t4.length ? " ".concat(t4.join(", ")) : "", ">");
  }
  contentsForInspection() {}
  toJSONString() {
    return JSON.stringify(this);
  }
  toUTF16String() {
    return $3.box(this);
  }
  getCacheKey() {
    return this.id.toString();
  }
}
var ot = function() {
  let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (t4.length !== e4.length)
    return false;
  for (let i4 = 0;i4 < t4.length; i4++) {
    if (t4[i4] !== e4[i4])
      return false;
  }
  return true;
};
var st = function(t4) {
  const e4 = t4.slice(0);
  for (var i4 = arguments.length, n3 = new Array(i4 > 1 ? i4 - 1 : 0), r4 = 1;r4 < i4; r4++)
    n3[r4 - 1] = arguments[r4];
  return e4.splice(...n3), e4;
};
var at = /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/;
var lt = function() {
  const t4 = T4("input", { dir: "auto", name: "x", dirName: "x.dir" }), e4 = T4("textarea", { dir: "auto", name: "y", dirName: "y.dir" }), i4 = T4("form");
  i4.appendChild(t4), i4.appendChild(e4);
  const n3 = function() {
    try {
      return new FormData(i4).has(e4.dirName);
    } catch (t5) {
      return false;
    }
  }(), r4 = function() {
    try {
      return t4.matches(":dir(ltr),:dir(rtl)");
    } catch (t5) {
      return false;
    }
  }();
  return n3 ? function(t5) {
    return e4.value = t5, new FormData(i4).get(e4.dirName);
  } : r4 ? function(e5) {
    return t4.value = e5, t4.matches(":dir(rtl)") ? "rtl" : "ltr";
  } : function(t5) {
    const e5 = t5.trim().charAt(0);
    return at.test(e5) ? "rtl" : "ltr";
  };
}();
var ct = null;
var ut = null;
var ht = null;
var dt = null;
var gt = () => (ct || (ct = bt().concat(pt())), ct);
var mt = (t4) => n2[t4];
var pt = () => (ut || (ut = Object.keys(n2)), ut);
var ft = (t4) => W2[t4];
var bt = () => (ht || (ht = Object.keys(W2)), ht);
var vt = function(t4, e4) {
  At(t4).textContent = e4.replace(/%t/g, t4);
};
var At = function(t4) {
  const e4 = document.createElement("style");
  e4.setAttribute("type", "text/css"), e4.setAttribute("data-tag-name", t4.toLowerCase());
  const i4 = yt();
  return i4 && e4.setAttribute("nonce", i4), document.head.insertBefore(e4, document.head.firstChild), e4;
};
var yt = function() {
  const t4 = xt("trix-csp-nonce") || xt("csp-nonce");
  if (t4) {
    const { nonce: e4, content: i4 } = t4;
    return e4 == "" ? i4 : e4;
  }
};
var xt = (t4) => document.head.querySelector("meta[name=".concat(t4, "]"));
var Ct = { "application/x-trix-feature-detection": "test" };
var Et = function(t4) {
  const e4 = t4.getData("text/plain"), i4 = t4.getData("text/html");
  if (!e4 || !i4)
    return e4 == null ? undefined : e4.length;
  {
    const { body: t5 } = new DOMParser().parseFromString(i4, "text/html");
    if (t5.textContent === e4)
      return !t5.querySelector("*");
  }
};
var St = /Mac|^iP/.test(navigator.platform) ? (t4) => t4.metaKey : (t4) => t4.ctrlKey;
var Rt = (t4) => setTimeout(t4, 1);
var kt = function() {
  let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const e4 = {};
  for (const i4 in t4) {
    const n3 = t4[i4];
    e4[i4] = n3;
  }
  return e4;
};
var Tt = function() {
  let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (Object.keys(t4).length !== Object.keys(e4).length)
    return false;
  for (const i4 in t4) {
    if (t4[i4] !== e4[i4])
      return false;
  }
  return true;
};
var wt = function(t4) {
  if (t4 != null)
    return Array.isArray(t4) || (t4 = [t4, t4]), [Nt(t4[0]), Nt(t4[1] != null ? t4[1] : t4[0])];
};
var Lt = function(t4) {
  if (t4 == null)
    return;
  const [e4, i4] = wt(t4);
  return It(e4, i4);
};
var Dt = function(t4, e4) {
  if (t4 == null || e4 == null)
    return;
  const [i4, n3] = wt(t4), [r4, o3] = wt(e4);
  return It(i4, r4) && It(n3, o3);
};
var Nt = function(t4) {
  return typeof t4 == "number" ? t4 : kt(t4);
};
var It = function(t4, e4) {
  return typeof t4 == "number" ? t4 === e4 : Tt(t4, e4);
};

class Ot extends q3 {
  constructor() {
    super(...arguments), this.update = this.update.bind(this), this.selectionManagers = [];
  }
  start() {
    this.started || (this.started = true, document.addEventListener("selectionchange", this.update, true));
  }
  stop() {
    if (this.started)
      return this.started = false, document.removeEventListener("selectionchange", this.update, true);
  }
  registerSelectionManager(t4) {
    if (!this.selectionManagers.includes(t4))
      return this.selectionManagers.push(t4), this.start();
  }
  unregisterSelectionManager(t4) {
    if (this.selectionManagers = this.selectionManagers.filter((e4) => e4 !== t4), this.selectionManagers.length === 0)
      return this.stop();
  }
  notifySelectionManagersOfSelectionChange() {
    return this.selectionManagers.map((t4) => t4.selectionDidChange());
  }
  update() {
    this.notifySelectionManagersOfSelectionChange();
  }
  reset() {
    this.update();
  }
}
var Ft = new Ot;
var Pt = function() {
  const t4 = window.getSelection();
  if (t4.rangeCount > 0)
    return t4;
};
var Mt = function() {
  var t4;
  const e4 = (t4 = Pt()) === null || t4 === undefined ? undefined : t4.getRangeAt(0);
  if (e4 && !_t(e4))
    return e4;
};
var Bt = function(t4) {
  const e4 = window.getSelection();
  return e4.removeAllRanges(), e4.addRange(t4), Ft.update();
};
var _t = (t4) => jt(t4.startContainer) || jt(t4.endContainer);
var jt = (t4) => !Object.getPrototypeOf(t4);
var Wt = (t4) => t4.replace(new RegExp("".concat(d2), "g"), "").replace(new RegExp("".concat(g4), "g"), " ");
var Ut = new RegExp("[^\\S".concat(g4, "]"));
var Vt = (t4) => t4.replace(new RegExp("".concat(Ut.source), "g"), " ").replace(/\ {2,}/g, " ");
var zt = function(t4, e4) {
  if (t4.isEqualTo(e4))
    return ["", ""];
  const i4 = qt(t4, e4), { length: n3 } = i4.utf16String;
  let r4;
  if (n3) {
    const { offset: o3 } = i4, s4 = t4.codepoints.slice(0, o3).concat(t4.codepoints.slice(o3 + n3));
    r4 = qt(e4, $3.fromCodepoints(s4));
  } else
    r4 = qt(e4, t4);
  return [i4.utf16String.toString(), r4.utf16String.toString()];
};
var qt = function(t4, e4) {
  let i4 = 0, n3 = t4.length, r4 = e4.length;
  for (;i4 < n3 && t4.charAt(i4).isEqualTo(e4.charAt(i4)); )
    i4++;
  for (;n3 > i4 + 1 && t4.charAt(n3 - 1).isEqualTo(e4.charAt(r4 - 1)); )
    n3--, r4--;
  return { utf16String: t4.slice(i4, n3), offset: i4 };
};

class Ht extends rt {
  static fromCommonAttributesOfObjects() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (!t4.length)
      return new this;
    let e4 = Yt(t4[0]), i4 = e4.getKeys();
    return t4.slice(1).forEach((t5) => {
      i4 = e4.getKeysCommonToHash(Yt(t5)), e4 = e4.slice(i4);
    }), e4;
  }
  static box(t4) {
    return Yt(t4);
  }
  constructor() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(...arguments), this.values = Gt(t4);
  }
  add(t4, e4) {
    return this.merge(Jt(t4, e4));
  }
  remove(t4) {
    return new Ht(Gt(this.values, t4));
  }
  get(t4) {
    return this.values[t4];
  }
  has(t4) {
    return t4 in this.values;
  }
  merge(t4) {
    return new Ht(Kt(this.values, Xt(t4)));
  }
  slice(t4) {
    const e4 = {};
    return Array.from(t4).forEach((t5) => {
      this.has(t5) && (e4[t5] = this.values[t5]);
    }), new Ht(e4);
  }
  getKeys() {
    return Object.keys(this.values);
  }
  getKeysCommonToHash(t4) {
    return t4 = Yt(t4), this.getKeys().filter((e4) => this.values[e4] === t4.values[e4]);
  }
  isEqualTo(t4) {
    return ot(this.toArray(), Yt(t4).toArray());
  }
  isEmpty() {
    return this.getKeys().length === 0;
  }
  toArray() {
    if (!this.array) {
      const t4 = [];
      for (const e4 in this.values) {
        const i4 = this.values[e4];
        t4.push(t4.push(e4, i4));
      }
      this.array = t4.slice(0);
    }
    return this.array;
  }
  toObject() {
    return Gt(this.values);
  }
  toJSON() {
    return this.toObject();
  }
  contentsForInspection() {
    return { values: JSON.stringify(this.values) };
  }
}
var Jt = function(t4, e4) {
  const i4 = {};
  return i4[t4] = e4, i4;
};
var Kt = function(t4, e4) {
  const i4 = Gt(t4);
  for (const t5 in e4) {
    const n3 = e4[t5];
    i4[t5] = n3;
  }
  return i4;
};
var Gt = function(t4, e4) {
  const i4 = {};
  return Object.keys(t4).sort().forEach((n3) => {
    n3 !== e4 && (i4[n3] = t4[n3]);
  }), i4;
};
var Yt = function(t4) {
  return t4 instanceof Ht ? t4 : new Ht(t4);
};
var Xt = function(t4) {
  return t4 instanceof Ht ? t4.values : t4;
};

class $t {
  static groupObjects() {
    let t4, e4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], { depth: i4, asTree: n3 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    n3 && i4 == null && (i4 = 0);
    const r4 = [];
    return Array.from(e4).forEach((e5) => {
      var o3;
      if (t4) {
        var s4, a4, l80;
        if ((s4 = e5.canBeGrouped) !== null && s4 !== undefined && s4.call(e5, i4) && (a4 = (l80 = t4[t4.length - 1]).canBeGroupedWith) !== null && a4 !== undefined && a4.call(l80, e5, i4))
          return void t4.push(e5);
        r4.push(new this(t4, { depth: i4, asTree: n3 })), t4 = null;
      }
      (o3 = e5.canBeGrouped) !== null && o3 !== undefined && o3.call(e5, i4) ? t4 = [e5] : r4.push(e5);
    }), t4 && r4.push(new this(t4, { depth: i4, asTree: n3 })), r4;
  }
  constructor() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], { depth: e4, asTree: i4 } = arguments.length > 1 ? arguments[1] : undefined;
    this.objects = t4, i4 && (this.depth = e4, this.objects = this.constructor.groupObjects(this.objects, { asTree: i4, depth: this.depth + 1 }));
  }
  getObjects() {
    return this.objects;
  }
  getDepth() {
    return this.depth;
  }
  getCacheKey() {
    const t4 = ["objectGroup"];
    return Array.from(this.getObjects()).forEach((e4) => {
      t4.push(e4.getCacheKey());
    }), t4.join("/");
  }
}

class Zt extends q3 {
  constructor() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(...arguments), this.objects = {}, Array.from(t4).forEach((t5) => {
      const e4 = JSON.stringify(t5);
      this.objects[e4] == null && (this.objects[e4] = t5);
    });
  }
  find(t4) {
    const e4 = JSON.stringify(t4);
    return this.objects[e4];
  }
}

class Qt {
  constructor(t4) {
    this.reset(t4);
  }
  add(t4) {
    const e4 = te(t4);
    this.elements[e4] = t4;
  }
  remove(t4) {
    const e4 = te(t4), i4 = this.elements[e4];
    if (i4)
      return delete this.elements[e4], i4;
  }
  reset() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return this.elements = {}, Array.from(t4).forEach((t5) => {
      this.add(t5);
    }), t4;
  }
}
var te = (t4) => t4.dataset.trixStoreKey;

class ee extends q3 {
  isPerforming() {
    return this.performing === true;
  }
  hasPerformed() {
    return this.performed === true;
  }
  hasSucceeded() {
    return this.performed && this.succeeded;
  }
  hasFailed() {
    return this.performed && !this.succeeded;
  }
  getPromise() {
    return this.promise || (this.promise = new Promise((t4, e4) => (this.performing = true, this.perform((i4, n3) => {
      this.succeeded = i4, this.performing = false, this.performed = true, this.succeeded ? t4(n3) : e4(n3);
    })))), this.promise;
  }
  perform(t4) {
    return t4(false);
  }
  release() {
    var t4, e4;
    (t4 = this.promise) === null || t4 === undefined || (e4 = t4.cancel) === null || e4 === undefined || e4.call(t4), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
  }
}
ee.proxyMethod("getPromise().then"), ee.proxyMethod("getPromise().catch");

class ie extends q3 {
  constructor(t4) {
    let e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(...arguments), this.object = t4, this.options = e4, this.childViews = [], this.rootView = this;
  }
  getNodes() {
    return this.nodes || (this.nodes = this.createNodes()), this.nodes.map((t4) => t4.cloneNode(true));
  }
  invalidate() {
    var t4;
    return this.nodes = null, this.childViews = [], (t4 = this.parentView) === null || t4 === undefined ? undefined : t4.invalidate();
  }
  invalidateViewForObject(t4) {
    var e4;
    return (e4 = this.findViewForObject(t4)) === null || e4 === undefined ? undefined : e4.invalidate();
  }
  findOrCreateCachedChildView(t4, e4, i4) {
    let n3 = this.getCachedViewForObject(e4);
    return n3 ? this.recordChildView(n3) : (n3 = this.createChildView(...arguments), this.cacheViewForObject(n3, e4)), n3;
  }
  createChildView(t4, e4) {
    let i4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    e4 instanceof $t && (i4.viewClass = t4, t4 = ne);
    const n3 = new t4(e4, i4);
    return this.recordChildView(n3);
  }
  recordChildView(t4) {
    return t4.parentView = this, t4.rootView = this.rootView, this.childViews.push(t4), t4;
  }
  getAllChildViews() {
    let t4 = [];
    return this.childViews.forEach((e4) => {
      t4.push(e4), t4 = t4.concat(e4.getAllChildViews());
    }), t4;
  }
  findElement() {
    return this.findElementForObject(this.object);
  }
  findElementForObject(t4) {
    const e4 = t4 == null ? undefined : t4.id;
    if (e4)
      return this.rootView.element.querySelector("[data-trix-id='".concat(e4, "']"));
  }
  findViewForObject(t4) {
    for (const e4 of this.getAllChildViews())
      if (e4.object === t4)
        return e4;
  }
  getViewCache() {
    return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? (this.viewCache || (this.viewCache = {}), this.viewCache) : undefined;
  }
  isViewCachingEnabled() {
    return this.shouldCacheViews !== false;
  }
  enableViewCaching() {
    this.shouldCacheViews = true;
  }
  disableViewCaching() {
    this.shouldCacheViews = false;
  }
  getCachedViewForObject(t4) {
    var e4;
    return (e4 = this.getViewCache()) === null || e4 === undefined ? undefined : e4[t4.getCacheKey()];
  }
  cacheViewForObject(t4, e4) {
    const i4 = this.getViewCache();
    i4 && (i4[e4.getCacheKey()] = t4);
  }
  garbageCollectCachedViews() {
    const t4 = this.getViewCache();
    if (t4) {
      const e4 = this.getAllChildViews().concat(this).map((t5) => t5.object.getCacheKey());
      for (const i4 in t4)
        e4.includes(i4) || delete t4[i4];
    }
  }
}

class ne extends ie {
  constructor() {
    super(...arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
  }
  getChildViews() {
    return this.childViews.length || Array.from(this.objectGroup.getObjects()).forEach((t4) => {
      this.findOrCreateCachedChildView(this.viewClass, t4, this.options);
    }), this.childViews;
  }
  createNodes() {
    const t4 = this.createContainerElement();
    return this.getChildViews().forEach((e4) => {
      Array.from(e4.getNodes()).forEach((e5) => {
        t4.appendChild(e5);
      });
    }), [t4];
  }
  createContainerElement() {
    let t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.objectGroup.getDepth();
    return this.getChildViews()[0].createContainerElement(t4);
  }
}
/*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE */
var { entries: re, setPrototypeOf: oe, isFrozen: se, getPrototypeOf: ae, getOwnPropertyDescriptor: le } = Object;
var { freeze: ce, seal: ue, create: he } = Object;
var { apply: de, construct: ge } = typeof Reflect != "undefined" && Reflect;
ce || (ce = function(t4) {
  return t4;
}), ue || (ue = function(t4) {
  return t4;
}), de || (de = function(t4, e4, i4) {
  return t4.apply(e4, i4);
}), ge || (ge = function(t4, e4) {
  return new t4(...e4);
});
var me = Le(Array.prototype.forEach);
var pe = Le(Array.prototype.lastIndexOf);
var fe = Le(Array.prototype.pop);
var be = Le(Array.prototype.push);
var ve = Le(Array.prototype.splice);
var Ae = Le(String.prototype.toLowerCase);
var ye = Le(String.prototype.toString);
var xe = Le(String.prototype.match);
var Ce = Le(String.prototype.replace);
var Ee = Le(String.prototype.indexOf);
var Se = Le(String.prototype.trim);
var Re = Le(Object.prototype.hasOwnProperty);
var ke = Le(RegExp.prototype.test);
var Te = (we = TypeError, function() {
  for (var t4 = arguments.length, e4 = new Array(t4), i4 = 0;i4 < t4; i4++)
    e4[i4] = arguments[i4];
  return ge(we, e4);
});
var we;
function Le(t4) {
  return function(e4) {
    e4 instanceof RegExp && (e4.lastIndex = 0);
    for (var i4 = arguments.length, n3 = new Array(i4 > 1 ? i4 - 1 : 0), r4 = 1;r4 < i4; r4++)
      n3[r4 - 1] = arguments[r4];
    return de(t4, e4, n3);
  };
}
function De(t4, e4) {
  let i4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Ae;
  oe && oe(t4, null);
  let n3 = e4.length;
  for (;n3--; ) {
    let r4 = e4[n3];
    if (typeof r4 == "string") {
      const t5 = i4(r4);
      t5 !== r4 && (se(e4) || (e4[n3] = t5), r4 = t5);
    }
    t4[r4] = true;
  }
  return t4;
}
function Ne(t4) {
  for (let e4 = 0;e4 < t4.length; e4++) {
    Re(t4, e4) || (t4[e4] = null);
  }
  return t4;
}
function Ie(t4) {
  const e4 = he(null);
  for (const [i4, n3] of re(t4)) {
    Re(t4, i4) && (Array.isArray(n3) ? e4[i4] = Ne(n3) : n3 && typeof n3 == "object" && n3.constructor === Object ? e4[i4] = Ie(n3) : e4[i4] = n3);
  }
  return e4;
}
function Oe(t4, e4) {
  for (;t4 !== null; ) {
    const i4 = le(t4, e4);
    if (i4) {
      if (i4.get)
        return Le(i4.get);
      if (typeof i4.value == "function")
        return Le(i4.value);
    }
    t4 = ae(t4);
  }
  return function() {
    return null;
  };
}
var Fe = ce(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var Pe = ce(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var Me = ce(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var Be = ce(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var _e = ce(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var je = ce(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var We = ce(["#text"]);
var Ue = ce(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var Ve = ce(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var ze = ce(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var qe = ce(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var He = ue(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var Je = ue(/<%[\w\W]*|[\w\W]*%>/gm);
var Ke = ue(/\$\{[\w\W]*/gm);
var Ge = ue(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var Ye = ue(/^aria-[\-\w]+$/);
var Xe = ue(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
var $e = ue(/^(?:\w+script|data):/i);
var Ze = ue(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
var Qe = ue(/^html$/i);
var ti = ue(/^[a-z][.\w]*(-[.\w]+)+$/i);
var ei = Object.freeze({ __proto__: null, ARIA_ATTR: Ye, ATTR_WHITESPACE: Ze, CUSTOM_ELEMENT: ti, DATA_ATTR: Ge, DOCTYPE_NAME: Qe, ERB_EXPR: Je, IS_ALLOWED_URI: Xe, IS_SCRIPT_OR_DATA: $e, MUSTACHE_EXPR: He, TMPLIT_EXPR: Ke });
var ii = 1;
var ni = 3;
var ri = 7;
var oi = 8;
var si = 9;
var ai = function() {
  return typeof window == "undefined" ? null : window;
};
var li = function t4() {
  let e4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ai();
  const i4 = (e5) => t4(e5);
  if (i4.version = "3.2.5", i4.removed = [], !e4 || !e4.document || e4.document.nodeType !== si || !e4.Element)
    return i4.isSupported = false, i4;
  let { document: n3 } = e4;
  const r4 = n3, o3 = r4.currentScript, { DocumentFragment: s4, HTMLTemplateElement: a4, Node: l80, Element: c4, NodeFilter: u4, NamedNodeMap: h4 = e4.NamedNodeMap || e4.MozNamedAttrMap, HTMLFormElement: d3, DOMParser: g5, trustedTypes: m4 } = e4, p4 = c4.prototype, f4 = Oe(p4, "cloneNode"), b4 = Oe(p4, "remove"), v4 = Oe(p4, "nextSibling"), A4 = Oe(p4, "childNodes"), y4 = Oe(p4, "parentNode");
  if (typeof a4 == "function") {
    const t5 = n3.createElement("template");
    t5.content && t5.content.ownerDocument && (n3 = t5.content.ownerDocument);
  }
  let x5, C4 = "";
  const { implementation: E3, createNodeIterator: S3, createDocumentFragment: R2, getElementsByTagName: k4 } = n3, { importNode: T5 } = r4;
  let w5 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
  i4.isSupported = typeof re == "function" && typeof y4 == "function" && E3 && E3.createHTMLDocument !== undefined;
  const { MUSTACHE_EXPR: L4, ERB_EXPR: D4, TMPLIT_EXPR: N4, DATA_ATTR: I4, ARIA_ATTR: O3, IS_SCRIPT_OR_DATA: F5, ATTR_WHITESPACE: P4, CUSTOM_ELEMENT: M3 } = ei;
  let { IS_ALLOWED_URI: B4 } = ei, _4 = null;
  const j5 = De({}, [...Fe, ...Pe, ...Me, ..._e, ...We]);
  let W3 = null;
  const U3 = De({}, [...Ue, ...Ve, ...ze, ...qe]);
  let V4 = Object.seal(he(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), z4 = null, q4 = null, H4 = true, J3 = true, K3 = false, G4 = true, Y2 = false, X3 = true, $4 = false, Z3 = false, Q3 = false, tt2 = false, et2 = false, it2 = false, nt2 = true, rt2 = false, ot2 = true, st2 = false, at2 = {}, lt2 = null;
  const ct2 = De({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ut2 = null;
  const ht2 = De({}, ["audio", "video", "img", "source", "image", "track"]);
  let dt2 = null;
  const gt2 = De({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mt2 = "http://www.w3.org/1998/Math/MathML", pt2 = "http://www.w3.org/2000/svg", ft2 = "http://www.w3.org/1999/xhtml";
  let bt2 = ft2, vt2 = false, At2 = null;
  const yt2 = De({}, [mt2, pt2, ft2], ye);
  let xt2 = De({}, ["mi", "mo", "mn", "ms", "mtext"]), Ct2 = De({}, ["annotation-xml"]);
  const Et2 = De({}, ["title", "style", "font", "a", "script"]);
  let St2 = null;
  const Rt2 = ["application/xhtml+xml", "text/html"];
  let kt2 = null, Tt2 = null;
  const wt2 = n3.createElement("form"), Lt2 = function(t5) {
    return t5 instanceof RegExp || t5 instanceof Function;
  }, Dt2 = function() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!Tt2 || Tt2 !== t5) {
      if (t5 && typeof t5 == "object" || (t5 = {}), t5 = Ie(t5), St2 = Rt2.indexOf(t5.PARSER_MEDIA_TYPE) === -1 ? "text/html" : t5.PARSER_MEDIA_TYPE, kt2 = St2 === "application/xhtml+xml" ? ye : Ae, _4 = Re(t5, "ALLOWED_TAGS") ? De({}, t5.ALLOWED_TAGS, kt2) : j5, W3 = Re(t5, "ALLOWED_ATTR") ? De({}, t5.ALLOWED_ATTR, kt2) : U3, At2 = Re(t5, "ALLOWED_NAMESPACES") ? De({}, t5.ALLOWED_NAMESPACES, ye) : yt2, dt2 = Re(t5, "ADD_URI_SAFE_ATTR") ? De(Ie(gt2), t5.ADD_URI_SAFE_ATTR, kt2) : gt2, ut2 = Re(t5, "ADD_DATA_URI_TAGS") ? De(Ie(ht2), t5.ADD_DATA_URI_TAGS, kt2) : ht2, lt2 = Re(t5, "FORBID_CONTENTS") ? De({}, t5.FORBID_CONTENTS, kt2) : ct2, z4 = Re(t5, "FORBID_TAGS") ? De({}, t5.FORBID_TAGS, kt2) : {}, q4 = Re(t5, "FORBID_ATTR") ? De({}, t5.FORBID_ATTR, kt2) : {}, at2 = !!Re(t5, "USE_PROFILES") && t5.USE_PROFILES, H4 = t5.ALLOW_ARIA_ATTR !== false, J3 = t5.ALLOW_DATA_ATTR !== false, K3 = t5.ALLOW_UNKNOWN_PROTOCOLS || false, G4 = t5.ALLOW_SELF_CLOSE_IN_ATTR !== false, Y2 = t5.SAFE_FOR_TEMPLATES || false, X3 = t5.SAFE_FOR_XML !== false, $4 = t5.WHOLE_DOCUMENT || false, tt2 = t5.RETURN_DOM || false, et2 = t5.RETURN_DOM_FRAGMENT || false, it2 = t5.RETURN_TRUSTED_TYPE || false, Q3 = t5.FORCE_BODY || false, nt2 = t5.SANITIZE_DOM !== false, rt2 = t5.SANITIZE_NAMED_PROPS || false, ot2 = t5.KEEP_CONTENT !== false, st2 = t5.IN_PLACE || false, B4 = t5.ALLOWED_URI_REGEXP || Xe, bt2 = t5.NAMESPACE || ft2, xt2 = t5.MATHML_TEXT_INTEGRATION_POINTS || xt2, Ct2 = t5.HTML_INTEGRATION_POINTS || Ct2, V4 = t5.CUSTOM_ELEMENT_HANDLING || {}, t5.CUSTOM_ELEMENT_HANDLING && Lt2(t5.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (V4.tagNameCheck = t5.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t5.CUSTOM_ELEMENT_HANDLING && Lt2(t5.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (V4.attributeNameCheck = t5.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t5.CUSTOM_ELEMENT_HANDLING && typeof t5.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (V4.allowCustomizedBuiltInElements = t5.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y2 && (J3 = false), et2 && (tt2 = true), at2 && (_4 = De({}, We), W3 = [], at2.html === true && (De(_4, Fe), De(W3, Ue)), at2.svg === true && (De(_4, Pe), De(W3, Ve), De(W3, qe)), at2.svgFilters === true && (De(_4, Me), De(W3, Ve), De(W3, qe)), at2.mathMl === true && (De(_4, _e), De(W3, ze), De(W3, qe))), t5.ADD_TAGS && (_4 === j5 && (_4 = Ie(_4)), De(_4, t5.ADD_TAGS, kt2)), t5.ADD_ATTR && (W3 === U3 && (W3 = Ie(W3)), De(W3, t5.ADD_ATTR, kt2)), t5.ADD_URI_SAFE_ATTR && De(dt2, t5.ADD_URI_SAFE_ATTR, kt2), t5.FORBID_CONTENTS && (lt2 === ct2 && (lt2 = Ie(lt2)), De(lt2, t5.FORBID_CONTENTS, kt2)), ot2 && (_4["#text"] = true), $4 && De(_4, ["html", "head", "body"]), _4.table && (De(_4, ["tbody"]), delete z4.tbody), t5.TRUSTED_TYPES_POLICY) {
        if (typeof t5.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof t5.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        x5 = t5.TRUSTED_TYPES_POLICY, C4 = x5.createHTML("");
      } else
        x5 === undefined && (x5 = function(t6, e5) {
          if (typeof t6 != "object" || typeof t6.createPolicy != "function")
            return null;
          let i5 = null;
          const n4 = "data-tt-policy-suffix";
          e5 && e5.hasAttribute(n4) && (i5 = e5.getAttribute(n4));
          const r5 = "dompurify" + (i5 ? "#" + i5 : "");
          try {
            return t6.createPolicy(r5, { createHTML: (t7) => t7, createScriptURL: (t7) => t7 });
          } catch (t7) {
            return console.warn("TrustedTypes policy " + r5 + " could not be created."), null;
          }
        }(m4, o3)), x5 !== null && typeof C4 == "string" && (C4 = x5.createHTML(""));
      ce && ce(t5), Tt2 = t5;
    }
  }, Nt2 = De({}, [...Pe, ...Me, ...Be]), It2 = De({}, [..._e, ...je]), Ot2 = function(t5) {
    be(i4.removed, { element: t5 });
    try {
      y4(t5).removeChild(t5);
    } catch (e5) {
      b4(t5);
    }
  }, Ft2 = function(t5, e5) {
    try {
      be(i4.removed, { attribute: e5.getAttributeNode(t5), from: e5 });
    } catch (t6) {
      be(i4.removed, { attribute: null, from: e5 });
    }
    if (e5.removeAttribute(t5), t5 === "is")
      if (tt2 || et2)
        try {
          Ot2(e5);
        } catch (t6) {}
      else
        try {
          e5.setAttribute(t5, "");
        } catch (t6) {}
  }, Pt2 = function(t5) {
    let e5 = null, i5 = null;
    if (Q3)
      t5 = "<remove></remove>" + t5;
    else {
      const e6 = xe(t5, /^[\r\n\t ]+/);
      i5 = e6 && e6[0];
    }
    St2 === "application/xhtml+xml" && bt2 === ft2 && (t5 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t5 + "</body></html>");
    const r5 = x5 ? x5.createHTML(t5) : t5;
    if (bt2 === ft2)
      try {
        e5 = new g5().parseFromString(r5, St2);
      } catch (t6) {}
    if (!e5 || !e5.documentElement) {
      e5 = E3.createDocument(bt2, "template", null);
      try {
        e5.documentElement.innerHTML = vt2 ? C4 : r5;
      } catch (t6) {}
    }
    const o4 = e5.body || e5.documentElement;
    return t5 && i5 && o4.insertBefore(n3.createTextNode(i5), o4.childNodes[0] || null), bt2 === ft2 ? k4.call(e5, $4 ? "html" : "body")[0] : $4 ? e5.documentElement : o4;
  }, Mt2 = function(t5) {
    return S3.call(t5.ownerDocument || t5, t5, u4.SHOW_ELEMENT | u4.SHOW_COMMENT | u4.SHOW_TEXT | u4.SHOW_PROCESSING_INSTRUCTION | u4.SHOW_CDATA_SECTION, null);
  }, Bt2 = function(t5) {
    return t5 instanceof d3 && (typeof t5.nodeName != "string" || typeof t5.textContent != "string" || typeof t5.removeChild != "function" || !(t5.attributes instanceof h4) || typeof t5.removeAttribute != "function" || typeof t5.setAttribute != "function" || typeof t5.namespaceURI != "string" || typeof t5.insertBefore != "function" || typeof t5.hasChildNodes != "function");
  }, _t2 = function(t5) {
    return typeof l80 == "function" && t5 instanceof l80;
  };
  function jt2(t5, e5, n4) {
    me(t5, (t6) => {
      t6.call(i4, e5, n4, Tt2);
    });
  }
  const Wt2 = function(t5) {
    let e5 = null;
    if (jt2(w5.beforeSanitizeElements, t5, null), Bt2(t5))
      return Ot2(t5), true;
    const n4 = kt2(t5.nodeName);
    if (jt2(w5.uponSanitizeElement, t5, { tagName: n4, allowedTags: _4 }), t5.hasChildNodes() && !_t2(t5.firstElementChild) && ke(/<[/\w!]/g, t5.innerHTML) && ke(/<[/\w!]/g, t5.textContent))
      return Ot2(t5), true;
    if (t5.nodeType === ri)
      return Ot2(t5), true;
    if (X3 && t5.nodeType === oi && ke(/<[/\w]/g, t5.data))
      return Ot2(t5), true;
    if (!_4[n4] || z4[n4]) {
      if (!z4[n4] && Vt2(n4)) {
        if (V4.tagNameCheck instanceof RegExp && ke(V4.tagNameCheck, n4))
          return false;
        if (V4.tagNameCheck instanceof Function && V4.tagNameCheck(n4))
          return false;
      }
      if (ot2 && !lt2[n4]) {
        const e6 = y4(t5) || t5.parentNode, i5 = A4(t5) || t5.childNodes;
        if (i5 && e6) {
          for (let n5 = i5.length - 1;n5 >= 0; --n5) {
            const r5 = f4(i5[n5], true);
            r5.__removalCount = (t5.__removalCount || 0) + 1, e6.insertBefore(r5, v4(t5));
          }
        }
      }
      return Ot2(t5), true;
    }
    return t5 instanceof c4 && !function(t6) {
      let e6 = y4(t6);
      e6 && e6.tagName || (e6 = { namespaceURI: bt2, tagName: "template" });
      const i5 = Ae(t6.tagName), n5 = Ae(e6.tagName);
      return !!At2[t6.namespaceURI] && (t6.namespaceURI === pt2 ? e6.namespaceURI === ft2 ? i5 === "svg" : e6.namespaceURI === mt2 ? i5 === "svg" && (n5 === "annotation-xml" || xt2[n5]) : Boolean(Nt2[i5]) : t6.namespaceURI === mt2 ? e6.namespaceURI === ft2 ? i5 === "math" : e6.namespaceURI === pt2 ? i5 === "math" && Ct2[n5] : Boolean(It2[i5]) : t6.namespaceURI === ft2 ? !(e6.namespaceURI === pt2 && !Ct2[n5]) && !(e6.namespaceURI === mt2 && !xt2[n5]) && !It2[i5] && (Et2[i5] || !Nt2[i5]) : !(St2 !== "application/xhtml+xml" || !At2[t6.namespaceURI]));
    }(t5) ? (Ot2(t5), true) : n4 !== "noscript" && n4 !== "noembed" && n4 !== "noframes" || !ke(/<\/no(script|embed|frames)/i, t5.innerHTML) ? (Y2 && t5.nodeType === ni && (e5 = t5.textContent, me([L4, D4, N4], (t6) => {
      e5 = Ce(e5, t6, " ");
    }), t5.textContent !== e5 && (be(i4.removed, { element: t5.cloneNode() }), t5.textContent = e5)), jt2(w5.afterSanitizeElements, t5, null), false) : (Ot2(t5), true);
  }, Ut2 = function(t5, e5, i5) {
    if (nt2 && (e5 === "id" || e5 === "name") && ((i5 in n3) || (i5 in wt2)))
      return false;
    if (J3 && !q4[e5] && ke(I4, e5))
      ;
    else if (H4 && ke(O3, e5))
      ;
    else if (!W3[e5] || q4[e5]) {
      if (!(Vt2(t5) && (V4.tagNameCheck instanceof RegExp && ke(V4.tagNameCheck, t5) || V4.tagNameCheck instanceof Function && V4.tagNameCheck(t5)) && (V4.attributeNameCheck instanceof RegExp && ke(V4.attributeNameCheck, e5) || V4.attributeNameCheck instanceof Function && V4.attributeNameCheck(e5)) || e5 === "is" && V4.allowCustomizedBuiltInElements && (V4.tagNameCheck instanceof RegExp && ke(V4.tagNameCheck, i5) || V4.tagNameCheck instanceof Function && V4.tagNameCheck(i5))))
        return false;
    } else if (dt2[e5])
      ;
    else if (ke(B4, Ce(i5, P4, "")))
      ;
    else if (e5 !== "src" && e5 !== "xlink:href" && e5 !== "href" || t5 === "script" || Ee(i5, "data:") !== 0 || !ut2[t5]) {
      if (K3 && !ke(F5, Ce(i5, P4, "")))
        ;
      else if (i5)
        return false;
    } else
      ;
    return true;
  }, Vt2 = function(t5) {
    return t5 !== "annotation-xml" && xe(t5, M3);
  }, zt2 = function(t5) {
    jt2(w5.beforeSanitizeAttributes, t5, null);
    const { attributes: e5 } = t5;
    if (!e5 || Bt2(t5))
      return;
    const n4 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: W3, forceKeepAttr: undefined };
    let r5 = e5.length;
    for (;r5--; ) {
      const o4 = e5[r5], { name: s5, namespaceURI: a5, value: l81 } = o4, c5 = kt2(s5);
      let u5 = s5 === "value" ? l81 : Se(l81);
      if (n4.attrName = c5, n4.attrValue = u5, n4.keepAttr = true, n4.forceKeepAttr = undefined, jt2(w5.uponSanitizeAttribute, t5, n4), u5 = n4.attrValue, !rt2 || c5 !== "id" && c5 !== "name" || (Ft2(s5, t5), u5 = "user-content-" + u5), X3 && ke(/((--!?|])>)|<\/(style|title)/i, u5)) {
        Ft2(s5, t5);
        continue;
      }
      if (n4.forceKeepAttr)
        continue;
      if (Ft2(s5, t5), !n4.keepAttr)
        continue;
      if (!G4 && ke(/\/>/i, u5)) {
        Ft2(s5, t5);
        continue;
      }
      Y2 && me([L4, D4, N4], (t6) => {
        u5 = Ce(u5, t6, " ");
      });
      const h5 = kt2(t5.nodeName);
      if (Ut2(h5, c5, u5)) {
        if (x5 && typeof m4 == "object" && typeof m4.getAttributeType == "function")
          if (a5)
            ;
          else
            switch (m4.getAttributeType(h5, c5)) {
              case "TrustedHTML":
                u5 = x5.createHTML(u5);
                break;
              case "TrustedScriptURL":
                u5 = x5.createScriptURL(u5);
            }
        try {
          a5 ? t5.setAttributeNS(a5, s5, u5) : t5.setAttribute(s5, u5), Bt2(t5) ? Ot2(t5) : fe(i4.removed);
        } catch (t6) {}
      }
    }
    jt2(w5.afterSanitizeAttributes, t5, null);
  }, qt2 = function t(e5) {
    let i5 = null;
    const n4 = Mt2(e5);
    for (jt2(w5.beforeSanitizeShadowDOM, e5, null);i5 = n4.nextNode(); )
      jt2(w5.uponSanitizeShadowNode, i5, null), Wt2(i5), zt2(i5), i5.content instanceof s4 && t(i5.content);
    jt2(w5.afterSanitizeShadowDOM, e5, null);
  };
  return i4.sanitize = function(t5) {
    let e5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, n4 = null, o4 = null, a5 = null, c5 = null;
    if (vt2 = !t5, vt2 && (t5 = "<!-->"), typeof t5 != "string" && !_t2(t5)) {
      if (typeof t5.toString != "function")
        throw Te("toString is not a function");
      if (typeof (t5 = t5.toString()) != "string")
        throw Te("dirty is not a string, aborting");
    }
    if (!i4.isSupported)
      return t5;
    if (Z3 || Dt2(e5), i4.removed = [], typeof t5 == "string" && (st2 = false), st2) {
      if (t5.nodeName) {
        const e6 = kt2(t5.nodeName);
        if (!_4[e6] || z4[e6])
          throw Te("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (t5 instanceof l80)
      n4 = Pt2("<!---->"), o4 = n4.ownerDocument.importNode(t5, true), o4.nodeType === ii && o4.nodeName === "BODY" || o4.nodeName === "HTML" ? n4 = o4 : n4.appendChild(o4);
    else {
      if (!tt2 && !Y2 && !$4 && t5.indexOf("<") === -1)
        return x5 && it2 ? x5.createHTML(t5) : t5;
      if (n4 = Pt2(t5), !n4)
        return tt2 ? null : it2 ? C4 : "";
    }
    n4 && Q3 && Ot2(n4.firstChild);
    const u5 = Mt2(st2 ? t5 : n4);
    for (;a5 = u5.nextNode(); )
      Wt2(a5), zt2(a5), a5.content instanceof s4 && qt2(a5.content);
    if (st2)
      return t5;
    if (tt2) {
      if (et2)
        for (c5 = R2.call(n4.ownerDocument);n4.firstChild; )
          c5.appendChild(n4.firstChild);
      else
        c5 = n4;
      return (W3.shadowroot || W3.shadowrootmode) && (c5 = T5.call(r4, c5, true)), c5;
    }
    let h5 = $4 ? n4.outerHTML : n4.innerHTML;
    return $4 && _4["!doctype"] && n4.ownerDocument && n4.ownerDocument.doctype && n4.ownerDocument.doctype.name && ke(Qe, n4.ownerDocument.doctype.name) && (h5 = "<!DOCTYPE " + n4.ownerDocument.doctype.name + `>
` + h5), Y2 && me([L4, D4, N4], (t6) => {
      h5 = Ce(h5, t6, " ");
    }), x5 && it2 ? x5.createHTML(h5) : h5;
  }, i4.setConfig = function() {
    Dt2(arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}), Z3 = true;
  }, i4.clearConfig = function() {
    Tt2 = null, Z3 = false;
  }, i4.isValidAttribute = function(t5, e5, i5) {
    Tt2 || Dt2({});
    const n4 = kt2(t5), r5 = kt2(e5);
    return Ut2(n4, r5, i5);
  }, i4.addHook = function(t5, e5) {
    typeof e5 == "function" && be(w5[t5], e5);
  }, i4.removeHook = function(t5, e5) {
    if (e5 !== undefined) {
      const i5 = pe(w5[t5], e5);
      return i5 === -1 ? undefined : ve(w5[t5], i5, 1)[0];
    }
    return fe(w5[t5]);
  }, i4.removeHooks = function(t5) {
    w5[t5] = [];
  }, i4.removeAllHooks = function() {
    w5 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
  }, i4;
}();
li.addHook("uponSanitizeAttribute", function(t5, e4) {
  /^data-trix-/.test(e4.attrName) && (e4.forceKeepAttr = true);
});
var ci = "style href src width height language class".split(" ");
var ui = "javascript:".split(" ");
var hi = "script iframe form noscript".split(" ");

class di extends q3 {
  static setHTML(t5, e4, i4) {
    const n3 = new this(e4, i4).sanitize(), r4 = n3.getHTML ? n3.getHTML() : n3.outerHTML;
    t5.innerHTML = r4;
  }
  static sanitize(t5, e4) {
    const i4 = new this(t5, e4);
    return i4.sanitize(), i4;
  }
  constructor(t5) {
    let { allowedAttributes: e4, forbiddenProtocols: i4, forbiddenElements: n3, purifyOptions: r4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(...arguments), this.allowedAttributes = e4 || ci, this.forbiddenProtocols = i4 || ui, this.forbiddenElements = n3 || hi, this.purifyOptions = r4 || {}, this.body = gi(t5);
  }
  sanitize() {
    this.sanitizeElements(), this.normalizeListElementNesting();
    const t5 = Object.assign({}, l79, this.purifyOptions);
    return li.setConfig(t5), this.body = li.sanitize(this.body), this.body;
  }
  getHTML() {
    return this.body.innerHTML;
  }
  getBody() {
    return this.body;
  }
  sanitizeElements() {
    const t5 = R(this.body), e4 = [];
    for (;t5.nextNode(); ) {
      const i4 = t5.currentNode;
      switch (i4.nodeType) {
        case Node.ELEMENT_NODE:
          this.elementIsRemovable(i4) ? e4.push(i4) : this.sanitizeElement(i4);
          break;
        case Node.COMMENT_NODE:
          e4.push(i4);
      }
    }
    return e4.forEach((t6) => S2(t6)), this.body;
  }
  sanitizeElement(t5) {
    return t5.hasAttribute("href") && this.forbiddenProtocols.includes(t5.protocol) && t5.removeAttribute("href"), Array.from(t5.attributes).forEach((e4) => {
      let { name: i4 } = e4;
      this.allowedAttributes.includes(i4) || i4.indexOf("data-trix") === 0 || t5.removeAttribute(i4);
    }), t5;
  }
  normalizeListElementNesting() {
    return Array.from(this.body.querySelectorAll("ul,ol")).forEach((t5) => {
      const e4 = t5.previousElementSibling;
      e4 && k3(e4) === "li" && e4.appendChild(t5);
    }), this.body;
  }
  elementIsRemovable(t5) {
    if ((t5 == null ? undefined : t5.nodeType) === Node.ELEMENT_NODE)
      return this.elementIsForbidden(t5) || this.elementIsntSerializable(t5);
  }
  elementIsForbidden(t5) {
    return this.forbiddenElements.includes(k3(t5));
  }
  elementIsntSerializable(t5) {
    return t5.getAttribute("data-trix-serialize") === "false" && !P3(t5);
  }
}
var gi = function() {
  let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  t5 = t5.replace(/<\/html[^>]*>[^]*$/i, "</html>");
  const e4 = document.implementation.createHTMLDocument("");
  return e4.documentElement.innerHTML = t5, Array.from(e4.head.querySelectorAll("style")).forEach((t6) => {
    e4.body.appendChild(t6);
  }), e4.body;
};
var { css: mi } = z3;

class pi extends ie {
  constructor() {
    super(...arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
  }
  createContentNodes() {
    return [];
  }
  createNodes() {
    let t5;
    const e4 = t5 = T4({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), i4 = this.getHref();
    return i4 && (t5 = T4({ tagName: "a", editable: false, attributes: { href: i4, tabindex: -1 } }), e4.appendChild(t5)), this.attachment.hasContent() ? di.setHTML(t5, this.attachment.getContent()) : this.createContentNodes().forEach((e5) => {
      t5.appendChild(e5);
    }), t5.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = T4({ tagName: "progress", attributes: { class: mi.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e4.appendChild(this.progressElement)), [fi("left"), e4, fi("right")];
  }
  createCaptionElement() {
    const t5 = T4({ tagName: "figcaption", className: mi.attachmentCaption }), e4 = this.attachmentPiece.getCaption();
    if (e4)
      t5.classList.add("".concat(mi.attachmentCaption, "--edited")), t5.textContent = e4;
    else {
      let e5, i4;
      const n3 = this.getCaptionConfig();
      if (n3.name && (e5 = this.attachment.getFilename()), n3.size && (i4 = this.attachment.getFormattedFilesize()), e5) {
        const i5 = T4({ tagName: "span", className: mi.attachmentName, textContent: e5 });
        t5.appendChild(i5);
      }
      if (i4) {
        e5 && t5.appendChild(document.createTextNode(" "));
        const n4 = T4({ tagName: "span", className: mi.attachmentSize, textContent: i4 });
        t5.appendChild(n4);
      }
    }
    return t5;
  }
  getClassName() {
    const t5 = [mi.attachment, "".concat(mi.attachment, "--").concat(this.attachment.getType())], e4 = this.attachment.getExtension();
    return e4 && t5.push("".concat(mi.attachment, "--").concat(e4)), t5.join(" ");
  }
  getData() {
    const t5 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, { attributes: e4 } = this.attachmentPiece;
    return e4.isEmpty() || (t5.trixAttributes = JSON.stringify(e4)), this.attachment.isPending() && (t5.trixSerialize = false), t5;
  }
  getHref() {
    if (!bi(this.attachment.getContent(), "a"))
      return this.attachment.getHref();
  }
  getCaptionConfig() {
    var t5;
    const e4 = this.attachment.getType(), n3 = kt((t5 = i3[e4]) === null || t5 === undefined ? undefined : t5.caption);
    return e4 === "file" && (n3.name = true), n3;
  }
  findProgressElement() {
    var t5;
    return (t5 = this.findElement()) === null || t5 === undefined ? undefined : t5.querySelector("progress");
  }
  attachmentDidChangeUploadProgress() {
    const t5 = this.attachment.getUploadProgress(), e4 = this.findProgressElement();
    e4 && (e4.value = t5);
  }
}
var fi = (t5) => T4({ tagName: "span", textContent: d2, data: { trixCursorTarget: t5, trixSerialize: false } });
var bi = function(t5, e4) {
  const i4 = T4("div");
  return di.setHTML(i4, t5 || ""), i4.querySelector(e4);
};

class vi extends pi {
  constructor() {
    super(...arguments), this.attachment.previewDelegate = this;
  }
  createContentNodes() {
    return this.image = T4({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
  }
  createCaptionElement() {
    const t5 = super.createCaptionElement(...arguments);
    return t5.textContent || t5.setAttribute("data-trix-placeholder", c3.captionPlaceholder), t5;
  }
  refresh(t5) {
    var e4;
    t5 || (t5 = (e4 = this.findElement()) === null || e4 === undefined ? undefined : e4.querySelector("img"));
    if (t5)
      return this.updateAttributesForImage(t5);
  }
  updateAttributesForImage(t5) {
    const e4 = this.attachment.getURL(), i4 = this.attachment.getPreviewURL();
    if (t5.src = i4 || e4, i4 === e4)
      t5.removeAttribute("data-trix-serialized-attributes");
    else {
      const i5 = JSON.stringify({ src: e4 });
      t5.setAttribute("data-trix-serialized-attributes", i5);
    }
    const n3 = this.attachment.getWidth(), r4 = this.attachment.getHeight();
    n3 != null && (t5.width = n3), r4 != null && (t5.height = r4);
    const o3 = ["imageElement", this.attachment.id, t5.src, t5.width, t5.height].join("/");
    t5.dataset.trixStoreKey = o3;
  }
  attachmentDidChangeAttributes() {
    return this.refresh(this.image), this.refresh();
  }
}

class Ai extends ie {
  constructor() {
    super(...arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), this.textConfig = this.options.textConfig, this.context = this.options.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
  }
  createNodes() {
    let t5 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes();
    const e4 = this.createElement();
    if (e4) {
      const i4 = function(t6) {
        for (;(e5 = t6) !== null && e5 !== undefined && e5.firstElementChild; ) {
          var e5;
          t6 = t6.firstElementChild;
        }
        return t6;
      }(e4);
      Array.from(t5).forEach((t6) => {
        i4.appendChild(t6);
      }), t5 = [e4];
    }
    return t5;
  }
  createAttachmentNodes() {
    const t5 = this.attachment.isPreviewable() ? vi : pi;
    return this.createChildView(t5, this.piece.attachment, { piece: this.piece }).getNodes();
  }
  createStringNodes() {
    var t5;
    if ((t5 = this.textConfig) !== null && t5 !== undefined && t5.plaintext)
      return [document.createTextNode(this.string)];
    {
      const t6 = [], e4 = this.string.split(`
`);
      for (let i4 = 0;i4 < e4.length; i4++) {
        const n3 = e4[i4];
        if (i4 > 0) {
          const e5 = T4("br");
          t6.push(e5);
        }
        if (n3.length) {
          const e5 = document.createTextNode(this.preserveSpaces(n3));
          t6.push(e5);
        }
      }
      return t6;
    }
  }
  createElement() {
    let t5, e4, i4;
    const n3 = {};
    for (e4 in this.attributes) {
      i4 = this.attributes[e4];
      const o3 = ft(e4);
      if (o3) {
        if (o3.tagName) {
          var r4;
          const e5 = T4(o3.tagName);
          r4 ? (r4.appendChild(e5), r4 = e5) : t5 = r4 = e5;
        }
        if (o3.styleProperty && (n3[o3.styleProperty] = i4), o3.style)
          for (e4 in o3.style)
            i4 = o3.style[e4], n3[e4] = i4;
      }
    }
    if (Object.keys(n3).length)
      for (e4 in t5 || (t5 = T4("span")), n3)
        i4 = n3[e4], t5.style[e4] = i4;
    return t5;
  }
  createContainerElement() {
    for (const t5 in this.attributes) {
      const e4 = this.attributes[t5], i4 = ft(t5);
      if (i4 && i4.groupTagName) {
        const n3 = {};
        return n3[t5] = e4, T4(i4.groupTagName, n3);
      }
    }
  }
  preserveSpaces(t5) {
    return this.context.isLast && (t5 = t5.replace(/\ $/, g4)), t5 = t5.replace(/(\S)\ {3}(\S)/g, "$1 ".concat(g4, " $2")).replace(/\ {2}/g, "".concat(g4, " ")).replace(/\ {2}/g, " ".concat(g4)), (this.context.isFirst || this.context.followsWhitespace) && (t5 = t5.replace(/^\ /, g4)), t5;
  }
}

class yi extends ie {
  constructor() {
    super(...arguments), this.text = this.object, this.textConfig = this.options.textConfig;
  }
  createNodes() {
    const t5 = [], e4 = $t.groupObjects(this.getPieces()), i4 = e4.length - 1;
    for (let r4 = 0;r4 < e4.length; r4++) {
      const o3 = e4[r4], s4 = {};
      r4 === 0 && (s4.isFirst = true), r4 === i4 && (s4.isLast = true), xi(n3) && (s4.followsWhitespace = true);
      const a4 = this.findOrCreateCachedChildView(Ai, o3, { textConfig: this.textConfig, context: s4 });
      t5.push(...Array.from(a4.getNodes() || []));
      var n3 = o3;
    }
    return t5;
  }
  getPieces() {
    return Array.from(this.text.getPieces()).filter((t5) => !t5.hasAttribute("blockBreak"));
  }
}
var xi = (t5) => /\s$/.test(t5 == null ? undefined : t5.toString());
var { css: Ci } = z3;

class Ei extends ie {
  constructor() {
    super(...arguments), this.block = this.object, this.attributes = this.block.getAttributes();
  }
  createNodes() {
    const t5 = [document.createComment("block")];
    if (this.block.isEmpty())
      t5.push(T4("br"));
    else {
      var e4;
      const i4 = (e4 = mt(this.block.getLastAttribute())) === null || e4 === undefined ? undefined : e4.text, n3 = this.findOrCreateCachedChildView(yi, this.block.text, { textConfig: i4 });
      t5.push(...Array.from(n3.getNodes() || [])), this.shouldAddExtraNewlineElement() && t5.push(T4("br"));
    }
    if (this.attributes.length)
      return t5;
    {
      let e5;
      const { tagName: i4 } = n2.default;
      this.block.isRTL() && (e5 = { dir: "rtl" });
      const r4 = T4({ tagName: i4, attributes: e5 });
      return t5.forEach((t6) => r4.appendChild(t6)), [r4];
    }
  }
  createContainerElement(t5) {
    const e4 = {};
    let i4;
    const n3 = this.attributes[t5], { tagName: r4, htmlAttributes: o3 = [] } = mt(n3);
    if (t5 === 0 && this.block.isRTL() && Object.assign(e4, { dir: "rtl" }), n3 === "attachmentGallery") {
      const t6 = this.block.getBlockBreakPosition();
      i4 = "".concat(Ci.attachmentGallery, " ").concat(Ci.attachmentGallery, "--").concat(t6);
    }
    return Object.entries(this.block.htmlAttributes).forEach((t6) => {
      let [i5, n4] = t6;
      o3.includes(i5) && (e4[i5] = n4);
    }), T4({ tagName: r4, className: i4, attributes: e4 });
  }
  shouldAddExtraNewlineElement() {
    return /\n\n$/.test(this.block.toString());
  }
}

class Si extends ie {
  static render(t5) {
    const e4 = T4("div"), i4 = new this(t5, { element: e4 });
    return i4.render(), i4.sync(), e4;
  }
  constructor() {
    super(...arguments), this.element = this.options.element, this.elementStore = new Qt, this.setDocument(this.object);
  }
  setDocument(t5) {
    t5.isEqualTo(this.document) || (this.document = this.object = t5);
  }
  render() {
    if (this.childViews = [], this.shadowElement = T4("div"), !this.document.isEmpty()) {
      const t5 = $t.groupObjects(this.document.getBlocks(), { asTree: true });
      Array.from(t5).forEach((t6) => {
        const e4 = this.findOrCreateCachedChildView(Ei, t6);
        Array.from(e4.getNodes()).map((t7) => this.shadowElement.appendChild(t7));
      });
    }
  }
  isSynced() {
    return ki(this.shadowElement, this.element);
  }
  sync() {
    const t5 = this.createDocumentFragmentForSync();
    for (;this.element.lastChild; )
      this.element.removeChild(this.element.lastChild);
    return this.element.appendChild(t5), this.didSync();
  }
  didSync() {
    return this.elementStore.reset(Ri(this.element)), Rt(() => this.garbageCollectCachedViews());
  }
  createDocumentFragmentForSync() {
    const t5 = document.createDocumentFragment();
    return Array.from(this.shadowElement.childNodes).forEach((e4) => {
      t5.appendChild(e4.cloneNode(true));
    }), Array.from(Ri(t5)).forEach((t6) => {
      const e4 = this.elementStore.remove(t6);
      e4 && t6.parentNode.replaceChild(e4, t6);
    }), t5;
  }
}
var Ri = (t5) => t5.querySelectorAll("[data-trix-store-key]");
var ki = (t5, e4) => Ti(t5.innerHTML) === Ti(e4.innerHTML);
var Ti = (t5) => t5.replace(/&nbsp;/g, " ");
function wi(t5) {
  var e4, i4;
  function n3(e5, i5) {
    try {
      var o3 = t5[e5](i5), s4 = o3.value, a4 = s4 instanceof Li;
      Promise.resolve(a4 ? s4.v : s4).then(function(i6) {
        if (a4) {
          var l80 = e5 === "return" ? "return" : "next";
          if (!s4.k || i6.done)
            return n3(l80, i6);
          i6 = t5[l80](i6).value;
        }
        r4(o3.done ? "return" : "normal", i6);
      }, function(t6) {
        n3("throw", t6);
      });
    } catch (t6) {
      r4("throw", t6);
    }
  }
  function r4(t6, r5) {
    switch (t6) {
      case "return":
        e4.resolve({ value: r5, done: true });
        break;
      case "throw":
        e4.reject(r5);
        break;
      default:
        e4.resolve({ value: r5, done: false });
    }
    (e4 = e4.next) ? n3(e4.key, e4.arg) : i4 = null;
  }
  this._invoke = function(t6, r5) {
    return new Promise(function(o3, s4) {
      var a4 = { key: t6, arg: r5, resolve: o3, reject: s4, next: null };
      i4 ? i4 = i4.next = a4 : (e4 = i4 = a4, n3(t6, r5));
    });
  }, typeof t5.return != "function" && (this.return = undefined);
}
function Li(t5, e4) {
  this.v = t5, this.k = e4;
}
function Di(t5, e4, i4) {
  return (e4 = Ni(e4)) in t5 ? Object.defineProperty(t5, e4, { value: i4, enumerable: true, configurable: true, writable: true }) : t5[e4] = i4, t5;
}
function Ni(t5) {
  var e4 = function(t6, e5) {
    if (typeof t6 != "object" || t6 === null)
      return t6;
    var i4 = t6[Symbol.toPrimitive];
    if (i4 !== undefined) {
      var n3 = i4.call(t6, e5 || "default");
      if (typeof n3 != "object")
        return n3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e5 === "string" ? String : Number)(t6);
  }(t5, "string");
  return typeof e4 == "symbol" ? e4 : String(e4);
}
wi.prototype[typeof Symbol == "function" && Symbol.asyncIterator || "@@asyncIterator"] = function() {
  return this;
}, wi.prototype.next = function(t5) {
  return this._invoke("next", t5);
}, wi.prototype.throw = function(t5) {
  return this._invoke("throw", t5);
}, wi.prototype.return = function(t5) {
  return this._invoke("return", t5);
};
function Ii(t5, e4) {
  return Pi(t5, Fi(t5, e4, "get"));
}
function Oi(t5, e4, i4) {
  return Mi(t5, Fi(t5, e4, "set"), i4), i4;
}
function Fi(t5, e4, i4) {
  if (!e4.has(t5))
    throw new TypeError("attempted to " + i4 + " private field on non-instance");
  return e4.get(t5);
}
function Pi(t5, e4) {
  return e4.get ? e4.get.call(t5) : e4.value;
}
function Mi(t5, e4, i4) {
  if (e4.set)
    e4.set.call(t5, i4);
  else {
    if (!e4.writable)
      throw new TypeError("attempted to set read only private field");
    e4.value = i4;
  }
}
function Bi(t5, e4, i4) {
  if (!e4.has(t5))
    throw new TypeError("attempted to get private field on non-instance");
  return i4;
}
function _i(t5, e4) {
  if (e4.has(t5))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function ji(t5, e4, i4) {
  _i(t5, e4), e4.set(t5, i4);
}

class Wi extends rt {
  static registerType(t5, e4) {
    e4.type = t5, this.types[t5] = e4;
  }
  static fromJSON(t5) {
    const e4 = this.types[t5.type];
    if (e4)
      return e4.fromJSON(t5);
  }
  constructor(t5) {
    let e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(...arguments), this.attributes = Ht.box(e4);
  }
  copyWithAttributes(t5) {
    return new this.constructor(this.getValue(), t5);
  }
  copyWithAdditionalAttributes(t5) {
    return this.copyWithAttributes(this.attributes.merge(t5));
  }
  copyWithoutAttribute(t5) {
    return this.copyWithAttributes(this.attributes.remove(t5));
  }
  copy() {
    return this.copyWithAttributes(this.attributes);
  }
  getAttribute(t5) {
    return this.attributes.get(t5);
  }
  getAttributesHash() {
    return this.attributes;
  }
  getAttributes() {
    return this.attributes.toObject();
  }
  hasAttribute(t5) {
    return this.attributes.has(t5);
  }
  hasSameStringValueAsPiece(t5) {
    return t5 && this.toString() === t5.toString();
  }
  hasSameAttributesAsPiece(t5) {
    return t5 && (this.attributes === t5.attributes || this.attributes.isEqualTo(t5.attributes));
  }
  isBlockBreak() {
    return false;
  }
  isEqualTo(t5) {
    return super.isEqualTo(...arguments) || this.hasSameConstructorAs(t5) && this.hasSameStringValueAsPiece(t5) && this.hasSameAttributesAsPiece(t5);
  }
  isEmpty() {
    return this.length === 0;
  }
  isSerializable() {
    return true;
  }
  toJSON() {
    return { type: this.constructor.type, attributes: this.getAttributes() };
  }
  contentsForInspection() {
    return { type: this.constructor.type, attributes: this.attributes.inspect() };
  }
  canBeGrouped() {
    return this.hasAttribute("href");
  }
  canBeGroupedWith(t5) {
    return this.getAttribute("href") === t5.getAttribute("href");
  }
  getLength() {
    return this.length;
  }
  canBeConsolidatedWith(t5) {
    return false;
  }
}
Di(Wi, "types", {});

class Ui extends ee {
  constructor(t5) {
    super(...arguments), this.url = t5;
  }
  perform(t5) {
    const e4 = new Image;
    e4.onload = () => (e4.width = this.width = e4.naturalWidth, e4.height = this.height = e4.naturalHeight, t5(true, e4)), e4.onerror = () => t5(false), e4.src = this.url;
  }
}

class Vi extends rt {
  static attachmentForFile(t5) {
    const e4 = new this(this.attributesForFile(t5));
    return e4.setFile(t5), e4;
  }
  static attributesForFile(t5) {
    return new Ht({ filename: t5.name, filesize: t5.size, contentType: t5.type });
  }
  static fromJSON(t5) {
    return new this(t5);
  }
  constructor() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(t5), this.releaseFile = this.releaseFile.bind(this), this.attributes = Ht.box(t5), this.didChangeAttributes();
  }
  getAttribute(t5) {
    return this.attributes.get(t5);
  }
  hasAttribute(t5) {
    return this.attributes.has(t5);
  }
  getAttributes() {
    return this.attributes.toObject();
  }
  setAttributes() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const e4 = this.attributes.merge(t5);
    var i4, n3, r4, o3;
    if (!this.attributes.isEqualTo(e4))
      return this.attributes = e4, this.didChangeAttributes(), (i4 = this.previewDelegate) === null || i4 === undefined || (n3 = i4.attachmentDidChangeAttributes) === null || n3 === undefined || n3.call(i4, this), (r4 = this.delegate) === null || r4 === undefined || (o3 = r4.attachmentDidChangeAttributes) === null || o3 === undefined ? undefined : o3.call(r4, this);
  }
  didChangeAttributes() {
    if (this.isPreviewable())
      return this.preloadURL();
  }
  isPending() {
    return this.file != null && !(this.getURL() || this.getHref());
  }
  isPreviewable() {
    return this.attributes.has("previewable") ? this.attributes.get("previewable") : Vi.previewablePattern.test(this.getContentType());
  }
  getType() {
    return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
  }
  getURL() {
    return this.attributes.get("url");
  }
  getHref() {
    return this.attributes.get("href");
  }
  getFilename() {
    return this.attributes.get("filename") || "";
  }
  getFilesize() {
    return this.attributes.get("filesize");
  }
  getFormattedFilesize() {
    const t5 = this.attributes.get("filesize");
    return typeof t5 == "number" ? h3.formatter(t5) : "";
  }
  getExtension() {
    var t5;
    return (t5 = this.getFilename().match(/\.(\w+)$/)) === null || t5 === undefined ? undefined : t5[1].toLowerCase();
  }
  getContentType() {
    return this.attributes.get("contentType");
  }
  hasContent() {
    return this.attributes.has("content");
  }
  getContent() {
    return this.attributes.get("content");
  }
  getWidth() {
    return this.attributes.get("width");
  }
  getHeight() {
    return this.attributes.get("height");
  }
  getFile() {
    return this.file;
  }
  setFile(t5) {
    if (this.file = t5, this.isPreviewable())
      return this.preloadFile();
  }
  releaseFile() {
    this.releasePreloadedFile(), this.file = null;
  }
  getUploadProgress() {
    return this.uploadProgress != null ? this.uploadProgress : 0;
  }
  setUploadProgress(t5) {
    var e4, i4;
    if (this.uploadProgress !== t5)
      return this.uploadProgress = t5, (e4 = this.uploadProgressDelegate) === null || e4 === undefined || (i4 = e4.attachmentDidChangeUploadProgress) === null || i4 === undefined ? undefined : i4.call(e4, this);
  }
  toJSON() {
    return this.getAttributes();
  }
  getCacheKey() {
    return [super.getCacheKey(...arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
  }
  getPreviewURL() {
    return this.previewURL || this.preloadingURL;
  }
  setPreviewURL(t5) {
    var e4, i4, n3, r4;
    if (t5 !== this.getPreviewURL())
      return this.previewURL = t5, (e4 = this.previewDelegate) === null || e4 === undefined || (i4 = e4.attachmentDidChangeAttributes) === null || i4 === undefined || i4.call(e4, this), (n3 = this.delegate) === null || n3 === undefined || (r4 = n3.attachmentDidChangePreviewURL) === null || r4 === undefined ? undefined : r4.call(n3, this);
  }
  preloadURL() {
    return this.preload(this.getURL(), this.releaseFile);
  }
  preloadFile() {
    if (this.file)
      return this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL);
  }
  releasePreloadedFile() {
    this.fileObjectURL && (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null);
  }
  preload(t5, e4) {
    if (t5 && t5 !== this.getPreviewURL()) {
      this.preloadingURL = t5;
      return new Ui(t5).then((i4) => {
        let { width: n3, height: r4 } = i4;
        return this.getWidth() && this.getHeight() || this.setAttributes({ width: n3, height: r4 }), this.preloadingURL = null, this.setPreviewURL(t5), e4 == null ? undefined : e4();
      }).catch(() => (this.preloadingURL = null, e4 == null ? undefined : e4()));
    }
  }
}
Di(Vi, "previewablePattern", /^image(\/(gif|png|webp|jpe?g)|$)/);

class zi extends Wi {
  static fromJSON(t5) {
    return new this(Vi.fromJSON(t5.attachment), t5.attributes);
  }
  constructor(t5) {
    super(...arguments), this.attachment = t5, this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
  }
  ensureAttachmentExclusivelyHasAttribute(t5) {
    this.hasAttribute(t5) && (this.attachment.hasAttribute(t5) || this.attachment.setAttributes(this.attributes.slice([t5])), this.attributes = this.attributes.remove(t5));
  }
  removeProhibitedAttributes() {
    const t5 = this.attributes.slice(zi.permittedAttributes);
    t5.isEqualTo(this.attributes) || (this.attributes = t5);
  }
  getValue() {
    return this.attachment;
  }
  isSerializable() {
    return !this.attachment.isPending();
  }
  getCaption() {
    return this.attributes.get("caption") || "";
  }
  isEqualTo(t5) {
    var e4;
    return super.isEqualTo(t5) && this.attachment.id === (t5 == null || (e4 = t5.attachment) === null || e4 === undefined ? undefined : e4.id);
  }
  toString() {
    return "";
  }
  toJSON() {
    const t5 = super.toJSON(...arguments);
    return t5.attachment = this.attachment, t5;
  }
  getCacheKey() {
    return [super.getCacheKey(...arguments), this.attachment.getCacheKey()].join("/");
  }
  toConsole() {
    return JSON.stringify(this.toString());
  }
}
Di(zi, "permittedAttributes", ["caption", "presentation"]), Wi.registerType("attachment", zi);

class qi extends Wi {
  static fromJSON(t5) {
    return new this(t5.string, t5.attributes);
  }
  constructor(t5) {
    super(...arguments), this.string = ((t6) => t6.replace(/\r\n?/g, `
`))(t5), this.length = this.string.length;
  }
  getValue() {
    return this.string;
  }
  toString() {
    return this.string.toString();
  }
  isBlockBreak() {
    return this.toString() === `
` && this.getAttribute("blockBreak") === true;
  }
  toJSON() {
    const t5 = super.toJSON(...arguments);
    return t5.string = this.string, t5;
  }
  canBeConsolidatedWith(t5) {
    return t5 && this.hasSameConstructorAs(t5) && this.hasSameAttributesAsPiece(t5);
  }
  consolidateWith(t5) {
    return new this.constructor(this.toString() + t5.toString(), this.attributes);
  }
  splitAtOffset(t5) {
    let e4, i4;
    return t5 === 0 ? (e4 = null, i4 = this) : t5 === this.length ? (e4 = this, i4 = null) : (e4 = new this.constructor(this.string.slice(0, t5), this.attributes), i4 = new this.constructor(this.string.slice(t5), this.attributes)), [e4, i4];
  }
  toConsole() {
    let { string: t5 } = this;
    return t5.length > 15 && (t5 = t5.slice(0, 14) + ""), JSON.stringify(t5.toString());
  }
}
Wi.registerType("string", qi);

class Hi extends rt {
  static box(t5) {
    return t5 instanceof this ? t5 : new this(t5);
  }
  constructor() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(...arguments), this.objects = t5.slice(0), this.length = this.objects.length;
  }
  indexOf(t5) {
    return this.objects.indexOf(t5);
  }
  splice() {
    for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0;i4 < t5; i4++)
      e4[i4] = arguments[i4];
    return new this.constructor(st(this.objects, ...e4));
  }
  eachObject(t5) {
    return this.objects.map((e4, i4) => t5(e4, i4));
  }
  insertObjectAtIndex(t5, e4) {
    return this.splice(e4, 0, t5);
  }
  insertSplittableListAtIndex(t5, e4) {
    return this.splice(e4, 0, ...t5.objects);
  }
  insertSplittableListAtPosition(t5, e4) {
    const [i4, n3] = this.splitObjectAtPosition(e4);
    return new this.constructor(i4).insertSplittableListAtIndex(t5, n3);
  }
  editObjectAtIndex(t5, e4) {
    return this.replaceObjectAtIndex(e4(this.objects[t5]), t5);
  }
  replaceObjectAtIndex(t5, e4) {
    return this.splice(e4, 1, t5);
  }
  removeObjectAtIndex(t5) {
    return this.splice(t5, 1);
  }
  getObjectAtIndex(t5) {
    return this.objects[t5];
  }
  getSplittableListInRange(t5) {
    const [e4, i4, n3] = this.splitObjectsAtRange(t5);
    return new this.constructor(e4.slice(i4, n3 + 1));
  }
  selectSplittableList(t5) {
    const e4 = this.objects.filter((e5) => t5(e5));
    return new this.constructor(e4);
  }
  removeObjectsInRange(t5) {
    const [e4, i4, n3] = this.splitObjectsAtRange(t5);
    return new this.constructor(e4).splice(i4, n3 - i4 + 1);
  }
  transformObjectsInRange(t5, e4) {
    const [i4, n3, r4] = this.splitObjectsAtRange(t5), o3 = i4.map((t6, i5) => n3 <= i5 && i5 <= r4 ? e4(t6) : t6);
    return new this.constructor(o3);
  }
  splitObjectsAtRange(t5) {
    let e4, [i4, n3, r4] = this.splitObjectAtPosition(Ki(t5));
    return [i4, e4] = new this.constructor(i4).splitObjectAtPosition(Gi(t5) + r4), [i4, n3, e4 - 1];
  }
  getObjectAtPosition(t5) {
    const { index: e4 } = this.findIndexAndOffsetAtPosition(t5);
    return this.objects[e4];
  }
  splitObjectAtPosition(t5) {
    let e4, i4;
    const { index: n3, offset: r4 } = this.findIndexAndOffsetAtPosition(t5), o3 = this.objects.slice(0);
    if (n3 != null)
      if (r4 === 0)
        e4 = n3, i4 = 0;
      else {
        const t6 = this.getObjectAtIndex(n3), [s4, a4] = t6.splitAtOffset(r4);
        o3.splice(n3, 1, s4, a4), e4 = n3 + 1, i4 = s4.getLength() - r4;
      }
    else
      e4 = o3.length, i4 = 0;
    return [o3, e4, i4];
  }
  consolidate() {
    const t5 = [];
    let e4 = this.objects[0];
    return this.objects.slice(1).forEach((i4) => {
      var n3, r4;
      (n3 = (r4 = e4).canBeConsolidatedWith) !== null && n3 !== undefined && n3.call(r4, i4) ? e4 = e4.consolidateWith(i4) : (t5.push(e4), e4 = i4);
    }), e4 && t5.push(e4), new this.constructor(t5);
  }
  consolidateFromIndexToIndex(t5, e4) {
    const i4 = this.objects.slice(0).slice(t5, e4 + 1), n3 = new this.constructor(i4).consolidate().toArray();
    return this.splice(t5, i4.length, ...n3);
  }
  findIndexAndOffsetAtPosition(t5) {
    let e4, i4 = 0;
    for (e4 = 0;e4 < this.objects.length; e4++) {
      const n3 = i4 + this.objects[e4].getLength();
      if (i4 <= t5 && t5 < n3)
        return { index: e4, offset: t5 - i4 };
      i4 = n3;
    }
    return { index: null, offset: null };
  }
  findPositionAtIndexAndOffset(t5, e4) {
    let i4 = 0;
    for (let n3 = 0;n3 < this.objects.length; n3++) {
      const r4 = this.objects[n3];
      if (n3 < t5)
        i4 += r4.getLength();
      else if (n3 === t5) {
        i4 += e4;
        break;
      }
    }
    return i4;
  }
  getEndPosition() {
    return this.endPosition == null && (this.endPosition = 0, this.objects.forEach((t5) => this.endPosition += t5.getLength())), this.endPosition;
  }
  toString() {
    return this.objects.join("");
  }
  toArray() {
    return this.objects.slice(0);
  }
  toJSON() {
    return this.toArray();
  }
  isEqualTo(t5) {
    return super.isEqualTo(...arguments) || Ji(this.objects, t5 == null ? undefined : t5.objects);
  }
  contentsForInspection() {
    return { objects: "[".concat(this.objects.map((t5) => t5.inspect()).join(", "), "]") };
  }
}
var Ji = function(t5) {
  let e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (t5.length !== e4.length)
    return false;
  let i4 = true;
  for (let n3 = 0;n3 < t5.length; n3++) {
    const r4 = t5[n3];
    i4 && !r4.isEqualTo(e4[n3]) && (i4 = false);
  }
  return i4;
};
var Ki = (t5) => t5[0];
var Gi = (t5) => t5[1];

class Yi extends rt {
  static textForAttachmentWithAttributes(t5, e4) {
    return new this([new zi(t5, e4)]);
  }
  static textForStringWithAttributes(t5, e4) {
    return new this([new qi(t5, e4)]);
  }
  static fromJSON(t5) {
    return new this(Array.from(t5).map((t6) => Wi.fromJSON(t6)));
  }
  constructor() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(...arguments);
    const e4 = t5.filter((t6) => !t6.isEmpty());
    this.pieceList = new Hi(e4);
  }
  copy() {
    return this.copyWithPieceList(this.pieceList);
  }
  copyWithPieceList(t5) {
    return new this.constructor(t5.consolidate().toArray());
  }
  copyUsingObjectMap(t5) {
    const e4 = this.getPieces().map((e5) => t5.find(e5) || e5);
    return new this.constructor(e4);
  }
  appendText(t5) {
    return this.insertTextAtPosition(t5, this.getLength());
  }
  insertTextAtPosition(t5, e4) {
    return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t5.pieceList, e4));
  }
  removeTextAtRange(t5) {
    return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t5));
  }
  replaceTextAtRange(t5, e4) {
    return this.removeTextAtRange(e4).insertTextAtPosition(t5, e4[0]);
  }
  moveTextFromRangeToPosition(t5, e4) {
    if (t5[0] <= e4 && e4 <= t5[1])
      return;
    const i4 = this.getTextAtRange(t5), n3 = i4.getLength();
    return t5[0] < e4 && (e4 -= n3), this.removeTextAtRange(t5).insertTextAtPosition(i4, e4);
  }
  addAttributeAtRange(t5, e4, i4) {
    const n3 = {};
    return n3[t5] = e4, this.addAttributesAtRange(n3, i4);
  }
  addAttributesAtRange(t5, e4) {
    return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithAdditionalAttributes(t5)));
  }
  removeAttributeAtRange(t5, e4) {
    return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithoutAttribute(t5)));
  }
  setAttributesAtRange(t5, e4) {
    return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithAttributes(t5)));
  }
  getAttributesAtPosition(t5) {
    var e4;
    return ((e4 = this.pieceList.getObjectAtPosition(t5)) === null || e4 === undefined ? undefined : e4.getAttributes()) || {};
  }
  getCommonAttributes() {
    const t5 = Array.from(this.pieceList.toArray()).map((t6) => t6.getAttributes());
    return Ht.fromCommonAttributesOfObjects(t5).toObject();
  }
  getCommonAttributesAtRange(t5) {
    return this.getTextAtRange(t5).getCommonAttributes() || {};
  }
  getExpandedRangeForAttributeAtOffset(t5, e4) {
    let i4, n3 = i4 = e4;
    const r4 = this.getLength();
    for (;n3 > 0 && this.getCommonAttributesAtRange([n3 - 1, i4])[t5]; )
      n3--;
    for (;i4 < r4 && this.getCommonAttributesAtRange([e4, i4 + 1])[t5]; )
      i4++;
    return [n3, i4];
  }
  getTextAtRange(t5) {
    return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t5));
  }
  getStringAtRange(t5) {
    return this.pieceList.getSplittableListInRange(t5).toString();
  }
  getStringAtPosition(t5) {
    return this.getStringAtRange([t5, t5 + 1]);
  }
  startsWithString(t5) {
    return this.getStringAtRange([0, t5.length]) === t5;
  }
  endsWithString(t5) {
    const e4 = this.getLength();
    return this.getStringAtRange([e4 - t5.length, e4]) === t5;
  }
  getAttachmentPieces() {
    return this.pieceList.toArray().filter((t5) => !!t5.attachment);
  }
  getAttachments() {
    return this.getAttachmentPieces().map((t5) => t5.attachment);
  }
  getAttachmentAndPositionById(t5) {
    let e4 = 0;
    for (const n3 of this.pieceList.toArray()) {
      var i4;
      if (((i4 = n3.attachment) === null || i4 === undefined ? undefined : i4.id) === t5)
        return { attachment: n3.attachment, position: e4 };
      e4 += n3.length;
    }
    return { attachment: null, position: null };
  }
  getAttachmentById(t5) {
    const { attachment: e4 } = this.getAttachmentAndPositionById(t5);
    return e4;
  }
  getRangeOfAttachment(t5) {
    const e4 = this.getAttachmentAndPositionById(t5.id), i4 = e4.position;
    if (t5 = e4.attachment)
      return [i4, i4 + 1];
  }
  updateAttributesForAttachment(t5, e4) {
    const i4 = this.getRangeOfAttachment(e4);
    return i4 ? this.addAttributesAtRange(t5, i4) : this;
  }
  getLength() {
    return this.pieceList.getEndPosition();
  }
  isEmpty() {
    return this.getLength() === 0;
  }
  isEqualTo(t5) {
    var e4;
    return super.isEqualTo(t5) || (t5 == null || (e4 = t5.pieceList) === null || e4 === undefined ? undefined : e4.isEqualTo(this.pieceList));
  }
  isBlockBreak() {
    return this.getLength() === 1 && this.pieceList.getObjectAtIndex(0).isBlockBreak();
  }
  eachPiece(t5) {
    return this.pieceList.eachObject(t5);
  }
  getPieces() {
    return this.pieceList.toArray();
  }
  getPieceAtPosition(t5) {
    return this.pieceList.getObjectAtPosition(t5);
  }
  contentsForInspection() {
    return { pieceList: this.pieceList.inspect() };
  }
  toSerializableText() {
    const t5 = this.pieceList.selectSplittableList((t6) => t6.isSerializable());
    return this.copyWithPieceList(t5);
  }
  toString() {
    return this.pieceList.toString();
  }
  toJSON() {
    return this.pieceList.toJSON();
  }
  toConsole() {
    return JSON.stringify(this.pieceList.toArray().map((t5) => JSON.parse(t5.toConsole())));
  }
  getDirection() {
    return lt(this.toString());
  }
  isRTL() {
    return this.getDirection() === "rtl";
  }
}

class Xi extends rt {
  static fromJSON(t5) {
    return new this(Yi.fromJSON(t5.text), t5.attributes, t5.htmlAttributes);
  }
  constructor(t5, e4, i4) {
    super(...arguments), this.text = $i(t5 || new Yi), this.attributes = e4 || [], this.htmlAttributes = i4 || {};
  }
  isEmpty() {
    return this.text.isBlockBreak();
  }
  isEqualTo(t5) {
    return !!super.isEqualTo(t5) || this.text.isEqualTo(t5 == null ? undefined : t5.text) && ot(this.attributes, t5 == null ? undefined : t5.attributes) && Tt(this.htmlAttributes, t5 == null ? undefined : t5.htmlAttributes);
  }
  copyWithText(t5) {
    return new Xi(t5, this.attributes, this.htmlAttributes);
  }
  copyWithoutText() {
    return this.copyWithText(null);
  }
  copyWithAttributes(t5) {
    return new Xi(this.text, t5, this.htmlAttributes);
  }
  copyWithoutAttributes() {
    return this.copyWithAttributes(null);
  }
  copyUsingObjectMap(t5) {
    const e4 = t5.find(this.text);
    return e4 ? this.copyWithText(e4) : this.copyWithText(this.text.copyUsingObjectMap(t5));
  }
  addAttribute(t5) {
    const e4 = this.attributes.concat(rn(t5));
    return this.copyWithAttributes(e4);
  }
  addHTMLAttribute(t5, e4) {
    const i4 = Object.assign({}, this.htmlAttributes, { [t5]: e4 });
    return new Xi(this.text, this.attributes, i4);
  }
  removeAttribute(t5) {
    const { listAttribute: e4 } = mt(t5), i4 = sn(sn(this.attributes, t5), e4);
    return this.copyWithAttributes(i4);
  }
  removeLastAttribute() {
    return this.removeAttribute(this.getLastAttribute());
  }
  getLastAttribute() {
    return on(this.attributes);
  }
  getAttributes() {
    return this.attributes.slice(0);
  }
  getAttributeLevel() {
    return this.attributes.length;
  }
  getAttributeAtLevel(t5) {
    return this.attributes[t5 - 1];
  }
  hasAttribute(t5) {
    return this.attributes.includes(t5);
  }
  hasAttributes() {
    return this.getAttributeLevel() > 0;
  }
  getLastNestableAttribute() {
    return on(this.getNestableAttributes());
  }
  getNestableAttributes() {
    return this.attributes.filter((t5) => mt(t5).nestable);
  }
  getNestingLevel() {
    return this.getNestableAttributes().length;
  }
  decreaseNestingLevel() {
    const t5 = this.getLastNestableAttribute();
    return t5 ? this.removeAttribute(t5) : this;
  }
  increaseNestingLevel() {
    const t5 = this.getLastNestableAttribute();
    if (t5) {
      const e4 = this.attributes.lastIndexOf(t5), i4 = st(this.attributes, e4 + 1, 0, ...rn(t5));
      return this.copyWithAttributes(i4);
    }
    return this;
  }
  getListItemAttributes() {
    return this.attributes.filter((t5) => mt(t5).listAttribute);
  }
  isListItem() {
    var t5;
    return (t5 = mt(this.getLastAttribute())) === null || t5 === undefined ? undefined : t5.listAttribute;
  }
  isTerminalBlock() {
    var t5;
    return (t5 = mt(this.getLastAttribute())) === null || t5 === undefined ? undefined : t5.terminal;
  }
  breaksOnReturn() {
    var t5;
    return (t5 = mt(this.getLastAttribute())) === null || t5 === undefined ? undefined : t5.breakOnReturn;
  }
  findLineBreakInDirectionFromPosition(t5, e4) {
    const i4 = this.toString();
    let n3;
    switch (t5) {
      case "forward":
        n3 = i4.indexOf(`
`, e4);
        break;
      case "backward":
        n3 = i4.slice(0, e4).lastIndexOf(`
`);
    }
    if (n3 !== -1)
      return n3;
  }
  contentsForInspection() {
    return { text: this.text.inspect(), attributes: this.attributes };
  }
  toString() {
    return this.text.toString();
  }
  toJSON() {
    return { text: this.text, attributes: this.attributes, htmlAttributes: this.htmlAttributes };
  }
  getDirection() {
    return this.text.getDirection();
  }
  isRTL() {
    return this.text.isRTL();
  }
  getLength() {
    return this.text.getLength();
  }
  canBeConsolidatedWith(t5) {
    return !this.hasAttributes() && !t5.hasAttributes() && this.getDirection() === t5.getDirection();
  }
  consolidateWith(t5) {
    const e4 = Yi.textForStringWithAttributes(`
`), i4 = this.getTextWithoutBlockBreak().appendText(e4);
    return this.copyWithText(i4.appendText(t5.text));
  }
  splitAtOffset(t5) {
    let e4, i4;
    return t5 === 0 ? (e4 = null, i4 = this) : t5 === this.getLength() ? (e4 = this, i4 = null) : (e4 = this.copyWithText(this.text.getTextAtRange([0, t5])), i4 = this.copyWithText(this.text.getTextAtRange([t5, this.getLength()]))), [e4, i4];
  }
  getBlockBreakPosition() {
    return this.text.getLength() - 1;
  }
  getTextWithoutBlockBreak() {
    return en2(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
  }
  canBeGrouped(t5) {
    return this.attributes[t5];
  }
  canBeGroupedWith(t5, e4) {
    const i4 = t5.getAttributes(), r4 = i4[e4], o3 = this.attributes[e4];
    return o3 === r4 && !(mt(o3).group === false && !(() => {
      if (!dt) {
        dt = [];
        for (const t6 in n2) {
          const { listAttribute: e5 } = n2[t6];
          e5 != null && dt.push(e5);
        }
      }
      return dt;
    })().includes(i4[e4 + 1])) && (this.getDirection() === t5.getDirection() || t5.isEmpty());
  }
}
var $i = function(t5) {
  return t5 = Zi(t5), t5 = tn2(t5);
};
var Zi = function(t5) {
  let e4 = false;
  const i4 = t5.getPieces();
  let n3 = i4.slice(0, i4.length - 1);
  const r4 = i4[i4.length - 1];
  return r4 ? (n3 = n3.map((t6) => t6.isBlockBreak() ? (e4 = true, nn2(t6)) : t6), e4 ? new Yi([...n3, r4]) : t5) : t5;
};
var Qi = Yi.textForStringWithAttributes(`
`, { blockBreak: true });
var tn2 = function(t5) {
  return en2(t5) ? t5 : t5.appendText(Qi);
};
var en2 = function(t5) {
  const e4 = t5.getLength();
  if (e4 === 0)
    return false;
  return t5.getTextAtRange([e4 - 1, e4]).isBlockBreak();
};
var nn2 = (t5) => t5.copyWithoutAttribute("blockBreak");
var rn = function(t5) {
  const { listAttribute: e4 } = mt(t5);
  return e4 ? [e4, t5] : [t5];
};
var on = (t5) => t5.slice(-1)[0];
var sn = function(t5, e4) {
  const i4 = t5.lastIndexOf(e4);
  return i4 === -1 ? t5 : st(t5, i4, 1);
};

class an extends rt {
  static fromJSON(t5) {
    return new this(Array.from(t5).map((t6) => Xi.fromJSON(t6)));
  }
  static fromString(t5, e4) {
    const i4 = Yi.textForStringWithAttributes(t5, e4);
    return new this([new Xi(i4)]);
  }
  constructor() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(...arguments), t5.length === 0 && (t5 = [new Xi]), this.blockList = Hi.box(t5);
  }
  isEmpty() {
    const t5 = this.getBlockAtIndex(0);
    return this.blockList.length === 1 && t5.isEmpty() && !t5.hasAttributes();
  }
  copy() {
    const t5 = (arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}).consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray();
    return new this.constructor(t5);
  }
  copyUsingObjectsFromDocument(t5) {
    const e4 = new Zt(t5.getObjects());
    return this.copyUsingObjectMap(e4);
  }
  copyUsingObjectMap(t5) {
    const e4 = this.getBlocks().map((e5) => t5.find(e5) || e5.copyUsingObjectMap(t5));
    return new this.constructor(e4);
  }
  copyWithBaseBlockAttributes() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const e4 = this.getBlocks().map((e5) => {
      const i4 = t5.concat(e5.getAttributes());
      return e5.copyWithAttributes(i4);
    });
    return new this.constructor(e4);
  }
  replaceBlock(t5, e4) {
    const i4 = this.blockList.indexOf(t5);
    return i4 === -1 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e4, i4));
  }
  insertDocumentAtRange(t5, e4) {
    const { blockList: i4 } = t5;
    e4 = wt(e4);
    let [n3] = e4;
    const { index: r4, offset: o3 } = this.locationFromPosition(n3);
    let s4 = this;
    const a4 = this.getBlockAtPosition(n3);
    return Lt(e4) && a4.isEmpty() && !a4.hasAttributes() ? s4 = new this.constructor(s4.blockList.removeObjectAtIndex(r4)) : a4.getBlockBreakPosition() === o3 && n3++, s4 = s4.removeTextAtRange(e4), new this.constructor(s4.blockList.insertSplittableListAtPosition(i4, n3));
  }
  mergeDocumentAtRange(t5, e4) {
    let i4, n3;
    e4 = wt(e4);
    const [r4] = e4, o3 = this.locationFromPosition(r4), s4 = this.getBlockAtIndex(o3.index).getAttributes(), a4 = t5.getBaseBlockAttributes(), l80 = s4.slice(-a4.length);
    if (ot(a4, l80)) {
      const e5 = s4.slice(0, -a4.length);
      i4 = t5.copyWithBaseBlockAttributes(e5);
    } else
      i4 = t5.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(s4);
    const c4 = i4.getBlockCount(), u4 = i4.getBlockAtIndex(0);
    if (ot(s4, u4.getAttributes())) {
      const t6 = u4.getTextWithoutBlockBreak();
      if (n3 = this.insertTextAtRange(t6, e4), c4 > 1) {
        i4 = new this.constructor(i4.getBlocks().slice(1));
        const e5 = r4 + t6.getLength();
        n3 = n3.insertDocumentAtRange(i4, e5);
      }
    } else
      n3 = this.insertDocumentAtRange(i4, e4);
    return n3;
  }
  insertTextAtRange(t5, e4) {
    e4 = wt(e4);
    const [i4] = e4, { index: n3, offset: r4 } = this.locationFromPosition(i4), o3 = this.removeTextAtRange(e4);
    return new this.constructor(o3.blockList.editObjectAtIndex(n3, (e5) => e5.copyWithText(e5.text.insertTextAtPosition(t5, r4))));
  }
  removeTextAtRange(t5) {
    let e4;
    t5 = wt(t5);
    const [i4, n3] = t5;
    if (Lt(t5))
      return this;
    const [r4, o3] = Array.from(this.locationRangeFromRange(t5)), s4 = r4.index, a4 = r4.offset, l80 = this.getBlockAtIndex(s4), c4 = o3.index, u4 = o3.offset, h4 = this.getBlockAtIndex(c4);
    if (n3 - i4 == 1 && l80.getBlockBreakPosition() === a4 && h4.getBlockBreakPosition() !== u4 && h4.text.getStringAtPosition(u4) === `
`)
      e4 = this.blockList.editObjectAtIndex(c4, (t6) => t6.copyWithText(t6.text.removeTextAtRange([u4, u4 + 1])));
    else {
      let t6;
      const i5 = l80.text.getTextAtRange([0, a4]), n4 = h4.text.getTextAtRange([u4, h4.getLength()]), r5 = i5.appendText(n4);
      t6 = s4 !== c4 && a4 === 0 && l80.getAttributeLevel() >= h4.getAttributeLevel() ? h4.copyWithText(r5) : l80.copyWithText(r5);
      const o4 = c4 + 1 - s4;
      e4 = this.blockList.splice(s4, o4, t6);
    }
    return new this.constructor(e4);
  }
  moveTextFromRangeToPosition(t5, e4) {
    let i4;
    t5 = wt(t5);
    const [n3, r4] = t5;
    if (n3 <= e4 && e4 <= r4)
      return this;
    let o3 = this.getDocumentAtRange(t5), s4 = this.removeTextAtRange(t5);
    const a4 = n3 < e4;
    a4 && (e4 -= o3.getLength());
    const [l80, ...c4] = o3.getBlocks();
    return c4.length === 0 ? (i4 = l80.getTextWithoutBlockBreak(), a4 && (e4 += 1)) : i4 = l80.text, s4 = s4.insertTextAtRange(i4, e4), c4.length === 0 ? s4 : (o3 = new this.constructor(c4), e4 += i4.getLength(), s4.insertDocumentAtRange(o3, e4));
  }
  addAttributeAtRange(t5, e4, i4) {
    let { blockList: n3 } = this;
    return this.eachBlockAtRange(i4, (i5, r4, o3) => n3 = n3.editObjectAtIndex(o3, function() {
      return mt(t5) ? i5.addAttribute(t5, e4) : r4[0] === r4[1] ? i5 : i5.copyWithText(i5.text.addAttributeAtRange(t5, e4, r4));
    })), new this.constructor(n3);
  }
  addAttribute(t5, e4) {
    let { blockList: i4 } = this;
    return this.eachBlock((n3, r4) => i4 = i4.editObjectAtIndex(r4, () => n3.addAttribute(t5, e4))), new this.constructor(i4);
  }
  removeAttributeAtRange(t5, e4) {
    let { blockList: i4 } = this;
    return this.eachBlockAtRange(e4, function(e5, n3, r4) {
      mt(t5) ? i4 = i4.editObjectAtIndex(r4, () => e5.removeAttribute(t5)) : n3[0] !== n3[1] && (i4 = i4.editObjectAtIndex(r4, () => e5.copyWithText(e5.text.removeAttributeAtRange(t5, n3))));
    }), new this.constructor(i4);
  }
  updateAttributesForAttachment(t5, e4) {
    const i4 = this.getRangeOfAttachment(e4), [n3] = Array.from(i4), { index: r4 } = this.locationFromPosition(n3), o3 = this.getTextAtIndex(r4);
    return new this.constructor(this.blockList.editObjectAtIndex(r4, (i5) => i5.copyWithText(o3.updateAttributesForAttachment(t5, e4))));
  }
  removeAttributeForAttachment(t5, e4) {
    const i4 = this.getRangeOfAttachment(e4);
    return this.removeAttributeAtRange(t5, i4);
  }
  setHTMLAttributeAtPosition(t5, e4, i4) {
    const n3 = this.getBlockAtPosition(t5), r4 = n3.addHTMLAttribute(e4, i4);
    return this.replaceBlock(n3, r4);
  }
  insertBlockBreakAtRange(t5) {
    let e4;
    t5 = wt(t5);
    const [i4] = t5, { offset: n3 } = this.locationFromPosition(i4), r4 = this.removeTextAtRange(t5);
    return n3 === 0 && (e4 = [new Xi]), new this.constructor(r4.blockList.insertSplittableListAtPosition(new Hi(e4), i4));
  }
  applyBlockAttributeAtRange(t5, e4, i4) {
    const n3 = this.expandRangeToLineBreaksAndSplitBlocks(i4);
    let r4 = n3.document;
    i4 = n3.range;
    const o3 = mt(t5);
    if (o3.listAttribute) {
      r4 = r4.removeLastListAttributeAtRange(i4, { exceptAttributeName: t5 });
      const e5 = r4.convertLineBreaksToBlockBreaksInRange(i4);
      r4 = e5.document, i4 = e5.range;
    } else
      r4 = o3.exclusive ? r4.removeBlockAttributesAtRange(i4) : o3.terminal ? r4.removeLastTerminalAttributeAtRange(i4) : r4.consolidateBlocksAtRange(i4);
    return r4.addAttributeAtRange(t5, e4, i4);
  }
  removeLastListAttributeAtRange(t5) {
    let e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, { blockList: i4 } = this;
    return this.eachBlockAtRange(t5, function(t6, n3, r4) {
      const o3 = t6.getLastAttribute();
      o3 && mt(o3).listAttribute && o3 !== e4.exceptAttributeName && (i4 = i4.editObjectAtIndex(r4, () => t6.removeAttribute(o3)));
    }), new this.constructor(i4);
  }
  removeLastTerminalAttributeAtRange(t5) {
    let { blockList: e4 } = this;
    return this.eachBlockAtRange(t5, function(t6, i4, n3) {
      const r4 = t6.getLastAttribute();
      r4 && mt(r4).terminal && (e4 = e4.editObjectAtIndex(n3, () => t6.removeAttribute(r4)));
    }), new this.constructor(e4);
  }
  removeBlockAttributesAtRange(t5) {
    let { blockList: e4 } = this;
    return this.eachBlockAtRange(t5, function(t6, i4, n3) {
      t6.hasAttributes() && (e4 = e4.editObjectAtIndex(n3, () => t6.copyWithoutAttributes()));
    }), new this.constructor(e4);
  }
  expandRangeToLineBreaksAndSplitBlocks(t5) {
    let e4;
    t5 = wt(t5);
    let [i4, n3] = t5;
    const r4 = this.locationFromPosition(i4), o3 = this.locationFromPosition(n3);
    let s4 = this;
    const a4 = s4.getBlockAtIndex(r4.index);
    if (r4.offset = a4.findLineBreakInDirectionFromPosition("backward", r4.offset), r4.offset != null && (e4 = s4.positionFromLocation(r4), s4 = s4.insertBlockBreakAtRange([e4, e4 + 1]), o3.index += 1, o3.offset -= s4.getBlockAtIndex(r4.index).getLength(), r4.index += 1), r4.offset = 0, o3.offset === 0 && o3.index > r4.index)
      o3.index -= 1, o3.offset = s4.getBlockAtIndex(o3.index).getBlockBreakPosition();
    else {
      const t6 = s4.getBlockAtIndex(o3.index);
      t6.text.getStringAtRange([o3.offset - 1, o3.offset]) === `
` ? o3.offset -= 1 : o3.offset = t6.findLineBreakInDirectionFromPosition("forward", o3.offset), o3.offset !== t6.getBlockBreakPosition() && (e4 = s4.positionFromLocation(o3), s4 = s4.insertBlockBreakAtRange([e4, e4 + 1]));
    }
    return i4 = s4.positionFromLocation(r4), n3 = s4.positionFromLocation(o3), { document: s4, range: t5 = wt([i4, n3]) };
  }
  convertLineBreaksToBlockBreaksInRange(t5) {
    t5 = wt(t5);
    let [e4] = t5;
    const i4 = this.getStringAtRange(t5).slice(0, -1);
    let n3 = this;
    return i4.replace(/.*?\n/g, function(t6) {
      e4 += t6.length, n3 = n3.insertBlockBreakAtRange([e4 - 1, e4]);
    }), { document: n3, range: t5 };
  }
  consolidateBlocksAtRange(t5) {
    t5 = wt(t5);
    const [e4, i4] = t5, n3 = this.locationFromPosition(e4).index, r4 = this.locationFromPosition(i4).index;
    return new this.constructor(this.blockList.consolidateFromIndexToIndex(n3, r4));
  }
  getDocumentAtRange(t5) {
    t5 = wt(t5);
    const e4 = this.blockList.getSplittableListInRange(t5).toArray();
    return new this.constructor(e4);
  }
  getStringAtRange(t5) {
    let e4;
    const i4 = t5 = wt(t5);
    return i4[i4.length - 1] !== this.getLength() && (e4 = -1), this.getDocumentAtRange(t5).toString().slice(0, e4);
  }
  getBlockAtIndex(t5) {
    return this.blockList.getObjectAtIndex(t5);
  }
  getBlockAtPosition(t5) {
    const { index: e4 } = this.locationFromPosition(t5);
    return this.getBlockAtIndex(e4);
  }
  getTextAtIndex(t5) {
    var e4;
    return (e4 = this.getBlockAtIndex(t5)) === null || e4 === undefined ? undefined : e4.text;
  }
  getTextAtPosition(t5) {
    const { index: e4 } = this.locationFromPosition(t5);
    return this.getTextAtIndex(e4);
  }
  getPieceAtPosition(t5) {
    const { index: e4, offset: i4 } = this.locationFromPosition(t5);
    return this.getTextAtIndex(e4).getPieceAtPosition(i4);
  }
  getCharacterAtPosition(t5) {
    const { index: e4, offset: i4 } = this.locationFromPosition(t5);
    return this.getTextAtIndex(e4).getStringAtRange([i4, i4 + 1]);
  }
  getLength() {
    return this.blockList.getEndPosition();
  }
  getBlocks() {
    return this.blockList.toArray();
  }
  getBlockCount() {
    return this.blockList.length;
  }
  getEditCount() {
    return this.editCount;
  }
  eachBlock(t5) {
    return this.blockList.eachObject(t5);
  }
  eachBlockAtRange(t5, e4) {
    let i4, n3;
    t5 = wt(t5);
    const [r4, o3] = t5, s4 = this.locationFromPosition(r4), a4 = this.locationFromPosition(o3);
    if (s4.index === a4.index)
      return i4 = this.getBlockAtIndex(s4.index), n3 = [s4.offset, a4.offset], e4(i4, n3, s4.index);
    for (let t6 = s4.index;t6 <= a4.index; t6++)
      if (i4 = this.getBlockAtIndex(t6), i4) {
        switch (t6) {
          case s4.index:
            n3 = [s4.offset, i4.text.getLength()];
            break;
          case a4.index:
            n3 = [0, a4.offset];
            break;
          default:
            n3 = [0, i4.text.getLength()];
        }
        e4(i4, n3, t6);
      }
  }
  getCommonAttributesAtRange(t5) {
    t5 = wt(t5);
    const [e4] = t5;
    if (Lt(t5))
      return this.getCommonAttributesAtPosition(e4);
    {
      const e5 = [], i4 = [];
      return this.eachBlockAtRange(t5, function(t6, n3) {
        if (n3[0] !== n3[1])
          return e5.push(t6.text.getCommonAttributesAtRange(n3)), i4.push(ln(t6));
      }), Ht.fromCommonAttributesOfObjects(e5).merge(Ht.fromCommonAttributesOfObjects(i4)).toObject();
    }
  }
  getCommonAttributesAtPosition(t5) {
    let e4, i4;
    const { index: n3, offset: r4 } = this.locationFromPosition(t5), o3 = this.getBlockAtIndex(n3);
    if (!o3)
      return {};
    const s4 = ln(o3), a4 = o3.text.getAttributesAtPosition(r4), l80 = o3.text.getAttributesAtPosition(r4 - 1), c4 = Object.keys(W2).filter((t6) => W2[t6].inheritable);
    for (e4 in l80)
      i4 = l80[e4], (i4 === a4[e4] || c4.includes(e4)) && (s4[e4] = i4);
    return s4;
  }
  getRangeOfCommonAttributeAtPosition(t5, e4) {
    const { index: i4, offset: n3 } = this.locationFromPosition(e4), r4 = this.getTextAtIndex(i4), [o3, s4] = Array.from(r4.getExpandedRangeForAttributeAtOffset(t5, n3)), a4 = this.positionFromLocation({ index: i4, offset: o3 }), l80 = this.positionFromLocation({ index: i4, offset: s4 });
    return wt([a4, l80]);
  }
  getBaseBlockAttributes() {
    let t5 = this.getBlockAtIndex(0).getAttributes();
    for (let e4 = 1;e4 < this.getBlockCount(); e4++) {
      const i4 = this.getBlockAtIndex(e4).getAttributes(), n3 = Math.min(t5.length, i4.length);
      t5 = (() => {
        const e5 = [];
        for (let r4 = 0;r4 < n3 && i4[r4] === t5[r4]; r4++)
          e5.push(i4[r4]);
        return e5;
      })();
    }
    return t5;
  }
  getAttachmentById(t5) {
    for (const e4 of this.getAttachments())
      if (e4.id === t5)
        return e4;
  }
  getAttachmentPieces() {
    let t5 = [];
    return this.blockList.eachObject((e4) => {
      let { text: i4 } = e4;
      return t5 = t5.concat(i4.getAttachmentPieces());
    }), t5;
  }
  getAttachments() {
    return this.getAttachmentPieces().map((t5) => t5.attachment);
  }
  getRangeOfAttachment(t5) {
    let e4 = 0;
    const i4 = this.blockList.toArray();
    for (let n3 = 0;n3 < i4.length; n3++) {
      const { text: r4 } = i4[n3], o3 = r4.getRangeOfAttachment(t5);
      if (o3)
        return wt([e4 + o3[0], e4 + o3[1]]);
      e4 += r4.getLength();
    }
  }
  getLocationRangeOfAttachment(t5) {
    const e4 = this.getRangeOfAttachment(t5);
    return this.locationRangeFromRange(e4);
  }
  getAttachmentPieceForAttachment(t5) {
    for (const e4 of this.getAttachmentPieces())
      if (e4.attachment === t5)
        return e4;
  }
  findRangesForBlockAttribute(t5) {
    let e4 = 0;
    const i4 = [];
    return this.getBlocks().forEach((n3) => {
      const r4 = n3.getLength();
      n3.hasAttribute(t5) && i4.push([e4, e4 + r4]), e4 += r4;
    }), i4;
  }
  findRangesForTextAttribute(t5) {
    let { withValue: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, i4 = 0, n3 = [];
    const r4 = [];
    return this.getPieces().forEach((o3) => {
      const s4 = o3.getLength();
      (function(i5) {
        return e4 ? i5.getAttribute(t5) === e4 : i5.hasAttribute(t5);
      })(o3) && (n3[1] === i4 ? n3[1] = i4 + s4 : r4.push(n3 = [i4, i4 + s4])), i4 += s4;
    }), r4;
  }
  locationFromPosition(t5) {
    const e4 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t5));
    if (e4.index != null)
      return e4;
    {
      const t6 = this.getBlocks();
      return { index: t6.length - 1, offset: t6[t6.length - 1].getLength() };
    }
  }
  positionFromLocation(t5) {
    return this.blockList.findPositionAtIndexAndOffset(t5.index, t5.offset);
  }
  locationRangeFromPosition(t5) {
    return wt(this.locationFromPosition(t5));
  }
  locationRangeFromRange(t5) {
    if (!(t5 = wt(t5)))
      return;
    const [e4, i4] = Array.from(t5), n3 = this.locationFromPosition(e4), r4 = this.locationFromPosition(i4);
    return wt([n3, r4]);
  }
  rangeFromLocationRange(t5) {
    let e4;
    t5 = wt(t5);
    const i4 = this.positionFromLocation(t5[0]);
    return Lt(t5) || (e4 = this.positionFromLocation(t5[1])), wt([i4, e4]);
  }
  isEqualTo(t5) {
    return this.blockList.isEqualTo(t5 == null ? undefined : t5.blockList);
  }
  getTexts() {
    return this.getBlocks().map((t5) => t5.text);
  }
  getPieces() {
    const t5 = [];
    return Array.from(this.getTexts()).forEach((e4) => {
      t5.push(...Array.from(e4.getPieces() || []));
    }), t5;
  }
  getObjects() {
    return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
  }
  toSerializableDocument() {
    const t5 = [];
    return this.blockList.eachObject((e4) => t5.push(e4.copyWithText(e4.text.toSerializableText()))), new this.constructor(t5);
  }
  toString() {
    return this.blockList.toString();
  }
  toJSON() {
    return this.blockList.toJSON();
  }
  toConsole() {
    return JSON.stringify(this.blockList.toArray().map((t5) => JSON.parse(t5.text.toConsole())));
  }
}
var ln = function(t5) {
  const e4 = {}, i4 = t5.getLastAttribute();
  return i4 && (e4[i4] = true), e4;
};
var cn = function(t5) {
  let e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return { string: t5 = Wt(t5), attributes: e4, type: "string" };
};
var un = (t5, e4) => {
  try {
    return JSON.parse(t5.getAttribute("data-trix-".concat(e4)));
  } catch (t6) {
    return {};
  }
};

class hn extends q3 {
  static parse(t5, e4) {
    const i4 = new this(t5, e4);
    return i4.parse(), i4;
  }
  constructor(t5) {
    let { referenceElement: e4, purifyOptions: i4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(...arguments), this.html = t5, this.referenceElement = e4, this.purifyOptions = i4, this.blocks = [], this.blockElements = [], this.processedElements = [];
  }
  getDocument() {
    return an.fromJSON(this.blocks);
  }
  parse() {
    try {
      this.createHiddenContainer(), di.setHTML(this.containerElement, this.html, { purifyOptions: this.purifyOptions });
      const t5 = R(this.containerElement, { usingFilter: pn });
      for (;t5.nextNode(); )
        this.processNode(t5.currentNode);
      return this.translateBlockElementMarginsToNewlines();
    } finally {
      this.removeHiddenContainer();
    }
  }
  createHiddenContainer() {
    return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = T4({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
  }
  removeHiddenContainer() {
    return S2(this.containerElement);
  }
  processNode(t5) {
    switch (t5.nodeType) {
      case Node.TEXT_NODE:
        if (!this.isInsignificantTextNode(t5))
          return this.appendBlockForTextNode(t5), this.processTextNode(t5);
        break;
      case Node.ELEMENT_NODE:
        return this.appendBlockForElement(t5), this.processElement(t5);
    }
  }
  appendBlockForTextNode(t5) {
    const e4 = t5.parentNode;
    if (e4 === this.currentBlockElement && this.isBlockElement(t5.previousSibling))
      return this.appendStringWithAttributes(`
`);
    if (e4 === this.containerElement || this.isBlockElement(e4)) {
      var i4;
      const t6 = this.getBlockAttributes(e4), n3 = this.getBlockHTMLAttributes(e4);
      ot(t6, (i4 = this.currentBlock) === null || i4 === undefined ? undefined : i4.attributes) || (this.currentBlock = this.appendBlockForAttributesWithElement(t6, e4, n3), this.currentBlockElement = e4);
    }
  }
  appendBlockForElement(t5) {
    const e4 = this.isBlockElement(t5), i4 = C3(this.currentBlockElement, t5);
    if (e4 && !this.isBlockElement(t5.firstChild)) {
      if (!this.isInsignificantTextNode(t5.firstChild) || !this.isBlockElement(t5.firstElementChild)) {
        const e5 = this.getBlockAttributes(t5), n3 = this.getBlockHTMLAttributes(t5);
        if (t5.firstChild) {
          if (i4 && ot(e5, this.currentBlock.attributes))
            return this.appendStringWithAttributes(`
`);
          this.currentBlock = this.appendBlockForAttributesWithElement(e5, t5, n3), this.currentBlockElement = t5;
        }
      }
    } else if (this.currentBlockElement && !i4 && !e4) {
      const e5 = this.findParentBlockElement(t5);
      if (e5)
        return this.appendBlockForElement(e5);
      this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null;
    }
  }
  findParentBlockElement(t5) {
    let { parentElement: e4 } = t5;
    for (;e4 && e4 !== this.containerElement; ) {
      if (this.isBlockElement(e4) && this.blockElements.includes(e4))
        return e4;
      e4 = e4.parentElement;
    }
    return null;
  }
  processTextNode(t5) {
    let e4 = t5.data;
    var i4;
    dn(t5.parentNode) || (e4 = Vt(e4), vn((i4 = t5.previousSibling) === null || i4 === undefined ? undefined : i4.textContent) && (e4 = fn(e4)));
    return this.appendStringWithAttributes(e4, this.getTextAttributes(t5.parentNode));
  }
  processElement(t5) {
    let e4;
    if (P3(t5)) {
      if (e4 = un(t5, "attachment"), Object.keys(e4).length) {
        const i4 = this.getTextAttributes(t5);
        this.appendAttachmentWithAttributes(e4, i4), t5.innerHTML = "";
      }
      return this.processedElements.push(t5);
    }
    switch (k3(t5)) {
      case "br":
        return this.isExtraBR(t5) || this.isBlockElement(t5.nextSibling) || this.appendStringWithAttributes(`
`, this.getTextAttributes(t5)), this.processedElements.push(t5);
      case "img":
        e4 = { url: t5.getAttribute("src"), contentType: "image" };
        const i4 = ((t6) => {
          const e5 = t6.getAttribute("width"), i5 = t6.getAttribute("height"), n3 = {};
          return e5 && (n3.width = parseInt(e5, 10)), i5 && (n3.height = parseInt(i5, 10)), n3;
        })(t5);
        for (const t6 in i4) {
          const n3 = i4[t6];
          e4[t6] = n3;
        }
        return this.appendAttachmentWithAttributes(e4, this.getTextAttributes(t5)), this.processedElements.push(t5);
      case "tr":
        if (this.needsTableSeparator(t5))
          return this.appendStringWithAttributes(j4.tableRowSeparator);
        break;
      case "td":
        if (this.needsTableSeparator(t5))
          return this.appendStringWithAttributes(j4.tableCellSeparator);
    }
  }
  appendBlockForAttributesWithElement(t5, e4) {
    let i4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.blockElements.push(e4);
    const n3 = function() {
      return { text: [], attributes: arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, htmlAttributes: arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {} };
    }(t5, i4);
    return this.blocks.push(n3), n3;
  }
  appendEmptyBlock() {
    return this.appendBlockForAttributesWithElement([], null);
  }
  appendStringWithAttributes(t5, e4) {
    return this.appendPiece(cn(t5, e4));
  }
  appendAttachmentWithAttributes(t5, e4) {
    return this.appendPiece(function(t6) {
      return { attachment: t6, attributes: arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, type: "attachment" };
    }(t5, e4));
  }
  appendPiece(t5) {
    return this.blocks.length === 0 && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t5);
  }
  appendStringToTextAtIndex(t5, e4) {
    const { text: i4 } = this.blocks[e4], n3 = i4[i4.length - 1];
    if ((n3 == null ? undefined : n3.type) !== "string")
      return i4.push(cn(t5));
    n3.string += t5;
  }
  prependStringToTextAtIndex(t5, e4) {
    const { text: i4 } = this.blocks[e4], n3 = i4[0];
    if ((n3 == null ? undefined : n3.type) !== "string")
      return i4.unshift(cn(t5));
    n3.string = t5 + n3.string;
  }
  getTextAttributes(t5) {
    let e4;
    const i4 = {};
    for (const n3 in W2) {
      const r4 = W2[n3];
      if (r4.tagName && y3(t5, { matchingSelector: r4.tagName, untilNode: this.containerElement }))
        i4[n3] = true;
      else if (r4.parser) {
        if (e4 = r4.parser(t5), e4) {
          let o3 = false;
          for (const i5 of this.findBlockElementAncestors(t5))
            if (r4.parser(i5) === e4) {
              o3 = true;
              break;
            }
          o3 || (i4[n3] = e4);
        }
      } else
        r4.styleProperty && (e4 = t5.style[r4.styleProperty], e4 && (i4[n3] = e4));
    }
    if (P3(t5)) {
      const n3 = un(t5, "attributes");
      for (const t6 in n3)
        e4 = n3[t6], i4[t6] = e4;
    }
    return i4;
  }
  getBlockAttributes(t5) {
    const e4 = [];
    for (;t5 && t5 !== this.containerElement; ) {
      for (const r4 in n2) {
        const o3 = n2[r4];
        var i4;
        if (o3.parse !== false) {
          if (k3(t5) === o3.tagName)
            ((i4 = o3.test) !== null && i4 !== undefined && i4.call(o3, t5) || !o3.test) && (e4.push(r4), o3.listAttribute && e4.push(o3.listAttribute));
        }
      }
      t5 = t5.parentNode;
    }
    return e4.reverse();
  }
  getBlockHTMLAttributes(t5) {
    const e4 = {}, i4 = Object.values(n2).find((e5) => e5.tagName === k3(t5));
    return ((i4 == null ? undefined : i4.htmlAttributes) || []).forEach((i5) => {
      t5.hasAttribute(i5) && (e4[i5] = t5.getAttribute(i5));
    }), e4;
  }
  findBlockElementAncestors(t5) {
    const e4 = [];
    for (;t5 && t5 !== this.containerElement; ) {
      const i4 = k3(t5);
      L3().includes(i4) && e4.push(t5), t5 = t5.parentNode;
    }
    return e4;
  }
  isBlockElement(t5) {
    if ((t5 == null ? undefined : t5.nodeType) === Node.ELEMENT_NODE && !P3(t5) && !y3(t5, { matchingSelector: "td", untilNode: this.containerElement }))
      return L3().includes(k3(t5)) || window.getComputedStyle(t5).display === "block";
  }
  isInsignificantTextNode(t5) {
    if ((t5 == null ? undefined : t5.nodeType) !== Node.TEXT_NODE)
      return;
    if (!bn(t5.data))
      return;
    const { parentNode: e4, previousSibling: i4, nextSibling: n3 } = t5;
    return gn(e4.previousSibling) && !this.isBlockElement(e4.previousSibling) || dn(e4) ? undefined : !i4 || this.isBlockElement(i4) || !n3 || this.isBlockElement(n3);
  }
  isExtraBR(t5) {
    return k3(t5) === "br" && this.isBlockElement(t5.parentNode) && t5.parentNode.lastChild === t5;
  }
  needsTableSeparator(t5) {
    if (j4.removeBlankTableCells) {
      var e4;
      const i4 = (e4 = t5.previousSibling) === null || e4 === undefined ? undefined : e4.textContent;
      return i4 && /\S/.test(i4);
    }
    return t5.previousSibling;
  }
  translateBlockElementMarginsToNewlines() {
    const t5 = this.getMarginOfDefaultBlockElement();
    for (let e4 = 0;e4 < this.blocks.length; e4++) {
      const i4 = this.getMarginOfBlockElementAtIndex(e4);
      i4 && (i4.top > 2 * t5.top && this.prependStringToTextAtIndex(`
`, e4), i4.bottom > 2 * t5.bottom && this.appendStringToTextAtIndex(`
`, e4));
    }
  }
  getMarginOfBlockElementAtIndex(t5) {
    const e4 = this.blockElements[t5];
    if (e4 && e4.textContent && !L3().includes(k3(e4)) && !this.processedElements.includes(e4))
      return mn(e4);
  }
  getMarginOfDefaultBlockElement() {
    const t5 = T4(n2.default.tagName);
    return this.containerElement.appendChild(t5), mn(t5);
  }
}
var dn = function(t5) {
  const { whiteSpace: e4 } = window.getComputedStyle(t5);
  return ["pre", "pre-wrap", "pre-line"].includes(e4);
};
var gn = (t5) => t5 && !vn(t5.textContent);
var mn = function(t5) {
  const e4 = window.getComputedStyle(t5);
  if (e4.display === "block")
    return { top: parseInt(e4.marginTop), bottom: parseInt(e4.marginBottom) };
};
var pn = function(t5) {
  return k3(t5) === "style" ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
};
var fn = (t5) => t5.replace(new RegExp("^".concat(Ut.source, "+")), "");
var bn = (t5) => new RegExp("^".concat(Ut.source, "*$")).test(t5);
var vn = (t5) => /\s$/.test(t5);
var An = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"];
var yn = "data-trix-serialized-attributes";
var xn = "[".concat(yn, "]");
var Cn = new RegExp("<!--block-->", "g");
var En = { "application/json": function(t5) {
  let e4;
  if (t5 instanceof an)
    e4 = t5;
  else {
    if (!(t5 instanceof HTMLElement))
      throw new Error("unserializable object");
    e4 = hn.parse(t5.innerHTML).getDocument();
  }
  return e4.toSerializableDocument().toJSONString();
}, "text/html": function(t5) {
  let e4;
  if (t5 instanceof an)
    e4 = Si.render(t5);
  else {
    if (!(t5 instanceof HTMLElement))
      throw new Error("unserializable object");
    e4 = t5.cloneNode(true);
  }
  return Array.from(e4.querySelectorAll("[data-trix-serialize=false]")).forEach((t6) => {
    S2(t6);
  }), An.forEach((t6) => {
    Array.from(e4.querySelectorAll("[".concat(t6, "]"))).forEach((e5) => {
      e5.removeAttribute(t6);
    });
  }), Array.from(e4.querySelectorAll(xn)).forEach((t6) => {
    try {
      const e5 = JSON.parse(t6.getAttribute(yn));
      t6.removeAttribute(yn);
      for (const i4 in e5) {
        const n3 = e5[i4];
        t6.setAttribute(i4, n3);
      }
    } catch (t7) {}
  }), e4.innerHTML.replace(Cn, "");
} };
var Sn = Object.freeze({ __proto__: null });

class Rn extends q3 {
  constructor(t5, e4) {
    super(...arguments), this.attachmentManager = t5, this.attachment = e4, this.id = this.attachment.id, this.file = this.attachment.file;
  }
  remove() {
    return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
  }
}
Rn.proxyMethod("attachment.getAttribute"), Rn.proxyMethod("attachment.hasAttribute"), Rn.proxyMethod("attachment.setAttribute"), Rn.proxyMethod("attachment.getAttributes"), Rn.proxyMethod("attachment.setAttributes"), Rn.proxyMethod("attachment.isPending"), Rn.proxyMethod("attachment.isPreviewable"), Rn.proxyMethod("attachment.getURL"), Rn.proxyMethod("attachment.getHref"), Rn.proxyMethod("attachment.getFilename"), Rn.proxyMethod("attachment.getFilesize"), Rn.proxyMethod("attachment.getFormattedFilesize"), Rn.proxyMethod("attachment.getExtension"), Rn.proxyMethod("attachment.getContentType"), Rn.proxyMethod("attachment.getFile"), Rn.proxyMethod("attachment.setFile"), Rn.proxyMethod("attachment.releaseFile"), Rn.proxyMethod("attachment.getUploadProgress"), Rn.proxyMethod("attachment.setUploadProgress");

class kn extends q3 {
  constructor() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(...arguments), this.managedAttachments = {}, Array.from(t5).forEach((t6) => {
      this.manageAttachment(t6);
    });
  }
  getAttachments() {
    const t5 = [];
    for (const e4 in this.managedAttachments) {
      const i4 = this.managedAttachments[e4];
      t5.push(i4);
    }
    return t5;
  }
  manageAttachment(t5) {
    return this.managedAttachments[t5.id] || (this.managedAttachments[t5.id] = new Rn(this, t5)), this.managedAttachments[t5.id];
  }
  attachmentIsManaged(t5) {
    return t5.id in this.managedAttachments;
  }
  requestRemovalOfAttachment(t5) {
    var e4, i4;
    if (this.attachmentIsManaged(t5))
      return (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.attachmentManagerDidRequestRemovalOfAttachment) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  unmanageAttachment(t5) {
    const e4 = this.managedAttachments[t5.id];
    return delete this.managedAttachments[t5.id], e4;
  }
}

class Tn {
  constructor(t5) {
    this.composition = t5, this.document = this.composition.document;
    const e4 = this.composition.getSelectedRange();
    this.startPosition = e4[0], this.endPosition = e4[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
  }
  shouldInsertBlockBreak() {
    return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? this.startLocation.offset !== 0 : this.breaksOnReturn && this.nextCharacter !== `
`;
  }
  shouldBreakFormattedBlock() {
    return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && this.nextCharacter === `
` || this.previousCharacter === `
`);
  }
  shouldDecreaseListLevel() {
    return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
  }
  shouldPrependListItem() {
    return this.block.isListItem() && this.startLocation.offset === 0 && !this.block.isEmpty();
  }
  shouldRemoveLastBlockAttribute() {
    return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
  }
}

class wn extends q3 {
  constructor() {
    super(...arguments), this.document = new an, this.attachments = [], this.currentAttributes = {}, this.revision = 0;
  }
  setDocument(t5) {
    var e4, i4;
    if (!t5.isEqualTo(this.document))
      return this.document = t5, this.refreshAttachments(), this.revision++, (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionDidChangeDocument) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  getSnapshot() {
    return { document: this.document, selectedRange: this.getSelectedRange() };
  }
  loadSnapshot(t5) {
    var e4, i4, n3, r4;
    let { document: o3, selectedRange: s4 } = t5;
    return (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionWillLoadSnapshot) === null || i4 === undefined || i4.call(e4), this.setDocument(o3 != null ? o3 : new an), this.setSelection(s4 != null ? s4 : [0, 0]), (n3 = this.delegate) === null || n3 === undefined || (r4 = n3.compositionDidLoadSnapshot) === null || r4 === undefined ? undefined : r4.call(n3);
  }
  insertText(t5) {
    let { updatePosition: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { updatePosition: true };
    const i4 = this.getSelectedRange();
    this.setDocument(this.document.insertTextAtRange(t5, i4));
    const n3 = i4[0], r4 = n3 + t5.getLength();
    return e4 && this.setSelection(r4), this.notifyDelegateOfInsertionAtRange([n3, r4]);
  }
  insertBlock() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Xi;
    const e4 = new an([t5]);
    return this.insertDocument(e4);
  }
  insertDocument() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new an;
    const e4 = this.getSelectedRange();
    this.setDocument(this.document.insertDocumentAtRange(t5, e4));
    const i4 = e4[0], n3 = i4 + t5.getLength();
    return this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([i4, n3]);
  }
  insertString(t5, e4) {
    const i4 = this.getCurrentTextAttributes(), n3 = Yi.textForStringWithAttributes(t5, i4);
    return this.insertText(n3, e4);
  }
  insertBlockBreak() {
    const t5 = this.getSelectedRange();
    this.setDocument(this.document.insertBlockBreakAtRange(t5));
    const e4 = t5[0], i4 = e4 + 1;
    return this.setSelection(i4), this.notifyDelegateOfInsertionAtRange([e4, i4]);
  }
  insertLineBreak() {
    const t5 = new Tn(this);
    if (t5.shouldDecreaseListLevel())
      return this.decreaseListLevel(), this.setSelection(t5.startPosition);
    if (t5.shouldPrependListItem()) {
      const e4 = new an([t5.block.copyWithoutText()]);
      return this.insertDocument(e4);
    }
    return t5.shouldInsertBlockBreak() ? this.insertBlockBreak() : t5.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : t5.shouldBreakFormattedBlock() ? this.breakFormattedBlock(t5) : this.insertString(`
`);
  }
  insertHTML(t5) {
    const e4 = hn.parse(t5, { purifyOptions: { SAFE_FOR_XML: true } }).getDocument(), i4 = this.getSelectedRange();
    this.setDocument(this.document.mergeDocumentAtRange(e4, i4));
    const n3 = i4[0], r4 = n3 + e4.getLength() - 1;
    return this.setSelection(r4), this.notifyDelegateOfInsertionAtRange([n3, r4]);
  }
  replaceHTML(t5) {
    const e4 = hn.parse(t5).getDocument().copyUsingObjectsFromDocument(this.document), i4 = this.getLocationRange({ strict: false }), n3 = this.document.rangeFromLocationRange(i4);
    return this.setDocument(e4), this.setSelection(n3);
  }
  insertFile(t5) {
    return this.insertFiles([t5]);
  }
  insertFiles(t5) {
    const e4 = [];
    return Array.from(t5).forEach((t6) => {
      var i4;
      if ((i4 = this.delegate) !== null && i4 !== undefined && i4.compositionShouldAcceptFile(t6)) {
        const i5 = Vi.attachmentForFile(t6);
        e4.push(i5);
      }
    }), this.insertAttachments(e4);
  }
  insertAttachment(t5) {
    return this.insertAttachments([t5]);
  }
  insertAttachments(t5) {
    let e4 = new Yi;
    return Array.from(t5).forEach((t6) => {
      var n3;
      const r4 = t6.getType(), o3 = (n3 = i3[r4]) === null || n3 === undefined ? undefined : n3.presentation, s4 = this.getCurrentTextAttributes();
      o3 && (s4.presentation = o3);
      const a4 = Yi.textForAttachmentWithAttributes(t6, s4);
      e4 = e4.appendText(a4);
    }), this.insertText(e4);
  }
  shouldManageDeletingInDirection(t5) {
    const e4 = this.getLocationRange();
    if (Lt(e4)) {
      if (t5 === "backward" && e4[0].offset === 0)
        return true;
      if (this.shouldManageMovingCursorInDirection(t5))
        return true;
    } else if (e4[0].index !== e4[1].index)
      return true;
    return false;
  }
  deleteInDirection(t5) {
    let e4, i4, n3, { length: r4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const o3 = this.getLocationRange();
    let s4 = this.getSelectedRange();
    const a4 = Lt(s4);
    if (a4 ? i4 = t5 === "backward" && o3[0].offset === 0 : n3 = o3[0].index !== o3[1].index, i4 && this.canDecreaseBlockAttributeLevel()) {
      const t6 = this.getBlock();
      if (t6.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(s4[0]), t6.isEmpty())
        return false;
    }
    return a4 && (s4 = this.getExpandedRangeInDirection(t5, { length: r4 }), t5 === "backward" && (e4 = this.getAttachmentAtRange(s4))), e4 ? (this.editAttachment(e4), false) : (this.setDocument(this.document.removeTextAtRange(s4)), this.setSelection(s4[0]), !i4 && !n3 && undefined);
  }
  moveTextFromRange(t5) {
    const [e4] = Array.from(this.getSelectedRange());
    return this.setDocument(this.document.moveTextFromRangeToPosition(t5, e4)), this.setSelection(e4);
  }
  removeAttachment(t5) {
    const e4 = this.document.getRangeOfAttachment(t5);
    if (e4)
      return this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e4)), this.setSelection(e4[0]);
  }
  removeLastBlockAttribute() {
    const [t5, e4] = Array.from(this.getSelectedRange()), i4 = this.document.getBlockAtPosition(e4);
    return this.removeCurrentAttribute(i4.getLastAttribute()), this.setSelection(t5);
  }
  insertPlaceholder() {
    return this.placeholderPosition = this.getPosition(), this.insertString(" ");
  }
  selectPlaceholder() {
    if (this.placeholderPosition != null)
      return this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + 1]), this.getSelectedRange();
  }
  forgetPlaceholder() {
    this.placeholderPosition = null;
  }
  hasCurrentAttribute(t5) {
    const e4 = this.currentAttributes[t5];
    return e4 != null && e4 !== false;
  }
  toggleCurrentAttribute(t5) {
    const e4 = !this.currentAttributes[t5];
    return e4 ? this.setCurrentAttribute(t5, e4) : this.removeCurrentAttribute(t5);
  }
  canSetCurrentAttribute(t5) {
    return mt(t5) ? this.canSetCurrentBlockAttribute(t5) : this.canSetCurrentTextAttribute(t5);
  }
  canSetCurrentTextAttribute(t5) {
    const e4 = this.getSelectedDocument();
    if (e4) {
      for (const t6 of Array.from(e4.getAttachments()))
        if (!t6.hasContent())
          return false;
      return true;
    }
  }
  canSetCurrentBlockAttribute(t5) {
    const e4 = this.getBlock();
    if (e4)
      return !e4.isTerminalBlock();
  }
  setCurrentAttribute(t5, e4) {
    return mt(t5) ? this.setBlockAttribute(t5, e4) : (this.setTextAttribute(t5, e4), this.currentAttributes[t5] = e4, this.notifyDelegateOfCurrentAttributesChange());
  }
  setHTMLAtributeAtPosition(t5, e4, i4) {
    var n3;
    const r4 = this.document.getBlockAtPosition(t5), o3 = (n3 = mt(r4.getLastAttribute())) === null || n3 === undefined ? undefined : n3.htmlAttributes;
    if (r4 && o3 != null && o3.includes(e4)) {
      const n4 = this.document.setHTMLAttributeAtPosition(t5, e4, i4);
      this.setDocument(n4);
    }
  }
  setTextAttribute(t5, e4) {
    const i4 = this.getSelectedRange();
    if (!i4)
      return;
    const [n3, r4] = Array.from(i4);
    if (n3 !== r4)
      return this.setDocument(this.document.addAttributeAtRange(t5, e4, i4));
    if (t5 === "href") {
      const t6 = Yi.textForStringWithAttributes(e4, { href: e4 });
      return this.insertText(t6);
    }
  }
  setBlockAttribute(t5, e4) {
    const i4 = this.getSelectedRange();
    if (this.canSetCurrentAttribute(t5))
      return this.setDocument(this.document.applyBlockAttributeAtRange(t5, e4, i4)), this.setSelection(i4);
  }
  removeCurrentAttribute(t5) {
    return mt(t5) ? (this.removeBlockAttribute(t5), this.updateCurrentAttributes()) : (this.removeTextAttribute(t5), delete this.currentAttributes[t5], this.notifyDelegateOfCurrentAttributesChange());
  }
  removeTextAttribute(t5) {
    const e4 = this.getSelectedRange();
    if (e4)
      return this.setDocument(this.document.removeAttributeAtRange(t5, e4));
  }
  removeBlockAttribute(t5) {
    const e4 = this.getSelectedRange();
    if (e4)
      return this.setDocument(this.document.removeAttributeAtRange(t5, e4));
  }
  canDecreaseNestingLevel() {
    var t5;
    return ((t5 = this.getBlock()) === null || t5 === undefined ? undefined : t5.getNestingLevel()) > 0;
  }
  canIncreaseNestingLevel() {
    var t5;
    const e4 = this.getBlock();
    if (e4) {
      if ((t5 = mt(e4.getLastNestableAttribute())) === null || t5 === undefined || !t5.listAttribute)
        return e4.getNestingLevel() > 0;
      {
        const t6 = this.getPreviousBlock();
        if (t6)
          return function() {
            let t7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            return ot((arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []).slice(0, t7.length), t7);
          }(t6.getListItemAttributes(), e4.getListItemAttributes());
      }
    }
  }
  decreaseNestingLevel() {
    const t5 = this.getBlock();
    if (t5)
      return this.setDocument(this.document.replaceBlock(t5, t5.decreaseNestingLevel()));
  }
  increaseNestingLevel() {
    const t5 = this.getBlock();
    if (t5)
      return this.setDocument(this.document.replaceBlock(t5, t5.increaseNestingLevel()));
  }
  canDecreaseBlockAttributeLevel() {
    var t5;
    return ((t5 = this.getBlock()) === null || t5 === undefined ? undefined : t5.getAttributeLevel()) > 0;
  }
  decreaseBlockAttributeLevel() {
    var t5;
    const e4 = (t5 = this.getBlock()) === null || t5 === undefined ? undefined : t5.getLastAttribute();
    if (e4)
      return this.removeCurrentAttribute(e4);
  }
  decreaseListLevel() {
    let [t5] = Array.from(this.getSelectedRange());
    const { index: e4 } = this.document.locationFromPosition(t5);
    let i4 = e4;
    const n3 = this.getBlock().getAttributeLevel();
    let r4 = this.document.getBlockAtIndex(i4 + 1);
    for (;r4 && r4.isListItem() && !(r4.getAttributeLevel() <= n3); )
      i4++, r4 = this.document.getBlockAtIndex(i4 + 1);
    t5 = this.document.positionFromLocation({ index: e4, offset: 0 });
    const o3 = this.document.positionFromLocation({ index: i4, offset: 0 });
    return this.setDocument(this.document.removeLastListAttributeAtRange([t5, o3]));
  }
  updateCurrentAttributes() {
    const t5 = this.getSelectedRange({ ignoreLock: true });
    if (t5) {
      const e4 = this.document.getCommonAttributesAtRange(t5);
      if (Array.from(gt()).forEach((t6) => {
        e4[t6] || this.canSetCurrentAttribute(t6) || (e4[t6] = false);
      }), !Tt(e4, this.currentAttributes))
        return this.currentAttributes = e4, this.notifyDelegateOfCurrentAttributesChange();
    }
  }
  getCurrentAttributes() {
    return m3.call({}, this.currentAttributes);
  }
  getCurrentTextAttributes() {
    const t5 = {};
    for (const e4 in this.currentAttributes) {
      const i4 = this.currentAttributes[e4];
      i4 !== false && ft(e4) && (t5[e4] = i4);
    }
    return t5;
  }
  freezeSelection() {
    return this.setCurrentAttribute("frozen", true);
  }
  thawSelection() {
    return this.removeCurrentAttribute("frozen");
  }
  hasFrozenSelection() {
    return this.hasCurrentAttribute("frozen");
  }
  setSelection(t5) {
    var e4;
    const i4 = this.document.locationRangeFromRange(t5);
    return (e4 = this.delegate) === null || e4 === undefined ? undefined : e4.compositionDidRequestChangingSelectionToLocationRange(i4);
  }
  getSelectedRange() {
    const t5 = this.getLocationRange();
    if (t5)
      return this.document.rangeFromLocationRange(t5);
  }
  setSelectedRange(t5) {
    const e4 = this.document.locationRangeFromRange(t5);
    return this.getSelectionManager().setLocationRange(e4);
  }
  getPosition() {
    const t5 = this.getLocationRange();
    if (t5)
      return this.document.positionFromLocation(t5[0]);
  }
  getLocationRange(t5) {
    return this.targetLocationRange ? this.targetLocationRange : this.getSelectionManager().getLocationRange(t5) || wt({ index: 0, offset: 0 });
  }
  withTargetLocationRange(t5, e4) {
    let i4;
    this.targetLocationRange = t5;
    try {
      i4 = e4();
    } finally {
      this.targetLocationRange = null;
    }
    return i4;
  }
  withTargetRange(t5, e4) {
    const i4 = this.document.locationRangeFromRange(t5);
    return this.withTargetLocationRange(i4, e4);
  }
  withTargetDOMRange(t5, e4) {
    const i4 = this.createLocationRangeFromDOMRange(t5, { strict: false });
    return this.withTargetLocationRange(i4, e4);
  }
  getExpandedRangeInDirection(t5) {
    let { length: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, [i4, n3] = Array.from(this.getSelectedRange());
    return t5 === "backward" ? e4 ? i4 -= e4 : i4 = this.translateUTF16PositionFromOffset(i4, -1) : e4 ? n3 += e4 : n3 = this.translateUTF16PositionFromOffset(n3, 1), wt([i4, n3]);
  }
  shouldManageMovingCursorInDirection(t5) {
    if (this.editingAttachment)
      return true;
    const e4 = this.getExpandedRangeInDirection(t5);
    return this.getAttachmentAtRange(e4) != null;
  }
  moveCursorInDirection(t5) {
    let e4, i4;
    if (this.editingAttachment)
      i4 = this.document.getRangeOfAttachment(this.editingAttachment);
    else {
      const n3 = this.getSelectedRange();
      i4 = this.getExpandedRangeInDirection(t5), e4 = !Dt(n3, i4);
    }
    if (t5 === "backward" ? this.setSelectedRange(i4[0]) : this.setSelectedRange(i4[1]), e4) {
      const t6 = this.getAttachmentAtRange(i4);
      if (t6)
        return this.editAttachment(t6);
    }
  }
  expandSelectionInDirection(t5) {
    let { length: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const i4 = this.getExpandedRangeInDirection(t5, { length: e4 });
    return this.setSelectedRange(i4);
  }
  expandSelectionForEditing() {
    if (this.hasCurrentAttribute("href"))
      return this.expandSelectionAroundCommonAttribute("href");
  }
  expandSelectionAroundCommonAttribute(t5) {
    const e4 = this.getPosition(), i4 = this.document.getRangeOfCommonAttributeAtPosition(t5, e4);
    return this.setSelectedRange(i4);
  }
  selectionContainsAttachments() {
    var t5;
    return ((t5 = this.getSelectedAttachments()) === null || t5 === undefined ? undefined : t5.length) > 0;
  }
  selectionIsInCursorTarget() {
    return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
  }
  positionIsCursorTarget(t5) {
    const e4 = this.document.locationFromPosition(t5);
    if (e4)
      return this.locationIsCursorTarget(e4);
  }
  positionIsBlockBreak(t5) {
    var e4;
    return (e4 = this.document.getPieceAtPosition(t5)) === null || e4 === undefined ? undefined : e4.isBlockBreak();
  }
  getSelectedDocument() {
    const t5 = this.getSelectedRange();
    if (t5)
      return this.document.getDocumentAtRange(t5);
  }
  getSelectedAttachments() {
    var t5;
    return (t5 = this.getSelectedDocument()) === null || t5 === undefined ? undefined : t5.getAttachments();
  }
  getAttachments() {
    return this.attachments.slice(0);
  }
  refreshAttachments() {
    const t5 = this.document.getAttachments(), { added: e4, removed: i4 } = function() {
      let t6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [], e5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      const i5 = [], n3 = [], r4 = new Set;
      t6.forEach((t7) => {
        r4.add(t7);
      });
      const o3 = new Set;
      return e5.forEach((t7) => {
        o3.add(t7), r4.has(t7) || i5.push(t7);
      }), t6.forEach((t7) => {
        o3.has(t7) || n3.push(t7);
      }), { added: i5, removed: n3 };
    }(this.attachments, t5);
    return this.attachments = t5, Array.from(i4).forEach((t6) => {
      var e5, i5;
      t6.delegate = null, (e5 = this.delegate) === null || e5 === undefined || (i5 = e5.compositionDidRemoveAttachment) === null || i5 === undefined || i5.call(e5, t6);
    }), (() => {
      const t6 = [];
      return Array.from(e4).forEach((e5) => {
        var i5, n3;
        e5.delegate = this, t6.push((i5 = this.delegate) === null || i5 === undefined || (n3 = i5.compositionDidAddAttachment) === null || n3 === undefined ? undefined : n3.call(i5, e5));
      }), t6;
    })();
  }
  attachmentDidChangeAttributes(t5) {
    var e4, i4;
    return this.revision++, (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionDidEditAttachment) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  attachmentDidChangePreviewURL(t5) {
    var e4, i4;
    return this.revision++, (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionDidChangeAttachmentPreviewURL) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  editAttachment(t5, e4) {
    var i4, n3;
    if (t5 !== this.editingAttachment)
      return this.stopEditingAttachment(), this.editingAttachment = t5, (i4 = this.delegate) === null || i4 === undefined || (n3 = i4.compositionDidStartEditingAttachment) === null || n3 === undefined ? undefined : n3.call(i4, this.editingAttachment, e4);
  }
  stopEditingAttachment() {
    var t5, e4;
    this.editingAttachment && ((t5 = this.delegate) === null || t5 === undefined || (e4 = t5.compositionDidStopEditingAttachment) === null || e4 === undefined || e4.call(t5, this.editingAttachment), this.editingAttachment = null);
  }
  updateAttributesForAttachment(t5, e4) {
    return this.setDocument(this.document.updateAttributesForAttachment(t5, e4));
  }
  removeAttributeForAttachment(t5, e4) {
    return this.setDocument(this.document.removeAttributeForAttachment(t5, e4));
  }
  breakFormattedBlock(t5) {
    let { document: e4 } = t5;
    const { block: i4 } = t5;
    let n3 = t5.startPosition, r4 = [n3 - 1, n3];
    i4.getBlockBreakPosition() === t5.startLocation.offset ? (i4.breaksOnReturn() && t5.nextCharacter === `
` ? n3 += 1 : e4 = e4.removeTextAtRange(r4), r4 = [n3, n3]) : t5.nextCharacter === `
` ? t5.previousCharacter === `
` ? r4 = [n3 - 1, n3 + 1] : (r4 = [n3, n3 + 1], n3 += 1) : t5.startLocation.offset - 1 != 0 && (n3 += 1);
    const o3 = new an([i4.removeLastAttribute().copyWithoutText()]);
    return this.setDocument(e4.insertDocumentAtRange(o3, r4)), this.setSelection(n3);
  }
  getPreviousBlock() {
    const t5 = this.getLocationRange();
    if (t5) {
      const { index: e4 } = t5[0];
      if (e4 > 0)
        return this.document.getBlockAtIndex(e4 - 1);
    }
  }
  getBlock() {
    const t5 = this.getLocationRange();
    if (t5)
      return this.document.getBlockAtIndex(t5[0].index);
  }
  getAttachmentAtRange(t5) {
    const e4 = this.document.getDocumentAtRange(t5);
    if (e4.toString() === "".concat("", `
`))
      return e4.getAttachments()[0];
  }
  notifyDelegateOfCurrentAttributesChange() {
    var t5, e4;
    return (t5 = this.delegate) === null || t5 === undefined || (e4 = t5.compositionDidChangeCurrentAttributes) === null || e4 === undefined ? undefined : e4.call(t5, this.currentAttributes);
  }
  notifyDelegateOfInsertionAtRange(t5) {
    var e4, i4;
    return (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionDidPerformInsertionAtRange) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  translateUTF16PositionFromOffset(t5, e4) {
    const i4 = this.document.toUTF16String(), n3 = i4.offsetFromUCS2Offset(t5);
    return i4.offsetToUCS2Offset(n3 + e4);
  }
}
wn.proxyMethod("getSelectionManager().getPointRange"), wn.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), wn.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), wn.proxyMethod("getSelectionManager().locationIsCursorTarget"), wn.proxyMethod("getSelectionManager().selectionIsExpanded"), wn.proxyMethod("delegate?.getSelectionManager");

class Ln extends q3 {
  constructor(t5) {
    super(...arguments), this.composition = t5, this.undoEntries = [], this.redoEntries = [];
  }
  recordUndoEntry(t5) {
    let { context: e4, consolidatable: i4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const n3 = this.undoEntries.slice(-1)[0];
    if (!i4 || !Dn(n3, t5, e4)) {
      const i5 = this.createEntry({ description: t5, context: e4 });
      this.undoEntries.push(i5), this.redoEntries = [];
    }
  }
  undo() {
    const t5 = this.undoEntries.pop();
    if (t5) {
      const e4 = this.createEntry(t5);
      return this.redoEntries.push(e4), this.composition.loadSnapshot(t5.snapshot);
    }
  }
  redo() {
    const t5 = this.redoEntries.pop();
    if (t5) {
      const e4 = this.createEntry(t5);
      return this.undoEntries.push(e4), this.composition.loadSnapshot(t5.snapshot);
    }
  }
  canUndo() {
    return this.undoEntries.length > 0;
  }
  canRedo() {
    return this.redoEntries.length > 0;
  }
  createEntry() {
    let { description: t5, context: e4 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return { description: t5 == null ? undefined : t5.toString(), context: JSON.stringify(e4), snapshot: this.composition.getSnapshot() };
  }
}
var Dn = (t5, e4, i4) => (t5 == null ? undefined : t5.description) === (e4 == null ? undefined : e4.toString()) && (t5 == null ? undefined : t5.context) === JSON.stringify(i4);
var Nn = "attachmentGallery";

class In {
  constructor(t5) {
    this.document = t5.document, this.selectedRange = t5.selectedRange;
  }
  perform() {
    return this.removeBlockAttribute(), this.applyBlockAttribute();
  }
  getSnapshot() {
    return { document: this.document, selectedRange: this.selectedRange };
  }
  removeBlockAttribute() {
    return this.findRangesOfBlocks().map((t5) => this.document = this.document.removeAttributeAtRange(Nn, t5));
  }
  applyBlockAttribute() {
    let t5 = 0;
    this.findRangesOfPieces().forEach((e4) => {
      e4[1] - e4[0] > 1 && (e4[0] += t5, e4[1] += t5, this.document.getCharacterAtPosition(e4[1]) !== `
` && (this.document = this.document.insertBlockBreakAtRange(e4[1]), e4[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), e4[1]++, t5++), e4[0] !== 0 && this.document.getCharacterAtPosition(e4[0] - 1) !== `
` && (this.document = this.document.insertBlockBreakAtRange(e4[0]), e4[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), e4[0]++, t5++), this.document = this.document.applyBlockAttributeAtRange(Nn, true, e4));
    });
  }
  findRangesOfBlocks() {
    return this.document.findRangesForBlockAttribute(Nn);
  }
  findRangesOfPieces() {
    return this.document.findRangesForTextAttribute("presentation", { withValue: "gallery" });
  }
  moveSelectedRangeForward() {
    this.selectedRange[0] += 1, this.selectedRange[1] += 1;
  }
}
var On = function(t5) {
  const e4 = new In(t5);
  return e4.perform(), e4.getSnapshot();
};
var Fn = [On];

class Pn {
  constructor(t5, e4, i4) {
    this.insertFiles = this.insertFiles.bind(this), this.composition = t5, this.selectionManager = e4, this.element = i4, this.undoManager = new Ln(this.composition), this.filters = Fn.slice(0);
  }
  loadDocument(t5) {
    return this.loadSnapshot({ document: t5, selectedRange: [0, 0] });
  }
  loadHTML() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    const e4 = hn.parse(t5, { referenceElement: this.element }).getDocument();
    return this.loadDocument(e4);
  }
  loadJSON(t5) {
    let { document: e4, selectedRange: i4 } = t5;
    return e4 = an.fromJSON(e4), this.loadSnapshot({ document: e4, selectedRange: i4 });
  }
  loadSnapshot(t5) {
    return this.undoManager = new Ln(this.composition), this.composition.loadSnapshot(t5);
  }
  getDocument() {
    return this.composition.document;
  }
  getSelectedDocument() {
    return this.composition.getSelectedDocument();
  }
  getSnapshot() {
    return this.composition.getSnapshot();
  }
  toJSON() {
    return this.getSnapshot();
  }
  deleteInDirection(t5) {
    return this.composition.deleteInDirection(t5);
  }
  insertAttachment(t5) {
    return this.composition.insertAttachment(t5);
  }
  insertAttachments(t5) {
    return this.composition.insertAttachments(t5);
  }
  insertDocument(t5) {
    return this.composition.insertDocument(t5);
  }
  insertFile(t5) {
    return this.composition.insertFile(t5);
  }
  insertFiles(t5) {
    return this.composition.insertFiles(t5);
  }
  insertHTML(t5) {
    return this.composition.insertHTML(t5);
  }
  insertString(t5) {
    return this.composition.insertString(t5);
  }
  insertText(t5) {
    return this.composition.insertText(t5);
  }
  insertLineBreak() {
    return this.composition.insertLineBreak();
  }
  getSelectedRange() {
    return this.composition.getSelectedRange();
  }
  getPosition() {
    return this.composition.getPosition();
  }
  getClientRectAtPosition(t5) {
    const e4 = this.getDocument().locationRangeFromRange([t5, t5 + 1]);
    return this.selectionManager.getClientRectAtLocationRange(e4);
  }
  expandSelectionInDirection(t5) {
    return this.composition.expandSelectionInDirection(t5);
  }
  moveCursorInDirection(t5) {
    return this.composition.moveCursorInDirection(t5);
  }
  setSelectedRange(t5) {
    return this.composition.setSelectedRange(t5);
  }
  activateAttribute(t5) {
    let e4 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
    return this.composition.setCurrentAttribute(t5, e4);
  }
  attributeIsActive(t5) {
    return this.composition.hasCurrentAttribute(t5);
  }
  canActivateAttribute(t5) {
    return this.composition.canSetCurrentAttribute(t5);
  }
  deactivateAttribute(t5) {
    return this.composition.removeCurrentAttribute(t5);
  }
  setHTMLAtributeAtPosition(t5, e4, i4) {
    this.composition.setHTMLAtributeAtPosition(t5, e4, i4);
  }
  canDecreaseNestingLevel() {
    return this.composition.canDecreaseNestingLevel();
  }
  canIncreaseNestingLevel() {
    return this.composition.canIncreaseNestingLevel();
  }
  decreaseNestingLevel() {
    if (this.canDecreaseNestingLevel())
      return this.composition.decreaseNestingLevel();
  }
  increaseNestingLevel() {
    if (this.canIncreaseNestingLevel())
      return this.composition.increaseNestingLevel();
  }
  canRedo() {
    return this.undoManager.canRedo();
  }
  canUndo() {
    return this.undoManager.canUndo();
  }
  recordUndoEntry(t5) {
    let { context: e4, consolidatable: i4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.undoManager.recordUndoEntry(t5, { context: e4, consolidatable: i4 });
  }
  redo() {
    if (this.canRedo())
      return this.undoManager.redo();
  }
  undo() {
    if (this.canUndo())
      return this.undoManager.undo();
  }
}

class Mn {
  constructor(t5) {
    this.element = t5;
  }
  findLocationFromContainerAndOffset(t5, e4) {
    let { strict: i4 } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { strict: true }, n3 = 0, r4 = false;
    const o3 = { index: 0, offset: 0 }, s4 = this.findAttachmentElementParentForNode(t5);
    s4 && (t5 = s4.parentNode, e4 = E2(s4));
    const a4 = R(this.element, { usingFilter: Wn });
    for (;a4.nextNode(); ) {
      const s5 = a4.currentNode;
      if (s5 === t5 && B3(t5)) {
        F4(s5) || (o3.offset += e4);
        break;
      }
      if (s5.parentNode === t5) {
        if (n3++ === e4)
          break;
      } else if (!C3(t5, s5) && n3 > 0)
        break;
      N3(s5, { strict: i4 }) ? (r4 && o3.index++, o3.offset = 0, r4 = true) : o3.offset += Bn(s5);
    }
    return o3;
  }
  findContainerAndOffsetFromLocation(t5) {
    let e4, i4;
    if (t5.index === 0 && t5.offset === 0) {
      for (e4 = this.element, i4 = 0;e4.firstChild; )
        if (e4 = e4.firstChild, D3(e4)) {
          i4 = 1;
          break;
        }
      return [e4, i4];
    }
    let [n3, r4] = this.findNodeAndOffsetFromLocation(t5);
    if (n3) {
      if (B3(n3))
        Bn(n3) === 0 ? (e4 = n3.parentNode.parentNode, i4 = E2(n3.parentNode), F4(n3, { name: "right" }) && i4++) : (e4 = n3, i4 = t5.offset - r4);
      else {
        if (e4 = n3.parentNode, !N3(n3.previousSibling) && !D3(e4))
          for (;n3 === e4.lastChild && (n3 = e4, e4 = e4.parentNode, !D3(e4)); )
            ;
        i4 = E2(n3), t5.offset !== 0 && i4++;
      }
      return [e4, i4];
    }
  }
  findNodeAndOffsetFromLocation(t5) {
    let e4, i4, n3 = 0;
    for (const r4 of this.getSignificantNodesForIndex(t5.index)) {
      const o3 = Bn(r4);
      if (t5.offset <= n3 + o3)
        if (B3(r4)) {
          if (e4 = r4, i4 = n3, t5.offset === i4 && F4(e4))
            break;
        } else
          e4 || (e4 = r4, i4 = n3);
      if (n3 += o3, n3 > t5.offset)
        break;
    }
    return [e4, i4];
  }
  findAttachmentElementParentForNode(t5) {
    for (;t5 && t5 !== this.element; ) {
      if (P3(t5))
        return t5;
      t5 = t5.parentNode;
    }
  }
  getSignificantNodesForIndex(t5) {
    const e4 = [], i4 = R(this.element, { usingFilter: _n });
    let n3 = false;
    for (;i4.nextNode(); ) {
      const o3 = i4.currentNode;
      var r4;
      if (I3(o3)) {
        if (r4 != null ? r4++ : r4 = 0, r4 === t5)
          n3 = true;
        else if (n3)
          break;
      } else
        n3 && e4.push(o3);
    }
    return e4;
  }
}
var Bn = function(t5) {
  if (t5.nodeType === Node.TEXT_NODE) {
    if (F4(t5))
      return 0;
    return t5.textContent.length;
  }
  return k3(t5) === "br" || P3(t5) ? 1 : 0;
};
var _n = function(t5) {
  return jn(t5) === NodeFilter.FILTER_ACCEPT ? Wn(t5) : NodeFilter.FILTER_REJECT;
};
var jn = function(t5) {
  return M2(t5) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
};
var Wn = function(t5) {
  return P3(t5.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
};

class Un {
  createDOMRangeFromPoint(t5) {
    let e4, { x: i4, y: n3 } = t5;
    if (document.caretPositionFromPoint) {
      const { offsetNode: t6, offset: r4 } = document.caretPositionFromPoint(i4, n3);
      return e4 = document.createRange(), e4.setStart(t6, r4), e4;
    }
    if (document.caretRangeFromPoint)
      return document.caretRangeFromPoint(i4, n3);
    if (document.body.createTextRange) {
      const t6 = Mt();
      try {
        const t7 = document.body.createTextRange();
        t7.moveToPoint(i4, n3), t7.select();
      } catch (t7) {}
      return e4 = Mt(), Bt(t6), e4;
    }
  }
  getClientRectsForDOMRange(t5) {
    const e4 = Array.from(t5.getClientRects());
    return [e4[0], e4[e4.length - 1]];
  }
}

class Vn extends q3 {
  constructor(t5) {
    super(...arguments), this.didMouseDown = this.didMouseDown.bind(this), this.selectionDidChange = this.selectionDidChange.bind(this), this.element = t5, this.locationMapper = new Mn(this.element), this.pointMapper = new Un, this.lockCount = 0, b3("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
  }
  getLocationRange() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return t5.strict === false ? this.createLocationRangeFromDOMRange(Mt()) : t5.ignoreLock ? this.currentLocationRange : this.lockedLocationRange ? this.lockedLocationRange : this.currentLocationRange;
  }
  setLocationRange(t5) {
    if (this.lockedLocationRange)
      return;
    t5 = wt(t5);
    const e4 = this.createDOMRangeFromLocationRange(t5);
    e4 && (Bt(e4), this.updateCurrentLocationRange(t5));
  }
  setLocationRangeFromPointRange(t5) {
    t5 = wt(t5);
    const e4 = this.getLocationAtPoint(t5[0]), i4 = this.getLocationAtPoint(t5[1]);
    this.setLocationRange([e4, i4]);
  }
  getClientRectAtLocationRange(t5) {
    const e4 = this.createDOMRangeFromLocationRange(t5);
    if (e4)
      return this.getClientRectsForDOMRange(e4)[1];
  }
  locationIsCursorTarget(t5) {
    const e4 = Array.from(this.findNodeAndOffsetFromLocation(t5))[0];
    return F4(e4);
  }
  lock() {
    this.lockCount++ == 0 && (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange());
  }
  unlock() {
    if (--this.lockCount == 0) {
      const { lockedLocationRange: t5 } = this;
      if (this.lockedLocationRange = null, t5 != null)
        return this.setLocationRange(t5);
    }
  }
  clearSelection() {
    var t5;
    return (t5 = Pt()) === null || t5 === undefined ? undefined : t5.removeAllRanges();
  }
  selectionIsCollapsed() {
    var t5;
    return ((t5 = Mt()) === null || t5 === undefined ? undefined : t5.collapsed) === true;
  }
  selectionIsExpanded() {
    return !this.selectionIsCollapsed();
  }
  createLocationRangeFromDOMRange(t5, e4) {
    if (t5 == null || !this.domRangeWithinElement(t5))
      return;
    const i4 = this.findLocationFromContainerAndOffset(t5.startContainer, t5.startOffset, e4);
    if (!i4)
      return;
    const n3 = t5.collapsed ? undefined : this.findLocationFromContainerAndOffset(t5.endContainer, t5.endOffset, e4);
    return wt([i4, n3]);
  }
  didMouseDown() {
    return this.pauseTemporarily();
  }
  pauseTemporarily() {
    let t5;
    this.paused = true;
    const e4 = () => {
      if (this.paused = false, clearTimeout(i4), Array.from(t5).forEach((t6) => {
        t6.destroy();
      }), C3(document, this.element))
        return this.selectionDidChange();
    }, i4 = setTimeout(e4, 200);
    t5 = ["mousemove", "keydown"].map((t6) => b3(t6, { onElement: document, withCallback: e4 }));
  }
  selectionDidChange() {
    if (!this.paused && !x4(this.element))
      return this.updateCurrentLocationRange();
  }
  updateCurrentLocationRange(t5) {
    var e4, i4;
    if ((t5 != null ? t5 : t5 = this.createLocationRangeFromDOMRange(Mt())) && !Dt(t5, this.currentLocationRange))
      return this.currentLocationRange = t5, (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.locationRangeDidChange) === null || i4 === undefined ? undefined : i4.call(e4, this.currentLocationRange.slice(0));
  }
  createDOMRangeFromLocationRange(t5) {
    const e4 = this.findContainerAndOffsetFromLocation(t5[0]), i4 = Lt(t5) ? e4 : this.findContainerAndOffsetFromLocation(t5[1]) || e4;
    if (e4 != null && i4 != null) {
      const t6 = document.createRange();
      return t6.setStart(...Array.from(e4 || [])), t6.setEnd(...Array.from(i4 || [])), t6;
    }
  }
  getLocationAtPoint(t5) {
    const e4 = this.createDOMRangeFromPoint(t5);
    var i4;
    if (e4)
      return (i4 = this.createLocationRangeFromDOMRange(e4)) === null || i4 === undefined ? undefined : i4[0];
  }
  domRangeWithinElement(t5) {
    return t5.collapsed ? C3(this.element, t5.startContainer) : C3(this.element, t5.startContainer) && C3(this.element, t5.endContainer);
  }
}
Vn.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), Vn.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), Vn.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), Vn.proxyMethod("pointMapper.createDOMRangeFromPoint"), Vn.proxyMethod("pointMapper.getClientRectsForDOMRange");
var zn = Object.freeze({ __proto__: null, Attachment: Vi, AttachmentManager: kn, AttachmentPiece: zi, Block: Xi, Composition: wn, Document: an, Editor: Pn, HTMLParser: hn, HTMLSanitizer: di, LineBreakInsertion: Tn, LocationMapper: Mn, ManagedAttachment: Rn, Piece: Wi, PointMapper: Un, SelectionManager: Vn, SplittableList: Hi, StringPiece: qi, Text: Yi, UndoManager: Ln });
var qn = Object.freeze({ __proto__: null, ObjectView: ie, AttachmentView: pi, BlockView: Ei, DocumentView: Si, PieceView: Ai, PreviewableAttachmentView: vi, TextView: yi });
var { lang: Hn, css: Jn, keyNames: Kn } = z3;
var Gn = function(t5) {
  return function() {
    const e4 = t5.apply(this, arguments);
    e4.do(), this.undos || (this.undos = []), this.undos.push(e4.undo);
  };
};

class Yn extends q3 {
  constructor(t5, e4, i4) {
    let n3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    super(...arguments), Di(this, "makeElementMutable", Gn(() => ({ do: () => {
      this.element.dataset.trixMutable = true;
    }, undo: () => delete this.element.dataset.trixMutable }))), Di(this, "addToolbar", Gn(() => {
      const t6 = T4({ tagName: "div", className: Jn.attachmentToolbar, data: { trixMutable: true }, childNodes: T4({ tagName: "div", className: "trix-button-row", childNodes: T4({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: T4({ tagName: "button", className: "trix-button trix-button--remove", textContent: Hn.remove, attributes: { title: Hn.remove }, data: { trixAction: "remove" } }) }) }) });
      return this.attachment.isPreviewable() && t6.appendChild(T4({ tagName: "div", className: Jn.attachmentMetadataContainer, childNodes: T4({ tagName: "span", className: Jn.attachmentMetadata, childNodes: [T4({ tagName: "span", className: Jn.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), T4({ tagName: "span", className: Jn.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), b3("click", { onElement: t6, withCallback: this.didClickToolbar }), b3("click", { onElement: t6, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), v3("trix-attachment-before-toolbar", { onElement: this.element, attributes: { toolbar: t6, attachment: this.attachment } }), { do: () => this.element.appendChild(t6), undo: () => S2(t6) };
    })), Di(this, "installCaptionEditor", Gn(() => {
      const t6 = T4({ tagName: "textarea", className: Jn.attachmentCaptionEditor, attributes: { placeholder: Hn.captionPlaceholder }, data: { trixMutable: true } });
      t6.value = this.attachmentPiece.getCaption();
      const e5 = t6.cloneNode();
      e5.classList.add("trix-autoresize-clone"), e5.tabIndex = -1;
      const i5 = function() {
        e5.value = t6.value, t6.style.height = e5.scrollHeight + "px";
      };
      b3("input", { onElement: t6, withCallback: i5 }), b3("input", { onElement: t6, withCallback: this.didInputCaption }), b3("keydown", { onElement: t6, withCallback: this.didKeyDownCaption }), b3("change", { onElement: t6, withCallback: this.didChangeCaption }), b3("blur", { onElement: t6, withCallback: this.didBlurCaption });
      const n4 = this.element.querySelector("figcaption"), r4 = n4.cloneNode();
      return { do: () => {
        if (n4.style.display = "none", r4.appendChild(t6), r4.appendChild(e5), r4.classList.add("".concat(Jn.attachmentCaption, "--editing")), n4.parentElement.insertBefore(r4, n4), i5(), this.options.editCaption)
          return Rt(() => t6.focus());
      }, undo() {
        S2(r4), n4.style.display = null;
      } };
    })), this.didClickToolbar = this.didClickToolbar.bind(this), this.didClickActionButton = this.didClickActionButton.bind(this), this.didKeyDownCaption = this.didKeyDownCaption.bind(this), this.didInputCaption = this.didInputCaption.bind(this), this.didChangeCaption = this.didChangeCaption.bind(this), this.didBlurCaption = this.didBlurCaption.bind(this), this.attachmentPiece = t5, this.element = e4, this.container = i4, this.options = n3, this.attachment = this.attachmentPiece.attachment, k3(this.element) === "a" && (this.element = this.element.firstChild), this.install();
  }
  install() {
    this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() && this.installCaptionEditor();
  }
  uninstall() {
    var t5;
    let e4 = this.undos.pop();
    for (this.savePendingCaption();e4; )
      e4(), e4 = this.undos.pop();
    (t5 = this.delegate) === null || t5 === undefined || t5.didUninstallAttachmentEditor(this);
  }
  savePendingCaption() {
    if (this.pendingCaption != null) {
      const r4 = this.pendingCaption;
      var t5, e4, i4, n3;
      if (this.pendingCaption = null, r4)
        (t5 = this.delegate) === null || t5 === undefined || (e4 = t5.attachmentEditorDidRequestUpdatingAttributesForAttachment) === null || e4 === undefined || e4.call(t5, { caption: r4 }, this.attachment);
      else
        (i4 = this.delegate) === null || i4 === undefined || (n3 = i4.attachmentEditorDidRequestRemovingAttributeForAttachment) === null || n3 === undefined || n3.call(i4, "caption", this.attachment);
    }
  }
  didClickToolbar(t5) {
    return t5.preventDefault(), t5.stopPropagation();
  }
  didClickActionButton(t5) {
    var e4;
    if (t5.target.getAttribute("data-trix-action") === "remove")
      return (e4 = this.delegate) === null || e4 === undefined ? undefined : e4.attachmentEditorDidRequestRemovalOfAttachment(this.attachment);
  }
  didKeyDownCaption(t5) {
    var e4, i4;
    if (Kn[t5.keyCode] === "return")
      return t5.preventDefault(), this.savePendingCaption(), (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.attachmentEditorDidRequestDeselectingAttachment) === null || i4 === undefined ? undefined : i4.call(e4, this.attachment);
  }
  didInputCaption(t5) {
    this.pendingCaption = t5.target.value.replace(/\s/g, " ").trim();
  }
  didChangeCaption(t5) {
    return this.savePendingCaption();
  }
  didBlurCaption(t5) {
    return this.savePendingCaption();
  }
}

class Xn extends q3 {
  constructor(t5, i4) {
    super(...arguments), this.didFocus = this.didFocus.bind(this), this.didBlur = this.didBlur.bind(this), this.didClickAttachment = this.didClickAttachment.bind(this), this.element = t5, this.composition = i4, this.documentView = new Si(this.composition.document, { element: this.element }), b3("focus", { onElement: this.element, withCallback: this.didFocus }), b3("blur", { onElement: this.element, withCallback: this.didBlur }), b3("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), b3("mousedown", { onElement: this.element, matchingSelector: e3, withCallback: this.didClickAttachment }), b3("click", { onElement: this.element, matchingSelector: "a".concat(e3), preventDefault: true });
  }
  didFocus(t5) {
    var e4;
    const i4 = () => {
      var t6, e5;
      if (!this.focused)
        return this.focused = true, (t6 = this.delegate) === null || t6 === undefined || (e5 = t6.compositionControllerDidFocus) === null || e5 === undefined ? undefined : e5.call(t6);
    };
    return ((e4 = this.blurPromise) === null || e4 === undefined ? undefined : e4.then(i4)) || i4();
  }
  didBlur(t5) {
    this.blurPromise = new Promise((t6) => Rt(() => {
      var e4, i4;
      x4(this.element) || (this.focused = null, (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionControllerDidBlur) === null || i4 === undefined || i4.call(e4));
      return this.blurPromise = null, t6();
    }));
  }
  didClickAttachment(t5, e4) {
    var i4, n3;
    const r4 = this.findAttachmentForElement(e4), o3 = !!y3(t5.target, { matchingSelector: "figcaption" });
    return (i4 = this.delegate) === null || i4 === undefined || (n3 = i4.compositionControllerDidSelectAttachment) === null || n3 === undefined ? undefined : n3.call(i4, r4, { editCaption: o3 });
  }
  getSerializableElement() {
    return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
  }
  render() {
    var t5, e4, i4, n3, r4, o3;
    (this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced()) && ((i4 = this.delegate) === null || i4 === undefined || (n3 = i4.compositionControllerWillSyncDocumentView) === null || n3 === undefined || n3.call(i4), this.documentView.sync(), (r4 = this.delegate) === null || r4 === undefined || (o3 = r4.compositionControllerDidSyncDocumentView) === null || o3 === undefined || o3.call(r4));
    return (t5 = this.delegate) === null || t5 === undefined || (e4 = t5.compositionControllerDidRender) === null || e4 === undefined ? undefined : e4.call(t5);
  }
  rerenderViewForObject(t5) {
    return this.invalidateViewForObject(t5), this.render();
  }
  invalidateViewForObject(t5) {
    return this.documentView.invalidateViewForObject(t5);
  }
  isViewCachingEnabled() {
    return this.documentView.isViewCachingEnabled();
  }
  enableViewCaching() {
    return this.documentView.enableViewCaching();
  }
  disableViewCaching() {
    return this.documentView.disableViewCaching();
  }
  refreshViewCache() {
    return this.documentView.garbageCollectCachedViews();
  }
  isEditingAttachment() {
    return !!this.attachmentEditor;
  }
  installAttachmentEditorForAttachment(t5, e4) {
    var i4;
    if (((i4 = this.attachmentEditor) === null || i4 === undefined ? undefined : i4.attachment) === t5)
      return;
    const n3 = this.documentView.findElementForObject(t5);
    if (!n3)
      return;
    this.uninstallAttachmentEditor();
    const r4 = this.composition.document.getAttachmentPieceForAttachment(t5);
    this.attachmentEditor = new Yn(r4, n3, this.element, e4), this.attachmentEditor.delegate = this;
  }
  uninstallAttachmentEditor() {
    var t5;
    return (t5 = this.attachmentEditor) === null || t5 === undefined ? undefined : t5.uninstall();
  }
  didUninstallAttachmentEditor() {
    return this.attachmentEditor = null, this.render();
  }
  attachmentEditorDidRequestUpdatingAttributesForAttachment(t5, e4) {
    var i4, n3;
    return (i4 = this.delegate) === null || i4 === undefined || (n3 = i4.compositionControllerWillUpdateAttachment) === null || n3 === undefined || n3.call(i4, e4), this.composition.updateAttributesForAttachment(t5, e4);
  }
  attachmentEditorDidRequestRemovingAttributeForAttachment(t5, e4) {
    var i4, n3;
    return (i4 = this.delegate) === null || i4 === undefined || (n3 = i4.compositionControllerWillUpdateAttachment) === null || n3 === undefined || n3.call(i4, e4), this.composition.removeAttributeForAttachment(t5, e4);
  }
  attachmentEditorDidRequestRemovalOfAttachment(t5) {
    var e4, i4;
    return (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionControllerDidRequestRemovalOfAttachment) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  attachmentEditorDidRequestDeselectingAttachment(t5) {
    var e4, i4;
    return (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.compositionControllerDidRequestDeselectingAttachment) === null || i4 === undefined ? undefined : i4.call(e4, t5);
  }
  canSyncDocumentView() {
    return !this.isEditingAttachment();
  }
  findAttachmentForElement(t5) {
    return this.composition.document.getAttachmentById(parseInt(t5.dataset.trixId, 10));
  }
}

class $n extends q3 {
}
var Zn = "data-trix-mutable";
var Qn = "[".concat(Zn, "]");
var tr = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true };

class er extends q3 {
  constructor(t5) {
    super(t5), this.didMutate = this.didMutate.bind(this), this.element = t5, this.observer = new window.MutationObserver(this.didMutate), this.start();
  }
  start() {
    return this.reset(), this.observer.observe(this.element, tr);
  }
  stop() {
    return this.observer.disconnect();
  }
  didMutate(t5) {
    var e4, i4;
    if (this.mutations.push(...Array.from(this.findSignificantMutations(t5) || [])), this.mutations.length)
      return (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.elementDidMutate) === null || i4 === undefined || i4.call(e4, this.getMutationSummary()), this.reset();
  }
  reset() {
    this.mutations = [];
  }
  findSignificantMutations(t5) {
    return t5.filter((t6) => this.mutationIsSignificant(t6));
  }
  mutationIsSignificant(t5) {
    if (this.nodeIsMutable(t5.target))
      return false;
    for (const e4 of Array.from(this.nodesModifiedByMutation(t5)))
      if (this.nodeIsSignificant(e4))
        return true;
    return false;
  }
  nodeIsSignificant(t5) {
    return t5 !== this.element && !this.nodeIsMutable(t5) && !M2(t5);
  }
  nodeIsMutable(t5) {
    return y3(t5, { matchingSelector: Qn });
  }
  nodesModifiedByMutation(t5) {
    const e4 = [];
    switch (t5.type) {
      case "attributes":
        t5.attributeName !== Zn && e4.push(t5.target);
        break;
      case "characterData":
        e4.push(t5.target.parentNode), e4.push(t5.target);
        break;
      case "childList":
        e4.push(...Array.from(t5.addedNodes || [])), e4.push(...Array.from(t5.removedNodes || []));
    }
    return e4;
  }
  getMutationSummary() {
    return this.getTextMutationSummary();
  }
  getTextMutationSummary() {
    const { additions: t5, deletions: e4 } = this.getTextChangesFromCharacterData(), i4 = this.getTextChangesFromChildList();
    Array.from(i4.additions).forEach((e5) => {
      Array.from(t5).includes(e5) || t5.push(e5);
    }), e4.push(...Array.from(i4.deletions || []));
    const n3 = {}, r4 = t5.join("");
    r4 && (n3.textAdded = r4);
    const o3 = e4.join("");
    return o3 && (n3.textDeleted = o3), n3;
  }
  getMutationsByType(t5) {
    return Array.from(this.mutations).filter((e4) => e4.type === t5);
  }
  getTextChangesFromChildList() {
    let t5, e4;
    const i4 = [], n3 = [];
    Array.from(this.getMutationsByType("childList")).forEach((t6) => {
      i4.push(...Array.from(t6.addedNodes || [])), n3.push(...Array.from(t6.removedNodes || []));
    });
    i4.length === 0 && n3.length === 1 && I3(n3[0]) ? (t5 = [], e4 = [`
`]) : (t5 = ir(i4), e4 = ir(n3));
    const r4 = t5.filter((t6, i5) => t6 !== e4[i5]).map(Wt), o3 = e4.filter((e5, i5) => e5 !== t5[i5]).map(Wt);
    return { additions: r4, deletions: o3 };
  }
  getTextChangesFromCharacterData() {
    let t5, e4;
    const i4 = this.getMutationsByType("characterData");
    if (i4.length) {
      const n3 = i4[0], r4 = i4[i4.length - 1], o3 = function(t6, e5) {
        let i5, n4;
        return t6 = $3.box(t6), (e5 = $3.box(e5)).length < t6.length ? [n4, i5] = zt(t6, e5) : [i5, n4] = zt(e5, t6), { added: i5, removed: n4 };
      }(Wt(n3.oldValue), Wt(r4.target.data));
      t5 = o3.added, e4 = o3.removed;
    }
    return { additions: t5 ? [t5] : [], deletions: e4 ? [e4] : [] };
  }
}
var ir = function() {
  let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  const e4 = [];
  for (const i4 of Array.from(t5))
    switch (i4.nodeType) {
      case Node.TEXT_NODE:
        e4.push(i4.data);
        break;
      case Node.ELEMENT_NODE:
        k3(i4) === "br" ? e4.push(`
`) : e4.push(...Array.from(ir(i4.childNodes) || []));
    }
  return e4;
};

class nr extends ee {
  constructor(t5) {
    super(...arguments), this.file = t5;
  }
  perform(t5) {
    const e4 = new FileReader;
    return e4.onerror = () => t5(false), e4.onload = () => {
      e4.onerror = null;
      try {
        e4.abort();
      } catch (t6) {}
      return t5(true, this.file);
    }, e4.readAsArrayBuffer(this.file);
  }
}

class rr {
  constructor(t5) {
    this.element = t5;
  }
  shouldIgnore(t5) {
    return !!a3.samsungAndroid && (this.previousEvent = this.event, this.event = t5, this.checkSamsungKeyboardBuggyModeStart(), this.checkSamsungKeyboardBuggyModeEnd(), this.buggyMode);
  }
  checkSamsungKeyboardBuggyModeStart() {
    this.insertingLongTextAfterUnidentifiedChar() && or(this.element.innerText, this.event.data) && (this.buggyMode = true, this.event.preventDefault());
  }
  checkSamsungKeyboardBuggyModeEnd() {
    this.buggyMode && this.event.inputType !== "insertText" && (this.buggyMode = false);
  }
  insertingLongTextAfterUnidentifiedChar() {
    var t5;
    return this.isBeforeInputInsertText() && this.previousEventWasUnidentifiedKeydown() && ((t5 = this.event.data) === null || t5 === undefined ? undefined : t5.length) > 50;
  }
  isBeforeInputInsertText() {
    return this.event.type === "beforeinput" && this.event.inputType === "insertText";
  }
  previousEventWasUnidentifiedKeydown() {
    var t5, e4;
    return ((t5 = this.previousEvent) === null || t5 === undefined ? undefined : t5.type) === "keydown" && ((e4 = this.previousEvent) === null || e4 === undefined ? undefined : e4.key) === "Unidentified";
  }
}
var or = (t5, e4) => ar(t5) === ar(e4);
var sr = new RegExp("(".concat("", "|").concat(d2, "|").concat(g4, "|\\s)+"), "g");
var ar = (t5) => t5.replace(sr, " ").trim();

class lr extends q3 {
  constructor(t5) {
    super(...arguments), this.element = t5, this.mutationObserver = new er(this.element), this.mutationObserver.delegate = this, this.flakyKeyboardDetector = new rr(this.element);
    for (const t6 in this.constructor.events)
      b3(t6, { onElement: this.element, withCallback: this.handlerFor(t6) });
  }
  elementDidMutate(t5) {}
  editorWillSyncDocumentView() {
    return this.mutationObserver.stop();
  }
  editorDidSyncDocumentView() {
    return this.mutationObserver.start();
  }
  requestRender() {
    var t5, e4;
    return (t5 = this.delegate) === null || t5 === undefined || (e4 = t5.inputControllerDidRequestRender) === null || e4 === undefined ? undefined : e4.call(t5);
  }
  requestReparse() {
    var t5, e4;
    return (t5 = this.delegate) === null || t5 === undefined || (e4 = t5.inputControllerDidRequestReparse) === null || e4 === undefined || e4.call(t5), this.requestRender();
  }
  attachFiles(t5) {
    const e4 = Array.from(t5).map((t6) => new nr(t6));
    return Promise.all(e4).then((t6) => {
      this.handleInput(function() {
        var e5, i4;
        return (e5 = this.delegate) === null || e5 === undefined || e5.inputControllerWillAttachFiles(), (i4 = this.responder) === null || i4 === undefined || i4.insertFiles(t6), this.requestRender();
      });
    });
  }
  handlerFor(t5) {
    return (e4) => {
      e4.defaultPrevented || this.handleInput(() => {
        if (!x4(this.element)) {
          if (this.flakyKeyboardDetector.shouldIgnore(e4))
            return;
          this.eventName = t5, this.constructor.events[t5].call(this, e4);
        }
      });
    };
  }
  handleInput(t5) {
    try {
      var e4;
      (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillHandleInput(), t5.call(this);
    } finally {
      var i4;
      (i4 = this.delegate) === null || i4 === undefined || i4.inputControllerDidHandleInput();
    }
  }
  createLinkHTML(t5, e4) {
    const i4 = document.createElement("a");
    return i4.href = t5, i4.textContent = e4 || t5, i4.outerHTML;
  }
}
var cr;
Di(lr, "events", {});
var { browser: ur, keyNames: hr } = z3;
var dr = 0;

class gr extends lr {
  constructor() {
    super(...arguments), this.resetInputSummary();
  }
  setInputSummary() {
    let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.inputSummary.eventName = this.eventName;
    for (const e4 in t5) {
      const i4 = t5[e4];
      this.inputSummary[e4] = i4;
    }
    return this.inputSummary;
  }
  resetInputSummary() {
    this.inputSummary = {};
  }
  reset() {
    return this.resetInputSummary(), Ft.reset();
  }
  elementDidMutate(t5) {
    var e4, i4;
    return this.isComposing() ? (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.inputControllerDidAllowUnhandledInput) === null || i4 === undefined ? undefined : i4.call(e4) : this.handleInput(function() {
      return this.mutationIsSignificant(t5) && (this.mutationIsExpected(t5) ? this.requestRender() : this.requestReparse()), this.reset();
    });
  }
  mutationIsExpected(t5) {
    let { textAdded: e4, textDeleted: i4 } = t5;
    if (this.inputSummary.preferDocument)
      return true;
    const n3 = e4 != null ? e4 === this.inputSummary.textAdded : !this.inputSummary.textAdded, r4 = i4 != null ? this.inputSummary.didDelete : !this.inputSummary.didDelete, o3 = [`
`, ` 
`].includes(e4) && !n3, s4 = i4 === `
` && !r4;
    if (o3 && !s4 || s4 && !o3) {
      const t6 = this.getSelectedRange();
      if (t6) {
        var a4;
        const i5 = o3 ? e4.replace(/\n$/, "").length || -1 : (e4 == null ? undefined : e4.length) || 1;
        if ((a4 = this.responder) !== null && a4 !== undefined && a4.positionIsBlockBreak(t6[1] + i5))
          return true;
      }
    }
    return n3 && r4;
  }
  mutationIsSignificant(t5) {
    var e4;
    const i4 = Object.keys(t5).length > 0, n3 = ((e4 = this.compositionInput) === null || e4 === undefined ? undefined : e4.getEndData()) === "";
    return i4 || !n3;
  }
  getCompositionInput() {
    if (this.isComposing())
      return this.compositionInput;
    this.compositionInput = new vr(this);
  }
  isComposing() {
    return this.compositionInput && !this.compositionInput.isEnded();
  }
  deleteInDirection(t5, e4) {
    var i4;
    return ((i4 = this.responder) === null || i4 === undefined ? undefined : i4.deleteInDirection(t5)) !== false ? this.setInputSummary({ didDelete: true }) : e4 ? (e4.preventDefault(), this.requestRender()) : undefined;
  }
  serializeSelectionToDataTransfer(t5) {
    var e4;
    if (!function(t6) {
      if (t6 == null || !t6.setData)
        return false;
      for (const e5 in Ct) {
        const i5 = Ct[e5];
        try {
          if (t6.setData(e5, i5), !t6.getData(e5) === i5)
            return false;
        } catch (t7) {
          return false;
        }
      }
      return true;
    }(t5))
      return;
    const i4 = (e4 = this.responder) === null || e4 === undefined ? undefined : e4.getSelectedDocument().toSerializableDocument();
    return t5.setData("application/x-trix-document", JSON.stringify(i4)), t5.setData("text/html", Si.render(i4).innerHTML), t5.setData("text/plain", i4.toString().replace(/\n$/, "")), true;
  }
  canAcceptDataTransfer(t5) {
    const e4 = {};
    return Array.from((t5 == null ? undefined : t5.types) || []).forEach((t6) => {
      e4[t6] = true;
    }), e4.Files || e4["application/x-trix-document"] || e4["text/html"] || e4["text/plain"];
  }
  getPastedHTMLUsingHiddenElement(t5) {
    const e4 = this.getSelectedRange(), i4 = { position: "absolute", left: "".concat(window.pageXOffset, "px"), top: "".concat(window.pageYOffset, "px"), opacity: 0 }, n3 = T4({ style: i4, tagName: "div", editable: true });
    return document.body.appendChild(n3), n3.focus(), requestAnimationFrame(() => {
      const i5 = n3.innerHTML;
      return S2(n3), this.setSelectedRange(e4), t5(i5);
    });
  }
}
Di(gr, "events", { keydown(t5) {
  this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true;
  const e4 = hr[t5.keyCode];
  if (e4) {
    var i4;
    let n4 = this.keys;
    ["ctrl", "alt", "shift", "meta"].forEach((e5) => {
      var i5;
      t5["".concat(e5, "Key")] && (e5 === "ctrl" && (e5 = "control"), n4 = (i5 = n4) === null || i5 === undefined ? undefined : i5[e5]);
    }), ((i4 = n4) === null || i4 === undefined ? undefined : i4[e4]) != null && (this.setInputSummary({ keyName: e4 }), Ft.reset(), n4[e4].call(this, t5));
  }
  if (St(t5)) {
    const e5 = String.fromCharCode(t5.keyCode).toLowerCase();
    if (e5) {
      var n3;
      const i5 = ["alt", "shift"].map((e6) => {
        if (t5["".concat(e6, "Key")])
          return e6;
      }).filter((t6) => t6);
      i5.push(e5), (n3 = this.delegate) !== null && n3 !== undefined && n3.inputControllerDidReceiveKeyboardCommand(i5) && t5.preventDefault();
    }
  }
}, keypress(t5) {
  if (this.inputSummary.eventName != null)
    return;
  if (t5.metaKey)
    return;
  if (t5.ctrlKey && !t5.altKey)
    return;
  const e4 = fr(t5);
  var i4, n3;
  return e4 ? ((i4 = this.delegate) === null || i4 === undefined || i4.inputControllerWillPerformTyping(), (n3 = this.responder) === null || n3 === undefined || n3.insertString(e4), this.setInputSummary({ textAdded: e4, didDelete: this.selectionIsExpanded() })) : undefined;
}, textInput(t5) {
  const { data: e4 } = t5, { textAdded: i4 } = this.inputSummary;
  if (i4 && i4 !== e4 && i4.toUpperCase() === e4) {
    var n3;
    const t6 = this.getSelectedRange();
    return this.setSelectedRange([t6[0], t6[1] + i4.length]), (n3 = this.responder) === null || n3 === undefined || n3.insertString(e4), this.setInputSummary({ textAdded: e4 }), this.setSelectedRange(t6);
  }
}, dragenter(t5) {
  t5.preventDefault();
}, dragstart(t5) {
  var e4, i4;
  return this.serializeSelectionToDataTransfer(t5.dataTransfer), this.draggedRange = this.getSelectedRange(), (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.inputControllerDidStartDrag) === null || i4 === undefined ? undefined : i4.call(e4);
}, dragover(t5) {
  if (this.draggedRange || this.canAcceptDataTransfer(t5.dataTransfer)) {
    t5.preventDefault();
    const n3 = { x: t5.clientX, y: t5.clientY };
    var e4, i4;
    if (!Tt(n3, this.draggingPoint))
      return this.draggingPoint = n3, (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.inputControllerDidReceiveDragOverPoint) === null || i4 === undefined ? undefined : i4.call(e4, this.draggingPoint);
  }
}, dragend(t5) {
  var e4, i4;
  (e4 = this.delegate) === null || e4 === undefined || (i4 = e4.inputControllerDidCancelDrag) === null || i4 === undefined || i4.call(e4), this.draggedRange = null, this.draggingPoint = null;
}, drop(t5) {
  var e4, i4;
  t5.preventDefault();
  const n3 = (e4 = t5.dataTransfer) === null || e4 === undefined ? undefined : e4.files, r4 = t5.dataTransfer.getData("application/x-trix-document"), o3 = { x: t5.clientX, y: t5.clientY };
  if ((i4 = this.responder) === null || i4 === undefined || i4.setLocationRangeFromPointRange(o3), n3 != null && n3.length)
    this.attachFiles(n3);
  else if (this.draggedRange) {
    var s4, a4;
    (s4 = this.delegate) === null || s4 === undefined || s4.inputControllerWillMoveText(), (a4 = this.responder) === null || a4 === undefined || a4.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender();
  } else if (r4) {
    var l80;
    const t6 = an.fromJSONString(r4);
    (l80 = this.responder) === null || l80 === undefined || l80.insertDocument(t6), this.requestRender();
  }
  this.draggedRange = null, this.draggingPoint = null;
}, cut(t5) {
  var e4, i4;
  if ((e4 = this.responder) !== null && e4 !== undefined && e4.selectionIsExpanded() && (this.serializeSelectionToDataTransfer(t5.clipboardData) && t5.preventDefault(), (i4 = this.delegate) === null || i4 === undefined || i4.inputControllerWillCutText(), this.deleteInDirection("backward"), t5.defaultPrevented))
    return this.requestRender();
}, copy(t5) {
  var e4;
  (e4 = this.responder) !== null && e4 !== undefined && e4.selectionIsExpanded() && this.serializeSelectionToDataTransfer(t5.clipboardData) && t5.preventDefault();
}, paste(t5) {
  const e4 = t5.clipboardData || t5.testClipboardData, i4 = { clipboard: e4 };
  if (!e4 || br(t5))
    return void this.getPastedHTMLUsingHiddenElement((t6) => {
      var e5, n4, r5;
      return i4.type = "text/html", i4.html = t6, (e5 = this.delegate) === null || e5 === undefined || e5.inputControllerWillPaste(i4), (n4 = this.responder) === null || n4 === undefined || n4.insertHTML(i4.html), this.requestRender(), (r5 = this.delegate) === null || r5 === undefined ? undefined : r5.inputControllerDidPaste(i4);
    });
  const n3 = e4.getData("URL"), r4 = e4.getData("text/html"), o3 = e4.getData("public.url-name");
  if (n3) {
    var s4, a4, l80;
    let t6;
    i4.type = "text/html", t6 = o3 ? Vt(o3).trim() : n3, i4.html = this.createLinkHTML(n3, t6), (s4 = this.delegate) === null || s4 === undefined || s4.inputControllerWillPaste(i4), this.setInputSummary({ textAdded: t6, didDelete: this.selectionIsExpanded() }), (a4 = this.responder) === null || a4 === undefined || a4.insertHTML(i4.html), this.requestRender(), (l80 = this.delegate) === null || l80 === undefined || l80.inputControllerDidPaste(i4);
  } else if (Et(e4)) {
    var c4, u4, h4;
    i4.type = "text/plain", i4.string = e4.getData("text/plain"), (c4 = this.delegate) === null || c4 === undefined || c4.inputControllerWillPaste(i4), this.setInputSummary({ textAdded: i4.string, didDelete: this.selectionIsExpanded() }), (u4 = this.responder) === null || u4 === undefined || u4.insertString(i4.string), this.requestRender(), (h4 = this.delegate) === null || h4 === undefined || h4.inputControllerDidPaste(i4);
  } else if (r4) {
    var d3, g5, m4;
    i4.type = "text/html", i4.html = r4, (d3 = this.delegate) === null || d3 === undefined || d3.inputControllerWillPaste(i4), (g5 = this.responder) === null || g5 === undefined || g5.insertHTML(i4.html), this.requestRender(), (m4 = this.delegate) === null || m4 === undefined || m4.inputControllerDidPaste(i4);
  } else if (Array.from(e4.types).includes("Files")) {
    var p4, f4;
    const t6 = (p4 = e4.items) === null || p4 === undefined || (p4 = p4[0]) === null || p4 === undefined || (f4 = p4.getAsFile) === null || f4 === undefined ? undefined : f4.call(p4);
    if (t6) {
      var b4, v4, A4;
      const e5 = mr(t6);
      !t6.name && e5 && (t6.name = "pasted-file-".concat(++dr, ".").concat(e5)), i4.type = "File", i4.file = t6, (b4 = this.delegate) === null || b4 === undefined || b4.inputControllerWillAttachFiles(), (v4 = this.responder) === null || v4 === undefined || v4.insertFile(i4.file), this.requestRender(), (A4 = this.delegate) === null || A4 === undefined || A4.inputControllerDidPaste(i4);
    }
  }
  t5.preventDefault();
}, compositionstart(t5) {
  return this.getCompositionInput().start(t5.data);
}, compositionupdate(t5) {
  return this.getCompositionInput().update(t5.data);
}, compositionend(t5) {
  return this.getCompositionInput().end(t5.data);
}, beforeinput(t5) {
  this.inputSummary.didInput = true;
}, input(t5) {
  return this.inputSummary.didInput = true, t5.stopPropagation();
} }), Di(gr, "keys", { backspace(t5) {
  var e4;
  return (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t5);
}, delete(t5) {
  var e4;
  return (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t5);
}, return(t5) {
  var e4, i4;
  return this.setInputSummary({ preferDocument: true }), (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), (i4 = this.responder) === null || i4 === undefined ? undefined : i4.insertLineBreak();
}, tab(t5) {
  var e4, i4;
  (e4 = this.responder) !== null && e4 !== undefined && e4.canIncreaseNestingLevel() && ((i4 = this.responder) === null || i4 === undefined || i4.increaseNestingLevel(), this.requestRender(), t5.preventDefault());
}, left(t5) {
  var e4;
  if (this.selectionIsInCursorTarget())
    return t5.preventDefault(), (e4 = this.responder) === null || e4 === undefined ? undefined : e4.moveCursorInDirection("backward");
}, right(t5) {
  var e4;
  if (this.selectionIsInCursorTarget())
    return t5.preventDefault(), (e4 = this.responder) === null || e4 === undefined ? undefined : e4.moveCursorInDirection("forward");
}, control: { d(t5) {
  var e4;
  return (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t5);
}, h(t5) {
  var e4;
  return (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t5);
}, o(t5) {
  var e4, i4;
  return t5.preventDefault(), (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), (i4 = this.responder) === null || i4 === undefined || i4.insertString(`
`, { updatePosition: false }), this.requestRender();
} }, shift: { return(t5) {
  var e4, i4;
  (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), (i4 = this.responder) === null || i4 === undefined || i4.insertString(`
`), this.requestRender(), t5.preventDefault();
}, tab(t5) {
  var e4, i4;
  (e4 = this.responder) !== null && e4 !== undefined && e4.canDecreaseNestingLevel() && ((i4 = this.responder) === null || i4 === undefined || i4.decreaseNestingLevel(), this.requestRender(), t5.preventDefault());
}, left(t5) {
  if (this.selectionIsInCursorTarget())
    return t5.preventDefault(), this.expandSelectionInDirection("backward");
}, right(t5) {
  if (this.selectionIsInCursorTarget())
    return t5.preventDefault(), this.expandSelectionInDirection("forward");
} }, alt: { backspace(t5) {
  var e4;
  return this.setInputSummary({ preferDocument: false }), (e4 = this.delegate) === null || e4 === undefined ? undefined : e4.inputControllerWillPerformTyping();
} }, meta: { backspace(t5) {
  var e4;
  return this.setInputSummary({ preferDocument: false }), (e4 = this.delegate) === null || e4 === undefined ? undefined : e4.inputControllerWillPerformTyping();
} } }), gr.proxyMethod("responder?.getSelectedRange"), gr.proxyMethod("responder?.setSelectedRange"), gr.proxyMethod("responder?.expandSelectionInDirection"), gr.proxyMethod("responder?.selectionIsInCursorTarget"), gr.proxyMethod("responder?.selectionIsExpanded");
var mr = (t5) => {
  var e4;
  return (e4 = t5.type) === null || e4 === undefined || (e4 = e4.match(/\/(\w+)$/)) === null || e4 === undefined ? undefined : e4[1];
};
var pr = !((cr = " ".codePointAt) === null || cr === undefined || !cr.call(" ", 0));
var fr = function(t5) {
  if (t5.key && pr && t5.key.codePointAt(0) === t5.keyCode)
    return t5.key;
  {
    let e4;
    if (t5.which === null ? e4 = t5.keyCode : t5.which !== 0 && t5.charCode !== 0 && (e4 = t5.charCode), e4 != null && hr[e4] !== "escape")
      return $3.fromCodepoints([e4]).toString();
  }
};
var br = function(t5) {
  const e4 = t5.clipboardData;
  if (e4) {
    if (e4.types.includes("text/html")) {
      for (const t6 of e4.types) {
        const i4 = /^CorePasteboardFlavorType/.test(t6), n3 = /^dyn\./.test(t6) && e4.getData(t6);
        if (i4 || n3)
          return true;
      }
      return false;
    }
    {
      const t6 = e4.types.includes("com.apple.webarchive"), i4 = e4.types.includes("com.apple.flat-rtfd");
      return t6 || i4;
    }
  }
};

class vr extends q3 {
  constructor(t5) {
    super(...arguments), this.inputController = t5, this.responder = this.inputController.responder, this.delegate = this.inputController.delegate, this.inputSummary = this.inputController.inputSummary, this.data = {};
  }
  start(t5) {
    if (this.data.start = t5, this.isSignificant()) {
      var e4, i4;
      if (this.inputSummary.eventName === "keypress" && this.inputSummary.textAdded)
        (i4 = this.responder) === null || i4 === undefined || i4.deleteInDirection("left");
      this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = (e4 = this.responder) === null || e4 === undefined ? undefined : e4.getSelectedRange();
    }
  }
  update(t5) {
    if (this.data.update = t5, this.isSignificant()) {
      const t6 = this.selectPlaceholder();
      t6 && (this.forgetPlaceholder(), this.range = t6);
    }
  }
  end(t5) {
    return this.data.end = t5, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), (i4 = this.responder) === null || i4 === undefined || i4.setSelectedRange(this.range), (n3 = this.responder) === null || n3 === undefined || n3.insertString(this.data.end), (r4 = this.responder) === null || r4 === undefined ? undefined : r4.setSelectedRange(this.range[0] + this.data.end.length)) : this.data.start != null || this.data.update != null ? (this.requestReparse(), this.inputController.reset()) : undefined) : this.inputController.reset();
    var e4, i4, n3, r4;
  }
  getEndData() {
    return this.data.end;
  }
  isEnded() {
    return this.getEndData() != null;
  }
  isSignificant() {
    return !ur.composesExistingText || this.inputSummary.didInput;
  }
  canApplyToDocument() {
    var t5, e4;
    return ((t5 = this.data.start) === null || t5 === undefined ? undefined : t5.length) === 0 && ((e4 = this.data.end) === null || e4 === undefined ? undefined : e4.length) > 0 && this.range;
  }
}
vr.proxyMethod("inputController.setInputSummary"), vr.proxyMethod("inputController.requestRender"), vr.proxyMethod("inputController.requestReparse"), vr.proxyMethod("responder?.selectionIsExpanded"), vr.proxyMethod("responder?.insertPlaceholder"), vr.proxyMethod("responder?.selectPlaceholder"), vr.proxyMethod("responder?.forgetPlaceholder");

class Ar extends lr {
  constructor() {
    super(...arguments), this.render = this.render.bind(this);
  }
  elementDidMutate() {
    return this.scheduledRender ? this.composing ? (t5 = this.delegate) === null || t5 === undefined || (e4 = t5.inputControllerDidAllowUnhandledInput) === null || e4 === undefined ? undefined : e4.call(t5) : undefined : this.reparse();
    var t5, e4;
  }
  scheduleRender() {
    return this.scheduledRender ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
  }
  render() {
    var t5, e4;
    (cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing) || ((e4 = this.delegate) === null || e4 === undefined || e4.render());
    (t5 = this.afterRender) === null || t5 === undefined || t5.call(this), this.afterRender = null;
  }
  reparse() {
    var t5;
    return (t5 = this.delegate) === null || t5 === undefined ? undefined : t5.reparse();
  }
  insertString() {
    var t5;
    let e4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "", i4 = arguments.length > 1 ? arguments[1] : undefined;
    return (t5 = this.delegate) === null || t5 === undefined || t5.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.insertString(e4, i4);
    });
  }
  toggleAttributeIfSupported(t5) {
    var e4;
    if (gt().includes(t5))
      return (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformFormatting(t5), this.withTargetDOMRange(function() {
        var e5;
        return (e5 = this.responder) === null || e5 === undefined ? undefined : e5.toggleCurrentAttribute(t5);
      });
  }
  activateAttributeIfSupported(t5, e4) {
    var i4;
    if (gt().includes(t5))
      return (i4 = this.delegate) === null || i4 === undefined || i4.inputControllerWillPerformFormatting(t5), this.withTargetDOMRange(function() {
        var i5;
        return (i5 = this.responder) === null || i5 === undefined ? undefined : i5.setCurrentAttribute(t5, e4);
      });
  }
  deleteInDirection(t5) {
    let { recordUndoEntry: e4 } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { recordUndoEntry: true };
    var i4;
    e4 && ((i4 = this.delegate) === null || i4 === undefined || i4.inputControllerWillPerformTyping());
    const n3 = () => {
      var e5;
      return (e5 = this.responder) === null || e5 === undefined ? undefined : e5.deleteInDirection(t5);
    }, r4 = this.getTargetDOMRange({ minLength: this.composing ? 1 : 2 });
    return r4 ? this.withTargetDOMRange(r4, n3) : n3();
  }
  withTargetDOMRange(t5, e4) {
    var i4;
    return typeof t5 == "function" && (e4 = t5, t5 = this.getTargetDOMRange()), t5 ? (i4 = this.responder) === null || i4 === undefined ? undefined : i4.withTargetDOMRange(t5, e4.bind(this)) : (Ft.reset(), e4.call(this));
  }
  getTargetDOMRange() {
    var t5, e4;
    let { minLength: i4 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { minLength: 0 };
    const n3 = (t5 = (e4 = this.event).getTargetRanges) === null || t5 === undefined ? undefined : t5.call(e4);
    if (n3 && n3.length) {
      const t6 = yr(n3[0]);
      if (i4 === 0 || t6.toString().length >= i4)
        return t6;
    }
  }
  withEvent(t5, e4) {
    let i4;
    this.event = t5;
    try {
      i4 = e4.call(this);
    } finally {
      this.event = null;
    }
    return i4;
  }
}
Di(Ar, "events", { keydown(t5) {
  if (St(t5)) {
    var e4;
    const i4 = Rr(t5);
    (e4 = this.delegate) !== null && e4 !== undefined && e4.inputControllerDidReceiveKeyboardCommand(i4) && t5.preventDefault();
  } else {
    let e5 = t5.key;
    t5.altKey && (e5 += "+Alt"), t5.shiftKey && (e5 += "+Shift");
    const i4 = this.constructor.keys[e5];
    if (i4)
      return this.withEvent(t5, i4);
  }
}, paste(t5) {
  var e4;
  let i4;
  const n3 = (e4 = t5.clipboardData) === null || e4 === undefined ? undefined : e4.getData("URL");
  return Er(t5) ? (t5.preventDefault(), this.attachFiles(t5.clipboardData.files)) : Sr(t5) ? (t5.preventDefault(), i4 = { type: "text/plain", string: t5.clipboardData.getData("text/plain") }, (r4 = this.delegate) === null || r4 === undefined || r4.inputControllerWillPaste(i4), (o3 = this.responder) === null || o3 === undefined || o3.insertString(i4.string), this.render(), (s4 = this.delegate) === null || s4 === undefined ? undefined : s4.inputControllerDidPaste(i4)) : n3 ? (t5.preventDefault(), i4 = { type: "text/html", html: this.createLinkHTML(n3) }, (a4 = this.delegate) === null || a4 === undefined || a4.inputControllerWillPaste(i4), (l80 = this.responder) === null || l80 === undefined || l80.insertHTML(i4.html), this.render(), (c4 = this.delegate) === null || c4 === undefined ? undefined : c4.inputControllerDidPaste(i4)) : undefined;
  var r4, o3, s4, a4, l80, c4;
}, beforeinput(t5) {
  const e4 = this.constructor.inputTypes[t5.inputType], i4 = (n3 = t5, !(!/iPhone|iPad/.test(navigator.userAgent) || n3.inputType && n3.inputType !== "insertParagraph"));
  var n3;
  e4 && (this.withEvent(t5, e4), i4 || this.scheduleRender()), i4 && this.render();
}, input(t5) {
  Ft.reset();
}, dragstart(t5) {
  var e4, i4;
  (e4 = this.responder) !== null && e4 !== undefined && e4.selectionContainsAttachments() && (t5.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: (i4 = this.responder) === null || i4 === undefined ? undefined : i4.getSelectedRange(), point: kr(t5) });
}, dragenter(t5) {
  xr(t5) && t5.preventDefault();
}, dragover(t5) {
  if (this.dragging) {
    t5.preventDefault();
    const i4 = kr(t5);
    var e4;
    if (!Tt(i4, this.dragging.point))
      return this.dragging.point = i4, (e4 = this.responder) === null || e4 === undefined ? undefined : e4.setLocationRangeFromPointRange(i4);
  } else
    xr(t5) && t5.preventDefault();
}, drop(t5) {
  var e4, i4;
  if (this.dragging)
    return t5.preventDefault(), (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillMoveText(), (i4 = this.responder) === null || i4 === undefined || i4.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender();
  if (xr(t5)) {
    var n3;
    t5.preventDefault();
    const e5 = kr(t5);
    return (n3 = this.responder) === null || n3 === undefined || n3.setLocationRangeFromPointRange(e5), this.attachFiles(t5.dataTransfer.files);
  }
}, dragend() {
  var t5;
  this.dragging && ((t5 = this.responder) === null || t5 === undefined || t5.setSelectedRange(this.dragging.range), this.dragging = null);
}, compositionend(t5) {
  this.composing && (this.composing = false, a3.recentAndroid || this.scheduleRender());
} }), Di(Ar, "keys", { ArrowLeft() {
  var t5, e4;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.shouldManageMovingCursorInDirection("backward"))
    return this.event.preventDefault(), (e4 = this.responder) === null || e4 === undefined ? undefined : e4.moveCursorInDirection("backward");
}, ArrowRight() {
  var t5, e4;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.shouldManageMovingCursorInDirection("forward"))
    return this.event.preventDefault(), (e4 = this.responder) === null || e4 === undefined ? undefined : e4.moveCursorInDirection("forward");
}, Backspace() {
  var t5, e4, i4;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.shouldManageDeletingInDirection("backward"))
    return this.event.preventDefault(), (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillPerformTyping(), (i4 = this.responder) === null || i4 === undefined || i4.deleteInDirection("backward"), this.render();
}, Tab() {
  var t5, e4;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.canIncreaseNestingLevel())
    return this.event.preventDefault(), (e4 = this.responder) === null || e4 === undefined || e4.increaseNestingLevel(), this.render();
}, "Tab+Shift"() {
  var t5, e4;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.canDecreaseNestingLevel())
    return this.event.preventDefault(), (e4 = this.responder) === null || e4 === undefined || e4.decreaseNestingLevel(), this.render();
} }), Di(Ar, "inputTypes", { deleteByComposition() {
  return this.deleteInDirection("backward", { recordUndoEntry: false });
}, deleteByCut() {
  return this.deleteInDirection("backward");
}, deleteByDrag() {
  return this.event.preventDefault(), this.withTargetDOMRange(function() {
    var t5;
    this.deleteByDragRange = (t5 = this.responder) === null || t5 === undefined ? undefined : t5.getSelectedRange();
  });
}, deleteCompositionText() {
  return this.deleteInDirection("backward", { recordUndoEntry: false });
}, deleteContent() {
  return this.deleteInDirection("backward");
}, deleteContentBackward() {
  return this.deleteInDirection("backward");
}, deleteContentForward() {
  return this.deleteInDirection("forward");
}, deleteEntireSoftLine() {
  return this.deleteInDirection("forward");
}, deleteHardLineBackward() {
  return this.deleteInDirection("backward");
}, deleteHardLineForward() {
  return this.deleteInDirection("forward");
}, deleteSoftLineBackward() {
  return this.deleteInDirection("backward");
}, deleteSoftLineForward() {
  return this.deleteInDirection("forward");
}, deleteWordBackward() {
  return this.deleteInDirection("backward");
}, deleteWordForward() {
  return this.deleteInDirection("forward");
}, formatBackColor() {
  return this.activateAttributeIfSupported("backgroundColor", this.event.data);
}, formatBold() {
  return this.toggleAttributeIfSupported("bold");
}, formatFontColor() {
  return this.activateAttributeIfSupported("color", this.event.data);
}, formatFontName() {
  return this.activateAttributeIfSupported("font", this.event.data);
}, formatIndent() {
  var t5;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.canIncreaseNestingLevel())
    return this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.increaseNestingLevel();
    });
}, formatItalic() {
  return this.toggleAttributeIfSupported("italic");
}, formatJustifyCenter() {
  return this.toggleAttributeIfSupported("justifyCenter");
}, formatJustifyFull() {
  return this.toggleAttributeIfSupported("justifyFull");
}, formatJustifyLeft() {
  return this.toggleAttributeIfSupported("justifyLeft");
}, formatJustifyRight() {
  return this.toggleAttributeIfSupported("justifyRight");
}, formatOutdent() {
  var t5;
  if ((t5 = this.responder) !== null && t5 !== undefined && t5.canDecreaseNestingLevel())
    return this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.decreaseNestingLevel();
    });
}, formatRemove() {
  this.withTargetDOMRange(function() {
    for (const i4 in (t5 = this.responder) === null || t5 === undefined ? undefined : t5.getCurrentAttributes()) {
      var t5, e4;
      (e4 = this.responder) === null || e4 === undefined || e4.removeCurrentAttribute(i4);
    }
  });
}, formatSetBlockTextDirection() {
  return this.activateAttributeIfSupported("blockDir", this.event.data);
}, formatSetInlineTextDirection() {
  return this.activateAttributeIfSupported("textDir", this.event.data);
}, formatStrikeThrough() {
  return this.toggleAttributeIfSupported("strike");
}, formatSubscript() {
  return this.toggleAttributeIfSupported("sub");
}, formatSuperscript() {
  return this.toggleAttributeIfSupported("sup");
}, formatUnderline() {
  return this.toggleAttributeIfSupported("underline");
}, historyRedo() {
  var t5;
  return (t5 = this.delegate) === null || t5 === undefined ? undefined : t5.inputControllerWillPerformRedo();
}, historyUndo() {
  var t5;
  return (t5 = this.delegate) === null || t5 === undefined ? undefined : t5.inputControllerWillPerformUndo();
}, insertCompositionText() {
  return this.composing = true, this.insertString(this.event.data);
}, insertFromComposition() {
  return this.composing = false, this.insertString(this.event.data);
}, insertFromDrop() {
  const t5 = this.deleteByDragRange;
  var e4;
  if (t5)
    return this.deleteByDragRange = null, (e4 = this.delegate) === null || e4 === undefined || e4.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
      var e5;
      return (e5 = this.responder) === null || e5 === undefined ? undefined : e5.moveTextFromRange(t5);
    });
}, insertFromPaste() {
  const { dataTransfer: t5 } = this.event, e4 = { dataTransfer: t5 }, i4 = t5.getData("URL"), n3 = t5.getData("text/html");
  if (i4) {
    var r4;
    let n4;
    this.event.preventDefault(), e4.type = "text/html";
    const o4 = t5.getData("public.url-name");
    n4 = o4 ? Vt(o4).trim() : i4, e4.html = this.createLinkHTML(i4, n4), (r4 = this.delegate) === null || r4 === undefined || r4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.insertHTML(e4.html);
    }), this.afterRender = () => {
      var t6;
      return (t6 = this.delegate) === null || t6 === undefined ? undefined : t6.inputControllerDidPaste(e4);
    };
  } else if (Et(t5)) {
    var o3;
    e4.type = "text/plain", e4.string = t5.getData("text/plain"), (o3 = this.delegate) === null || o3 === undefined || o3.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.insertString(e4.string);
    }), this.afterRender = () => {
      var t6;
      return (t6 = this.delegate) === null || t6 === undefined ? undefined : t6.inputControllerDidPaste(e4);
    };
  } else if (Cr(this.event)) {
    var s4;
    e4.type = "File", e4.file = t5.files[0], (s4 = this.delegate) === null || s4 === undefined || s4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.insertFile(e4.file);
    }), this.afterRender = () => {
      var t6;
      return (t6 = this.delegate) === null || t6 === undefined ? undefined : t6.inputControllerDidPaste(e4);
    };
  } else if (n3) {
    var a4;
    this.event.preventDefault(), e4.type = "text/html", e4.html = n3, (a4 = this.delegate) === null || a4 === undefined || a4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.insertHTML(e4.html);
    }), this.afterRender = () => {
      var t6;
      return (t6 = this.delegate) === null || t6 === undefined ? undefined : t6.inputControllerDidPaste(e4);
    };
  }
}, insertFromYank() {
  return this.insertString(this.event.data);
}, insertLineBreak() {
  return this.insertString(`
`);
}, insertLink() {
  return this.activateAttributeIfSupported("href", this.event.data);
}, insertOrderedList() {
  return this.toggleAttributeIfSupported("number");
}, insertParagraph() {
  var t5;
  return (t5 = this.delegate) === null || t5 === undefined || t5.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
    var t6;
    return (t6 = this.responder) === null || t6 === undefined ? undefined : t6.insertLineBreak();
  });
}, insertReplacementText() {
  const t5 = this.event.dataTransfer.getData("text/plain"), e4 = this.event.getTargetRanges()[0];
  this.withTargetDOMRange(e4, () => {
    this.insertString(t5, { updatePosition: false });
  });
}, insertText() {
  var t5;
  return this.insertString(this.event.data || ((t5 = this.event.dataTransfer) === null || t5 === undefined ? undefined : t5.getData("text/plain")));
}, insertTranspose() {
  return this.insertString(this.event.data);
}, insertUnorderedList() {
  return this.toggleAttributeIfSupported("bullet");
} });
var yr = function(t5) {
  const e4 = document.createRange();
  return e4.setStart(t5.startContainer, t5.startOffset), e4.setEnd(t5.endContainer, t5.endOffset), e4;
};
var xr = (t5) => {
  var e4;
  return Array.from(((e4 = t5.dataTransfer) === null || e4 === undefined ? undefined : e4.types) || []).includes("Files");
};
var Cr = (t5) => {
  var e4;
  return ((e4 = t5.dataTransfer.files) === null || e4 === undefined ? undefined : e4[0]) && !Er(t5) && !((t6) => {
    let { dataTransfer: e5 } = t6;
    return e5.types.includes("Files") && e5.types.includes("text/html") && e5.getData("text/html").includes("urn:schemas-microsoft-com:office:office");
  })(t5);
};
var Er = function(t5) {
  const e4 = t5.clipboardData;
  if (e4) {
    return Array.from(e4.types).filter((t6) => t6.match(/file/i)).length === e4.types.length && e4.files.length >= 1;
  }
};
var Sr = function(t5) {
  const e4 = t5.clipboardData;
  if (e4)
    return e4.types.includes("text/plain") && e4.types.length === 1;
};
var Rr = function(t5) {
  const e4 = [];
  return t5.altKey && e4.push("alt"), t5.shiftKey && e4.push("shift"), e4.push(t5.key), e4;
};
var kr = (t5) => ({ x: t5.clientX, y: t5.clientY });
var Tr = "[data-trix-attribute]";
var wr = "[data-trix-action]";
var Lr = "".concat(Tr, ", ").concat(wr);
var Dr = "[data-trix-dialog]";
var Nr = "".concat(Dr, "[data-trix-active]");
var Ir = "".concat(Dr, " [data-trix-method]");
var Or = "".concat(Dr, " [data-trix-input]");
var Fr = (t5, e4) => (e4 || (e4 = Mr(t5)), t5.querySelector("[data-trix-input][name='".concat(e4, "']")));
var Pr = (t5) => t5.getAttribute("data-trix-action");
var Mr = (t5) => t5.getAttribute("data-trix-attribute") || t5.getAttribute("data-trix-dialog-attribute");

class Br extends q3 {
  constructor(t5) {
    super(t5), this.didClickActionButton = this.didClickActionButton.bind(this), this.didClickAttributeButton = this.didClickAttributeButton.bind(this), this.didClickDialogButton = this.didClickDialogButton.bind(this), this.didKeyDownDialogInput = this.didKeyDownDialogInput.bind(this), this.element = t5, this.attributes = {}, this.actions = {}, this.resetDialogInputs(), b3("mousedown", { onElement: this.element, matchingSelector: wr, withCallback: this.didClickActionButton }), b3("mousedown", { onElement: this.element, matchingSelector: Tr, withCallback: this.didClickAttributeButton }), b3("click", { onElement: this.element, matchingSelector: Lr, preventDefault: true }), b3("click", { onElement: this.element, matchingSelector: Ir, withCallback: this.didClickDialogButton }), b3("keydown", { onElement: this.element, matchingSelector: Or, withCallback: this.didKeyDownDialogInput });
  }
  didClickActionButton(t5, e4) {
    var i4;
    (i4 = this.delegate) === null || i4 === undefined || i4.toolbarDidClickButton(), t5.preventDefault();
    const n3 = Pr(e4);
    return this.getDialog(n3) ? this.toggleDialog(n3) : (r4 = this.delegate) === null || r4 === undefined ? undefined : r4.toolbarDidInvokeAction(n3, e4);
    var r4;
  }
  didClickAttributeButton(t5, e4) {
    var i4;
    (i4 = this.delegate) === null || i4 === undefined || i4.toolbarDidClickButton(), t5.preventDefault();
    const n3 = Mr(e4);
    var r4;
    this.getDialog(n3) ? this.toggleDialog(n3) : (r4 = this.delegate) === null || r4 === undefined || r4.toolbarDidToggleAttribute(n3);
    return this.refreshAttributeButtons();
  }
  didClickDialogButton(t5, e4) {
    const i4 = y3(e4, { matchingSelector: Dr });
    return this[e4.getAttribute("data-trix-method")].call(this, i4);
  }
  didKeyDownDialogInput(t5, e4) {
    if (t5.keyCode === 13) {
      t5.preventDefault();
      const i4 = e4.getAttribute("name"), n3 = this.getDialog(i4);
      this.setAttribute(n3);
    }
    if (t5.keyCode === 27)
      return t5.preventDefault(), this.hideDialog();
  }
  updateActions(t5) {
    return this.actions = t5, this.refreshActionButtons();
  }
  refreshActionButtons() {
    return this.eachActionButton((t5, e4) => {
      t5.disabled = this.actions[e4] === false;
    });
  }
  eachActionButton(t5) {
    return Array.from(this.element.querySelectorAll(wr)).map((e4) => t5(e4, Pr(e4)));
  }
  updateAttributes(t5) {
    return this.attributes = t5, this.refreshAttributeButtons();
  }
  refreshAttributeButtons() {
    return this.eachAttributeButton((t5, e4) => (t5.disabled = this.attributes[e4] === false, this.attributes[e4] || this.dialogIsVisible(e4) ? (t5.setAttribute("data-trix-active", ""), t5.classList.add("trix-active")) : (t5.removeAttribute("data-trix-active"), t5.classList.remove("trix-active"))));
  }
  eachAttributeButton(t5) {
    return Array.from(this.element.querySelectorAll(Tr)).map((e4) => t5(e4, Mr(e4)));
  }
  applyKeyboardCommand(t5) {
    const e4 = JSON.stringify(t5.sort());
    for (const t6 of Array.from(this.element.querySelectorAll("[data-trix-key]"))) {
      const i4 = t6.getAttribute("data-trix-key").split("+");
      if (JSON.stringify(i4.sort()) === e4)
        return v3("mousedown", { onElement: t6 }), true;
    }
    return false;
  }
  dialogIsVisible(t5) {
    const e4 = this.getDialog(t5);
    if (e4)
      return e4.hasAttribute("data-trix-active");
  }
  toggleDialog(t5) {
    return this.dialogIsVisible(t5) ? this.hideDialog() : this.showDialog(t5);
  }
  showDialog(t5) {
    var e4, i4;
    this.hideDialog(), (e4 = this.delegate) === null || e4 === undefined || e4.toolbarWillShowDialog();
    const n3 = this.getDialog(t5);
    n3.setAttribute("data-trix-active", ""), n3.classList.add("trix-active"), Array.from(n3.querySelectorAll("input[disabled]")).forEach((t6) => {
      t6.removeAttribute("disabled");
    });
    const r4 = Mr(n3);
    if (r4) {
      const e5 = Fr(n3, t5);
      e5 && (e5.value = this.attributes[r4] || "", e5.select());
    }
    return (i4 = this.delegate) === null || i4 === undefined ? undefined : i4.toolbarDidShowDialog(t5);
  }
  setAttribute(t5) {
    var e4;
    const i4 = Mr(t5), n3 = Fr(t5, i4);
    return !n3.willValidate || (n3.setCustomValidity(""), n3.checkValidity() && this.isSafeAttribute(n3)) ? ((e4 = this.delegate) === null || e4 === undefined || e4.toolbarDidUpdateAttribute(i4, n3.value), this.hideDialog()) : (n3.setCustomValidity("Invalid value"), n3.setAttribute("data-trix-validate", ""), n3.classList.add("trix-validate"), n3.focus());
  }
  isSafeAttribute(t5) {
    return !t5.hasAttribute("data-trix-validate-href") || li.isValidAttribute("a", "href", t5.value);
  }
  removeAttribute(t5) {
    var e4;
    const i4 = Mr(t5);
    return (e4 = this.delegate) === null || e4 === undefined || e4.toolbarDidRemoveAttribute(i4), this.hideDialog();
  }
  hideDialog() {
    const t5 = this.element.querySelector(Nr);
    var e4;
    if (t5)
      return t5.removeAttribute("data-trix-active"), t5.classList.remove("trix-active"), this.resetDialogInputs(), (e4 = this.delegate) === null || e4 === undefined ? undefined : e4.toolbarDidHideDialog(((t6) => t6.getAttribute("data-trix-dialog"))(t5));
  }
  resetDialogInputs() {
    Array.from(this.element.querySelectorAll(Or)).forEach((t5) => {
      t5.setAttribute("disabled", "disabled"), t5.removeAttribute("data-trix-validate"), t5.classList.remove("trix-validate");
    });
  }
  getDialog(t5) {
    return this.element.querySelector("[data-trix-dialog=".concat(t5, "]"));
  }
}

class _r extends $n {
  constructor(t5) {
    let { editorElement: e4, document: i4, html: n3 } = t5;
    super(...arguments), this.editorElement = e4, this.selectionManager = new Vn(this.editorElement), this.selectionManager.delegate = this, this.composition = new wn, this.composition.delegate = this, this.attachmentManager = new kn(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = _3.getLevel() === 2 ? new Ar(this.editorElement) : new gr(this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new Xn(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new Br(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new Pn(this.composition, this.selectionManager, this.editorElement), i4 ? this.editor.loadDocument(i4) : this.editor.loadHTML(n3);
  }
  registerSelectionManager() {
    return Ft.registerSelectionManager(this.selectionManager);
  }
  unregisterSelectionManager() {
    return Ft.unregisterSelectionManager(this.selectionManager);
  }
  render() {
    return this.compositionController.render();
  }
  reparse() {
    return this.composition.replaceHTML(this.editorElement.innerHTML);
  }
  compositionDidChangeDocument(t5) {
    if (this.notifyEditorElement("document-change"), !this.handlingInput)
      return this.render();
  }
  compositionDidChangeCurrentAttributes(t5) {
    return this.currentAttributes = t5, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
  }
  compositionDidPerformInsertionAtRange(t5) {
    this.pasting && (this.pastedRange = t5);
  }
  compositionShouldAcceptFile(t5) {
    return this.notifyEditorElement("file-accept", { file: t5 });
  }
  compositionDidAddAttachment(t5) {
    const e4 = this.attachmentManager.manageAttachment(t5);
    return this.notifyEditorElement("attachment-add", { attachment: e4 });
  }
  compositionDidEditAttachment(t5) {
    this.compositionController.rerenderViewForObject(t5);
    const e4 = this.attachmentManager.manageAttachment(t5);
    return this.notifyEditorElement("attachment-edit", { attachment: e4 }), this.notifyEditorElement("change");
  }
  compositionDidChangeAttachmentPreviewURL(t5) {
    return this.compositionController.invalidateViewForObject(t5), this.notifyEditorElement("change");
  }
  compositionDidRemoveAttachment(t5) {
    const e4 = this.attachmentManager.unmanageAttachment(t5);
    return this.notifyEditorElement("attachment-remove", { attachment: e4 });
  }
  compositionDidStartEditingAttachment(t5, e4) {
    return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t5), this.compositionController.installAttachmentEditorForAttachment(t5, e4), this.selectionManager.setLocationRange(this.attachmentLocationRange);
  }
  compositionDidStopEditingAttachment(t5) {
    this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
  }
  compositionDidRequestChangingSelectionToLocationRange(t5) {
    if (!this.loadingSnapshot || this.isFocused())
      return this.requestedLocationRange = t5, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? undefined : this.render();
  }
  compositionWillLoadSnapshot() {
    this.loadingSnapshot = true;
  }
  compositionDidLoadSnapshot() {
    this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
  }
  getSelectionManager() {
    return this.selectionManager;
  }
  attachmentManagerDidRequestRemovalOfAttachment(t5) {
    return this.removeAttachment(t5);
  }
  compositionControllerWillSyncDocumentView() {
    return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
  }
  compositionControllerDidSyncDocumentView() {
    return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
  }
  compositionControllerDidRender() {
    this.requestedLocationRange && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
  }
  compositionControllerDidFocus() {
    return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
  }
  compositionControllerDidBlur() {
    return this.notifyEditorElement("blur");
  }
  compositionControllerDidSelectAttachment(t5, e4) {
    return this.toolbarController.hideDialog(), this.composition.editAttachment(t5, e4);
  }
  compositionControllerDidRequestDeselectingAttachment(t5) {
    const e4 = this.attachmentLocationRange || this.composition.document.getLocationRangeOfAttachment(t5);
    return this.selectionManager.setLocationRange(e4[1]);
  }
  compositionControllerWillUpdateAttachment(t5) {
    return this.editor.recordUndoEntry("Edit Attachment", { context: t5.id, consolidatable: true });
  }
  compositionControllerDidRequestRemovalOfAttachment(t5) {
    return this.removeAttachment(t5);
  }
  inputControllerWillHandleInput() {
    this.handlingInput = true, this.requestedRender = false;
  }
  inputControllerDidRequestRender() {
    this.requestedRender = true;
  }
  inputControllerDidHandleInput() {
    if (this.handlingInput = false, this.requestedRender)
      return this.requestedRender = false, this.render();
  }
  inputControllerDidAllowUnhandledInput() {
    return this.notifyEditorElement("change");
  }
  inputControllerDidRequestReparse() {
    return this.reparse();
  }
  inputControllerWillPerformTyping() {
    return this.recordTypingUndoEntry();
  }
  inputControllerWillPerformFormatting(t5) {
    return this.recordFormattingUndoEntry(t5);
  }
  inputControllerWillCutText() {
    return this.editor.recordUndoEntry("Cut");
  }
  inputControllerWillPaste(t5) {
    return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t5 });
  }
  inputControllerDidPaste(t5) {
    return t5.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t5 });
  }
  inputControllerWillMoveText() {
    return this.editor.recordUndoEntry("Move");
  }
  inputControllerWillAttachFiles() {
    return this.editor.recordUndoEntry("Drop Files");
  }
  inputControllerWillPerformUndo() {
    return this.editor.undo();
  }
  inputControllerWillPerformRedo() {
    return this.editor.redo();
  }
  inputControllerDidReceiveKeyboardCommand(t5) {
    return this.toolbarController.applyKeyboardCommand(t5);
  }
  inputControllerDidStartDrag() {
    this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
  }
  inputControllerDidReceiveDragOverPoint(t5) {
    return this.selectionManager.setLocationRangeFromPointRange(t5);
  }
  inputControllerDidCancelDrag() {
    this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
  }
  locationRangeDidChange(t5) {
    return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !Dt(this.attachmentLocationRange, t5) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
  }
  toolbarDidClickButton() {
    if (!this.getLocationRange())
      return this.setLocationRange({ index: 0, offset: 0 });
  }
  toolbarDidInvokeAction(t5, e4) {
    return this.invokeAction(t5, e4);
  }
  toolbarDidToggleAttribute(t5) {
    if (this.recordFormattingUndoEntry(t5), this.composition.toggleCurrentAttribute(t5), this.render(), !this.selectionFrozen)
      return this.editorElement.focus();
  }
  toolbarDidUpdateAttribute(t5, e4) {
    if (this.recordFormattingUndoEntry(t5), this.composition.setCurrentAttribute(t5, e4), this.render(), !this.selectionFrozen)
      return this.editorElement.focus();
  }
  toolbarDidRemoveAttribute(t5) {
    if (this.recordFormattingUndoEntry(t5), this.composition.removeCurrentAttribute(t5), this.render(), !this.selectionFrozen)
      return this.editorElement.focus();
  }
  toolbarWillShowDialog(t5) {
    return this.composition.expandSelectionForEditing(), this.freezeSelection();
  }
  toolbarDidShowDialog(t5) {
    return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t5 });
  }
  toolbarDidHideDialog(t5) {
    return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t5 });
  }
  freezeSelection() {
    if (!this.selectionFrozen)
      return this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render();
  }
  thawSelection() {
    if (this.selectionFrozen)
      return this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render();
  }
  canInvokeAction(t5) {
    return !!this.actionIsExternal(t5) || !((e4 = this.actions[t5]) === null || e4 === undefined || (e4 = e4.test) === null || e4 === undefined || !e4.call(this));
    var e4;
  }
  invokeAction(t5, e4) {
    return this.actionIsExternal(t5) ? this.notifyEditorElement("action-invoke", { actionName: t5, invokingElement: e4 }) : (i4 = this.actions[t5]) === null || i4 === undefined || (i4 = i4.perform) === null || i4 === undefined ? undefined : i4.call(this);
    var i4;
  }
  actionIsExternal(t5) {
    return /^x-./.test(t5);
  }
  getCurrentActions() {
    const t5 = {};
    for (const e4 in this.actions)
      t5[e4] = this.canInvokeAction(e4);
    return t5;
  }
  updateCurrentActions() {
    const t5 = this.getCurrentActions();
    if (!Tt(t5, this.currentActions))
      return this.currentActions = t5, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions });
  }
  runEditorFilters() {
    let t5 = this.composition.getSnapshot();
    if (Array.from(this.editor.filters).forEach((e5) => {
      const { document: i5, selectedRange: n3 } = t5;
      t5 = e5.call(this.editor, t5) || {}, t5.document || (t5.document = i5), t5.selectedRange || (t5.selectedRange = n3);
    }), e4 = t5, i4 = this.composition.getSnapshot(), !Dt(e4.selectedRange, i4.selectedRange) || !e4.document.isEqualTo(i4.document))
      return this.composition.loadSnapshot(t5);
    var e4, i4;
  }
  updateInputElement() {
    const t5 = function(t6, e4) {
      const i4 = En[e4];
      if (i4)
        return i4(t6);
      throw new Error("unknown content type: ".concat(e4));
    }(this.compositionController.getSerializableElement(), "text/html");
    return this.editorElement.setFormValue(t5);
  }
  notifyEditorElement(t5, e4) {
    switch (t5) {
      case "document-change":
        this.documentChangedSinceLastRender = true;
        break;
      case "render":
        this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
        break;
      case "change":
      case "attachment-add":
      case "attachment-edit":
      case "attachment-remove":
        this.updateInputElement();
    }
    return this.editorElement.notify(t5, e4);
  }
  removeAttachment(t5) {
    return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t5), this.render();
  }
  recordFormattingUndoEntry(t5) {
    const e4 = mt(t5), i4 = this.selectionManager.getLocationRange();
    if (e4 || !Lt(i4))
      return this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true });
  }
  recordTypingUndoEntry() {
    return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
  }
  getUndoContext() {
    for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0;i4 < t5; i4++)
      e4[i4] = arguments[i4];
    return [this.getLocationContext(), this.getTimeContext(), ...Array.from(e4)];
  }
  getLocationContext() {
    const t5 = this.selectionManager.getLocationRange();
    return Lt(t5) ? t5[0].index : t5;
  }
  getTimeContext() {
    return V3.interval > 0 ? Math.floor(new Date().getTime() / V3.interval) : 0;
  }
  isFocused() {
    var t5;
    return this.editorElement === ((t5 = this.editorElement.ownerDocument) === null || t5 === undefined ? undefined : t5.activeElement);
  }
  isFocusedInvisibly() {
    return this.isFocused() && !this.getLocationRange();
  }
  get actions() {
    return this.constructor.actions;
  }
}
Di(_r, "actions", { undo: { test() {
  return this.editor.canUndo();
}, perform() {
  return this.editor.undo();
} }, redo: { test() {
  return this.editor.canRedo();
}, perform() {
  return this.editor.redo();
} }, link: { test() {
  return this.editor.canActivateAttribute("href");
} }, increaseNestingLevel: { test() {
  return this.editor.canIncreaseNestingLevel();
}, perform() {
  return this.editor.increaseNestingLevel() && this.render();
} }, decreaseNestingLevel: { test() {
  return this.editor.canDecreaseNestingLevel();
}, perform() {
  return this.editor.decreaseNestingLevel() && this.render();
} }, attachFiles: { test: () => true, perform() {
  return _3.pickFiles(this.editor.insertFiles);
} } }), _r.proxyMethod("getSelectionManager().setLocationRange"), _r.proxyMethod("getSelectionManager().getLocationRange");
var jr = Object.freeze({ __proto__: null, AttachmentEditorController: Yn, CompositionController: Xn, Controller: $n, EditorController: _r, InputController: lr, Level0InputController: gr, Level2InputController: Ar, ToolbarController: Br });
var Wr = Object.freeze({ __proto__: null, MutationObserver: er, SelectionChangeObserver: Ot });
var Ur = Object.freeze({ __proto__: null, FileVerificationOperation: nr, ImagePreloadOperation: Ui });
vt("trix-toolbar", `%t {
  display: block;
}

%t {
  white-space: nowrap;
}

%t [data-trix-dialog] {
  display: none;
}

%t [data-trix-dialog][data-trix-active] {
  display: block;
}

%t [data-trix-dialog] [data-trix-validate]:invalid {
  background-color: #ffdddd;
}`);

class Vr extends HTMLElement {
  connectedCallback() {
    this.innerHTML === "" && (this.innerHTML = U2.getDefaultHTML());
  }
}
var zr = 0;
var qr = function(t5) {
  if (!t5.hasAttribute("contenteditable"))
    return t5.setAttribute("contenteditable", ""), function(t6) {
      let e4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return e4.times = 1, b3(t6, e4);
    }("focus", { onElement: t5, withCallback: () => Hr(t5) });
};
var Hr = function(t5) {
  return Jr(t5), Kr(t5);
};
var Jr = function(t5) {
  var e4, i4;
  if ((e4 = (i4 = document).queryCommandSupported) !== null && e4 !== undefined && e4.call(i4, "enableObjectResizing"))
    return document.execCommand("enableObjectResizing", false, false), b3("mscontrolselect", { onElement: t5, preventDefault: true });
};
var Kr = function(t5) {
  var e4, i4;
  if ((e4 = (i4 = document).queryCommandSupported) !== null && e4 !== undefined && e4.call(i4, "DefaultParagraphSeparator")) {
    const { tagName: t6 } = n2.default;
    if (["div", "p"].includes(t6))
      return document.execCommand("DefaultParagraphSeparator", false, t6);
  }
};
var Gr = a3.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
vt("trix-editor", `%t {
    display: block;
}

%t:empty::before {
    content: attr(placeholder);
    color: graytext;
    cursor: text;
    pointer-events: none;
    white-space: pre-line;
}

%t a[contenteditable=false] {
    cursor: text;
}

%t img {
    max-width: 100%;
    height: auto;
}

%t `.concat(e3, ` figcaption textarea {
    resize: none;
}

%t `).concat(e3, ` figcaption textarea.trix-autoresize-clone {
    position: absolute;
    left: -9999px;
    max-height: 0px;
}

%t `).concat(e3, ` figcaption[data-trix-placeholder]:empty::before {
    content: attr(data-trix-placeholder);
    color: graytext;
}

%t [data-trix-cursor-target] {
    display: `).concat(Gr.display, ` !important;
    width: `).concat(Gr.width, ` !important;
    padding: 0 !important;
    margin: 0 !important;
    border: none !important;
}

%t [data-trix-cursor-target=left] {
    vertical-align: top !important;
    margin-left: -1px !important;
}

%t [data-trix-cursor-target=right] {
    vertical-align: bottom !important;
    margin-right: -1px !important;
}`));
var Yr = new WeakMap;
var Xr = new WeakSet;

class $r {
  constructor(t5) {
    var e4, i4;
    _i(e4 = this, i4 = Xr), i4.add(e4), ji(this, Yr, { writable: true, value: undefined }), this.element = t5, Oi(this, Yr, t5.attachInternals());
  }
  connectedCallback() {
    Bi(this, Xr, Zr).call(this);
  }
  disconnectedCallback() {}
  get labels() {
    return Ii(this, Yr).labels;
  }
  get disabled() {
    var t5;
    return (t5 = this.element.inputElement) === null || t5 === undefined ? undefined : t5.disabled;
  }
  set disabled(t5) {
    this.element.toggleAttribute("disabled", t5);
  }
  get required() {
    return this.element.hasAttribute("required");
  }
  set required(t5) {
    this.element.toggleAttribute("required", t5), Bi(this, Xr, Zr).call(this);
  }
  get validity() {
    return Ii(this, Yr).validity;
  }
  get validationMessage() {
    return Ii(this, Yr).validationMessage;
  }
  get willValidate() {
    return Ii(this, Yr).willValidate;
  }
  setFormValue(t5) {
    Bi(this, Xr, Zr).call(this);
  }
  checkValidity() {
    return Ii(this, Yr).checkValidity();
  }
  reportValidity() {
    return Ii(this, Yr).reportValidity();
  }
  setCustomValidity(t5) {
    Bi(this, Xr, Zr).call(this, t5);
  }
}
function Zr() {
  let t5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  const { required: e4, value: i4 } = this.element, n3 = e4 && !i4, r4 = !!t5, o3 = T4("input", { required: e4 }), s4 = t5 || o3.validationMessage;
  Ii(this, Yr).setValidity({ valueMissing: n3, customError: r4 }, s4);
}
var Qr = new WeakMap;
var to2 = new WeakMap;
var eo = new WeakMap;

class io {
  constructor(t5) {
    ji(this, Qr, { writable: true, value: undefined }), ji(this, to2, { writable: true, value: (t6) => {
      t6.defaultPrevented || t6.target === this.element.form && this.element.reset();
    } }), ji(this, eo, { writable: true, value: (t6) => {
      if (t6.defaultPrevented)
        return;
      if (this.element.contains(t6.target))
        return;
      const e4 = y3(t6.target, { matchingSelector: "label" });
      e4 && Array.from(this.labels).includes(e4) && this.element.focus();
    } }), this.element = t5;
  }
  connectedCallback() {
    Oi(this, Qr, function(t5) {
      if (t5.hasAttribute("aria-label") || t5.hasAttribute("aria-labelledby"))
        return;
      const e4 = function() {
        const e5 = Array.from(t5.labels).map((e6) => {
          if (!e6.contains(t5))
            return e6.textContent;
        }).filter((t6) => t6), i4 = e5.join(" ");
        return i4 ? t5.setAttribute("aria-label", i4) : t5.removeAttribute("aria-label");
      };
      return e4(), b3("focus", { onElement: t5, withCallback: e4 });
    }(this.element)), window.addEventListener("reset", Ii(this, to2), false), window.addEventListener("click", Ii(this, eo), false);
  }
  disconnectedCallback() {
    var t5;
    (t5 = Ii(this, Qr)) === null || t5 === undefined || t5.destroy(), window.removeEventListener("reset", Ii(this, to2), false), window.removeEventListener("click", Ii(this, eo), false);
  }
  get labels() {
    const t5 = [];
    this.element.id && this.element.ownerDocument && t5.push(...Array.from(this.element.ownerDocument.querySelectorAll("label[for='".concat(this.element.id, "']")) || []));
    const e4 = y3(this.element, { matchingSelector: "label" });
    return e4 && [this.element, null].includes(e4.control) && t5.push(e4), t5;
  }
  get disabled() {
    return console.warn("This browser does not support the [disabled] attribute for trix-editor elements."), false;
  }
  set disabled(t5) {
    console.warn("This browser does not support the [disabled] attribute for trix-editor elements.");
  }
  get required() {
    return console.warn("This browser does not support the [required] attribute for trix-editor elements."), false;
  }
  set required(t5) {
    console.warn("This browser does not support the [required] attribute for trix-editor elements.");
  }
  get validity() {
    return console.warn("This browser does not support the validity property for trix-editor elements."), null;
  }
  get validationMessage() {
    return console.warn("This browser does not support the validationMessage property for trix-editor elements."), "";
  }
  get willValidate() {
    return console.warn("This browser does not support the willValidate property for trix-editor elements."), false;
  }
  setFormValue(t5) {}
  checkValidity() {
    return console.warn("This browser does not support checkValidity() for trix-editor elements."), true;
  }
  reportValidity() {
    return console.warn("This browser does not support reportValidity() for trix-editor elements."), true;
  }
  setCustomValidity(t5) {
    console.warn("This browser does not support setCustomValidity(validationMessage) for trix-editor elements.");
  }
}
var no = new WeakMap;

class ro extends HTMLElement {
  constructor() {
    super(), ji(this, no, { writable: true, value: undefined }), Oi(this, no, this.constructor.formAssociated ? new $r(this) : new io(this));
  }
  get trixId() {
    return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++zr), this.trixId);
  }
  get labels() {
    return Ii(this, no).labels;
  }
  get disabled() {
    return Ii(this, no).disabled;
  }
  set disabled(t5) {
    Ii(this, no).disabled = t5;
  }
  get required() {
    return Ii(this, no).required;
  }
  set required(t5) {
    Ii(this, no).required = t5;
  }
  get validity() {
    return Ii(this, no).validity;
  }
  get validationMessage() {
    return Ii(this, no).validationMessage;
  }
  get willValidate() {
    return Ii(this, no).willValidate;
  }
  get type() {
    return this.localName;
  }
  get toolbarElement() {
    var t5;
    if (this.hasAttribute("toolbar"))
      return (t5 = this.ownerDocument) === null || t5 === undefined ? undefined : t5.getElementById(this.getAttribute("toolbar"));
    if (this.parentNode) {
      const t6 = "trix-toolbar-".concat(this.trixId);
      return this.setAttribute("toolbar", t6), this.internalToolbar = T4("trix-toolbar", { id: t6 }), this.parentNode.insertBefore(this.internalToolbar, this), this.internalToolbar;
    }
  }
  get form() {
    var t5;
    return (t5 = this.inputElement) === null || t5 === undefined ? undefined : t5.form;
  }
  get inputElement() {
    var t5;
    if (this.hasAttribute("input"))
      return (t5 = this.ownerDocument) === null || t5 === undefined ? undefined : t5.getElementById(this.getAttribute("input"));
    if (this.parentNode) {
      const t6 = "trix-input-".concat(this.trixId);
      this.setAttribute("input", t6);
      const e4 = T4("input", { type: "hidden", id: t6 });
      return this.parentNode.insertBefore(e4, this.nextElementSibling), e4;
    }
  }
  get editor() {
    var t5;
    return (t5 = this.editorController) === null || t5 === undefined ? undefined : t5.editor;
  }
  get name() {
    var t5;
    return (t5 = this.inputElement) === null || t5 === undefined ? undefined : t5.name;
  }
  get value() {
    var t5;
    return (t5 = this.inputElement) === null || t5 === undefined ? undefined : t5.value;
  }
  set value(t5) {
    var e4;
    this.defaultValue = t5, (e4 = this.editor) === null || e4 === undefined || e4.loadHTML(this.defaultValue);
  }
  attributeChangedCallback(t5, e4, i4) {
    t5 === "connected" && this.isConnected && e4 != null && e4 !== i4 && requestAnimationFrame(() => this.reconnect());
  }
  notify(t5, e4) {
    if (this.editorController)
      return v3("trix-".concat(t5), { onElement: this, attributes: e4 });
  }
  setFormValue(t5) {
    this.inputElement && (this.inputElement.value = t5, Ii(this, no).setFormValue(t5));
  }
  connectedCallback() {
    this.hasAttribute("data-trix-internal") || (qr(this), function(t5) {
      if (!t5.hasAttribute("role"))
        t5.setAttribute("role", "textbox");
    }(this), this.editorController || (v3("trix-before-initialize", { onElement: this }), this.editorController = new _r({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(() => v3("trix-initialize", { onElement: this }))), this.editorController.registerSelectionManager(), Ii(this, no).connectedCallback(), this.toggleAttribute("connected", true), function(t5) {
      if (!document.querySelector(":focus") && t5.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t5)
        t5.focus();
    }(this));
  }
  disconnectedCallback() {
    var t5;
    (t5 = this.editorController) === null || t5 === undefined || t5.unregisterSelectionManager(), Ii(this, no).disconnectedCallback(), this.toggleAttribute("connected", false);
  }
  reconnect() {
    this.removeInternalToolbar(), this.disconnectedCallback(), this.connectedCallback();
  }
  removeInternalToolbar() {
    var t5;
    (t5 = this.internalToolbar) === null || t5 === undefined || t5.remove(), this.internalToolbar = null;
  }
  checkValidity() {
    return Ii(this, no).checkValidity();
  }
  reportValidity() {
    return Ii(this, no).reportValidity();
  }
  setCustomValidity(t5) {
    Ii(this, no).setCustomValidity(t5);
  }
  formDisabledCallback(t5) {
    this.inputElement && (this.inputElement.disabled = t5), this.toggleAttribute("contenteditable", !t5);
  }
  formResetCallback() {
    this.reset();
  }
  reset() {
    this.value = this.defaultValue;
  }
}
Di(ro, "formAssociated", "ElementInternals" in window), Di(ro, "observedAttributes", ["connected"]);
var oo = { VERSION: t3, config: z3, core: Sn, models: zn, views: qn, controllers: jr, observers: Wr, operations: Ur, elements: Object.freeze({ __proto__: null, TrixEditorElement: ro, TrixToolbarElement: Vr }), filters: Object.freeze({ __proto__: null, Filter: In, attachmentGalleryFilter: On }) };
Object.assign(oo, zn), window.Trix = oo, setTimeout(function() {
  customElements.get("trix-toolbar") || customElements.define("trix-toolbar", Vr), customElements.get("trix-editor") || customElements.define("trix-editor", ro);
}, 0);

// node_modules/@rails/actiontext/app/assets/javascripts/actiontext.esm.js
var sparkMd52 = {
  exports: {}
};
(function(module, exports) {
  (function(factory) {
    {
      module.exports = factory();
    }
  })(function(undefined$1) {
    var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function md5cycle(x5, k4) {
      var a4 = x5[0], b4 = x5[1], c4 = x5[2], d3 = x5[3];
      a4 += (b4 & c4 | ~b4 & d3) + k4[0] - 680876936 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[1] - 389564586 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[2] + 606105819 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[3] - 1044525330 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & c4 | ~b4 & d3) + k4[4] - 176418897 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[5] + 1200080426 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[6] - 1473231341 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[7] - 45705983 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & c4 | ~b4 & d3) + k4[8] + 1770035416 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[9] - 1958414417 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[10] - 42063 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[11] - 1990404162 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & c4 | ~b4 & d3) + k4[12] + 1804603682 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[13] - 40341101 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[14] - 1502002290 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[15] + 1236535329 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[1] - 165796510 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[6] - 1069501632 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[11] + 643717713 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[0] - 373897302 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[5] - 701558691 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[10] + 38016083 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[15] - 660478335 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[4] - 405537848 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[9] + 568446438 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[14] - 1019803690 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[3] - 187363961 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[8] + 1163531501 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[13] - 1444681467 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[2] - 51403784 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[7] + 1735328473 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[12] - 1926607734 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[5] - 378558 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[8] - 2022574463 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[11] + 1839030562 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[14] - 35309556 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[1] - 1530992060 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[4] + 1272893353 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[7] - 155497632 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[10] - 1094730640 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[13] + 681279174 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[0] - 358537222 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[3] - 722521979 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[6] + 76029189 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[9] - 640364487 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[12] - 421815835 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[15] + 530742520 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[2] - 995338651 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[0] - 198630844 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[7] + 1126891415 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[14] - 1416354905 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[5] - 57434055 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[12] + 1700485571 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[3] - 1894986606 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[10] - 1051523 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[1] - 2054922799 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[8] + 1873313359 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[15] - 30611744 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[6] - 1560198380 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[13] + 1309151649 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[4] - 145523070 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[11] - 1120210379 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[2] + 718787259 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[9] - 343485551 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      x5[0] = a4 + x5[0] | 0;
      x5[1] = b4 + x5[1] | 0;
      x5[2] = c4 + x5[2] | 0;
      x5[3] = d3 + x5[3] | 0;
    }
    function md5blk(s4) {
      var md5blks = [], i4;
      for (i4 = 0;i4 < 64; i4 += 4) {
        md5blks[i4 >> 2] = s4.charCodeAt(i4) + (s4.charCodeAt(i4 + 1) << 8) + (s4.charCodeAt(i4 + 2) << 16) + (s4.charCodeAt(i4 + 3) << 24);
      }
      return md5blks;
    }
    function md5blk_array(a4) {
      var md5blks = [], i4;
      for (i4 = 0;i4 < 64; i4 += 4) {
        md5blks[i4 >> 2] = a4[i4] + (a4[i4 + 1] << 8) + (a4[i4 + 2] << 16) + (a4[i4 + 3] << 24);
      }
      return md5blks;
    }
    function md51(s4) {
      var n3 = s4.length, state = [1732584193, -271733879, -1732584194, 271733878], i4, length, tail, tmp, lo, hi2;
      for (i4 = 64;i4 <= n3; i4 += 64) {
        md5cycle(state, md5blk(s4.substring(i4 - 64, i4)));
      }
      s4 = s4.substring(i4 - 64);
      length = s4.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i4 = 0;i4 < length; i4 += 1) {
        tail[i4 >> 2] |= s4.charCodeAt(i4) << (i4 % 4 << 3);
      }
      tail[i4 >> 2] |= 128 << (i4 % 4 << 3);
      if (i4 > 55) {
        md5cycle(state, tail);
        for (i4 = 0;i4 < 16; i4 += 1) {
          tail[i4] = 0;
        }
      }
      tmp = n3 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi2 = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi2;
      md5cycle(state, tail);
      return state;
    }
    function md51_array(a4) {
      var n3 = a4.length, state = [1732584193, -271733879, -1732584194, 271733878], i4, length, tail, tmp, lo, hi2;
      for (i4 = 64;i4 <= n3; i4 += 64) {
        md5cycle(state, md5blk_array(a4.subarray(i4 - 64, i4)));
      }
      a4 = i4 - 64 < n3 ? a4.subarray(i4 - 64) : new Uint8Array(0);
      length = a4.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i4 = 0;i4 < length; i4 += 1) {
        tail[i4 >> 2] |= a4[i4] << (i4 % 4 << 3);
      }
      tail[i4 >> 2] |= 128 << (i4 % 4 << 3);
      if (i4 > 55) {
        md5cycle(state, tail);
        for (i4 = 0;i4 < 16; i4 += 1) {
          tail[i4] = 0;
        }
      }
      tmp = n3 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi2 = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi2;
      md5cycle(state, tail);
      return state;
    }
    function rhex(n3) {
      var s4 = "", j5;
      for (j5 = 0;j5 < 4; j5 += 1) {
        s4 += hex_chr[n3 >> j5 * 8 + 4 & 15] + hex_chr[n3 >> j5 * 8 & 15];
      }
      return s4;
    }
    function hex(x5) {
      var i4;
      for (i4 = 0;i4 < x5.length; i4 += 1) {
        x5[i4] = rhex(x5[i4]);
      }
      return x5.join("");
    }
    if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592")
      ;
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
      (function() {
        function clamp(val, length) {
          val = val | 0 || 0;
          if (val < 0) {
            return Math.max(val + length, 0);
          }
          return Math.min(val, length);
        }
        ArrayBuffer.prototype.slice = function(from2, to3) {
          var length = this.byteLength, begin = clamp(from2, length), end = length, num, target, targetArray, sourceArray;
          if (to3 !== undefined$1) {
            end = clamp(to3, length);
          }
          if (begin > end) {
            return new ArrayBuffer(0);
          }
          num = end - begin;
          target = new ArrayBuffer(num);
          targetArray = new Uint8Array(target);
          sourceArray = new Uint8Array(this, begin, num);
          targetArray.set(sourceArray);
          return target;
        };
      })();
    }
    function toUtf8(str) {
      if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str));
      }
      return str;
    }
    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
      var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i4;
      for (i4 = 0;i4 < length; i4 += 1) {
        arr[i4] = str.charCodeAt(i4);
      }
      return returnUInt8Array ? arr : buff;
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff));
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result = new Uint8Array(first.byteLength + second.byteLength);
      result.set(new Uint8Array(first));
      result.set(new Uint8Array(second), first.byteLength);
      return returnUInt8Array ? result : result.buffer;
    }
    function hexToBinaryString(hex2) {
      var bytes = [], length = hex2.length, x5;
      for (x5 = 0;x5 < length - 1; x5 += 2) {
        bytes.push(parseInt(hex2.substr(x5, 2), 16));
      }
      return String.fromCharCode.apply(String, bytes);
    }
    function SparkMD52() {
      this.reset();
    }
    SparkMD52.prototype.append = function(str) {
      this.appendBinary(toUtf8(str));
      return this;
    };
    SparkMD52.prototype.appendBinary = function(contents) {
      this._buff += contents;
      this._length += contents.length;
      var length = this._buff.length, i4;
      for (i4 = 64;i4 <= length; i4 += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i4 - 64, i4)));
      }
      this._buff = this._buff.substring(i4 - 64);
      return this;
    };
    SparkMD52.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, i4, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
      for (i4 = 0;i4 < length; i4 += 1) {
        tail[i4 >> 2] |= buff.charCodeAt(i4) << (i4 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.prototype.reset = function() {
      this._buff = "";
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    };
    SparkMD52.prototype.setState = function(state) {
      this._buff = state.buff;
      this._length = state.length;
      this._hash = state.hash;
      return this;
    };
    SparkMD52.prototype.destroy = function() {
      delete this._hash;
      delete this._buff;
      delete this._length;
    };
    SparkMD52.prototype._finish = function(tail, length) {
      var i4 = length, tmp, lo, hi2;
      tail[i4 >> 2] |= 128 << (i4 % 4 << 3);
      if (i4 > 55) {
        md5cycle(this._hash, tail);
        for (i4 = 0;i4 < 16; i4 += 1) {
          tail[i4] = 0;
        }
      }
      tmp = this._length * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi2 = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi2;
      md5cycle(this._hash, tail);
    };
    SparkMD52.hash = function(str, raw) {
      return SparkMD52.hashBinary(toUtf8(str), raw);
    };
    SparkMD52.hashBinary = function(content, raw) {
      var hash = md51(content), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    SparkMD52.ArrayBuffer = function() {
      this.reset();
    };
    SparkMD52.ArrayBuffer.prototype.append = function(arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i4;
      this._length += arr.byteLength;
      for (i4 = 64;i4 <= length; i4 += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i4 - 64, i4)));
      }
      this._buff = i4 - 64 < length ? new Uint8Array(buff.buffer.slice(i4 - 64)) : new Uint8Array(0);
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i4, ret;
      for (i4 = 0;i4 < length; i4 += 1) {
        tail[i4 >> 2] |= buff[i4] << (i4 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.ArrayBuffer.prototype.reset = function() {
      this._buff = new Uint8Array(0);
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.getState = function() {
      var state = SparkMD52.prototype.getState.call(this);
      state.buff = arrayBuffer2Utf8Str(state.buff);
      return state;
    };
    SparkMD52.ArrayBuffer.prototype.setState = function(state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true);
      return SparkMD52.prototype.setState.call(this, state);
    };
    SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
    SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
    SparkMD52.ArrayBuffer.hash = function(arr, raw) {
      var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    return SparkMD52;
  });
})(sparkMd52);
var SparkMD52 = sparkMd52.exports;
var fileSlice2 = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;

class FileChecksum2 {
  static create(file, callback) {
    const instance = new FileChecksum2(file);
    instance.create(callback);
  }
  constructor(file) {
    this.file = file;
    this.chunkSize = 2097152;
    this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
    this.chunkIndex = 0;
  }
  create(callback) {
    this.callback = callback;
    this.md5Buffer = new SparkMD52.ArrayBuffer;
    this.fileReader = new FileReader;
    this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
    this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
    this.readNextChunk();
  }
  fileReaderDidLoad(event) {
    this.md5Buffer.append(event.target.result);
    if (!this.readNextChunk()) {
      const binaryDigest = this.md5Buffer.end(true);
      const base64digest = btoa(binaryDigest);
      this.callback(null, base64digest);
    }
  }
  fileReaderDidError(event) {
    this.callback(`Error reading ${this.file.name}`);
  }
  readNextChunk() {
    if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
      const start3 = this.chunkIndex * this.chunkSize;
      const end = Math.min(start3 + this.chunkSize, this.file.size);
      const bytes = fileSlice2.call(this.file, start3, end);
      this.fileReader.readAsArrayBuffer(bytes);
      this.chunkIndex++;
      return true;
    } else {
      return false;
    }
  }
}
function getMetaValue2(name) {
  const element = findElement2(document.head, `meta[name="${name}"]`);
  if (element) {
    return element.getAttribute("content");
  }
}
function findElements3(root, selector) {
  if (typeof root == "string") {
    selector = root;
    root = document;
  }
  const elements = root.querySelectorAll(selector);
  return toArray3(elements);
}
function findElement2(root, selector) {
  if (typeof root == "string") {
    selector = root;
    root = document;
  }
  return root.querySelector(selector);
}
function dispatchEvent3(element, type, eventInit = {}) {
  const { disabled } = element;
  const { bubbles, cancelable, detail } = eventInit;
  const event = document.createEvent("Event");
  event.initEvent(type, bubbles || true, cancelable || true);
  event.detail = detail || {};
  try {
    element.disabled = false;
    element.dispatchEvent(event);
  } finally {
    element.disabled = disabled;
  }
  return event;
}
function toArray3(value) {
  if (Array.isArray(value)) {
    return value;
  } else if (Array.from) {
    return Array.from(value);
  } else {
    return [].slice.call(value);
  }
}

class BlobRecord2 {
  constructor(file, checksum, url, customHeaders = {}) {
    this.file = file;
    this.attributes = {
      filename: file.name,
      content_type: file.type || "application/octet-stream",
      byte_size: file.size,
      checksum
    };
    this.xhr = new XMLHttpRequest;
    this.xhr.open("POST", url, true);
    this.xhr.responseType = "json";
    this.xhr.setRequestHeader("Content-Type", "application/json");
    this.xhr.setRequestHeader("Accept", "application/json");
    this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    Object.keys(customHeaders).forEach((headerKey) => {
      this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
    });
    const csrfToken = getMetaValue2("csrf-token");
    if (csrfToken != null) {
      this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
    }
    this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
    this.xhr.addEventListener("error", (event) => this.requestDidError(event));
  }
  get status() {
    return this.xhr.status;
  }
  get response() {
    const { responseType, response } = this.xhr;
    if (responseType == "json") {
      return response;
    } else {
      return JSON.parse(response);
    }
  }
  create(callback) {
    this.callback = callback;
    this.xhr.send(JSON.stringify({
      blob: this.attributes
    }));
  }
  requestDidLoad(event) {
    if (this.status >= 200 && this.status < 300) {
      const { response } = this;
      const { direct_upload } = response;
      delete response.direct_upload;
      this.attributes = response;
      this.directUploadData = direct_upload;
      this.callback(null, this.toJSON());
    } else {
      this.requestDidError(event);
    }
  }
  requestDidError(event) {
    this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
  }
  toJSON() {
    const result = {};
    for (const key in this.attributes) {
      result[key] = this.attributes[key];
    }
    return result;
  }
}

class BlobUpload2 {
  constructor(blob) {
    this.blob = blob;
    this.file = blob.file;
    const { url, headers } = blob.directUploadData;
    this.xhr = new XMLHttpRequest;
    this.xhr.open("PUT", url, true);
    this.xhr.responseType = "text";
    for (const key in headers) {
      this.xhr.setRequestHeader(key, headers[key]);
    }
    this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
    this.xhr.addEventListener("error", (event) => this.requestDidError(event));
  }
  create(callback) {
    this.callback = callback;
    this.xhr.send(this.file.slice());
  }
  requestDidLoad(event) {
    const { status, response } = this.xhr;
    if (status >= 200 && status < 300) {
      this.callback(null, response);
    } else {
      this.requestDidError(event);
    }
  }
  requestDidError(event) {
    this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
  }
}
var id2 = 0;

class DirectUpload2 {
  constructor(file, url, delegate, customHeaders = {}) {
    this.id = ++id2;
    this.file = file;
    this.url = url;
    this.delegate = delegate;
    this.customHeaders = customHeaders;
  }
  create(callback) {
    FileChecksum2.create(this.file, (error2, checksum) => {
      if (error2) {
        callback(error2);
        return;
      }
      const blob = new BlobRecord2(this.file, checksum, this.url, this.customHeaders);
      notify2(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
      blob.create((error3) => {
        if (error3) {
          callback(error3);
        } else {
          const upload = new BlobUpload2(blob);
          notify2(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
          upload.create((error4) => {
            if (error4) {
              callback(error4);
            } else {
              callback(null, blob.toJSON());
            }
          });
        }
      });
    });
  }
}
function notify2(object, methodName, ...messages) {
  if (object && typeof object[methodName] == "function") {
    return object[methodName](...messages);
  }
}

class DirectUploadController2 {
  constructor(input, file) {
    this.input = input;
    this.file = file;
    this.directUpload = new DirectUpload2(this.file, this.url, this);
    this.dispatch("initialize");
  }
  start(callback) {
    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.name = this.input.name;
    this.input.insertAdjacentElement("beforebegin", hiddenInput);
    this.dispatch("start");
    this.directUpload.create((error2, attributes) => {
      if (error2) {
        hiddenInput.parentNode.removeChild(hiddenInput);
        this.dispatchError(error2);
      } else {
        hiddenInput.value = attributes.signed_id;
      }
      this.dispatch("end");
      callback(error2);
    });
  }
  uploadRequestDidProgress(event) {
    const progress = event.loaded / event.total * 100;
    if (progress) {
      this.dispatch("progress", {
        progress
      });
    }
  }
  get url() {
    return this.input.getAttribute("data-direct-upload-url");
  }
  dispatch(name, detail = {}) {
    detail.file = this.file;
    detail.id = this.directUpload.id;
    return dispatchEvent3(this.input, `direct-upload:${name}`, {
      detail
    });
  }
  dispatchError(error2) {
    const event = this.dispatch("error", {
      error: error2
    });
    if (!event.defaultPrevented) {
      alert(error2);
    }
  }
  directUploadWillCreateBlobWithXHR(xhr) {
    this.dispatch("before-blob-request", {
      xhr
    });
  }
  directUploadWillStoreFileWithXHR(xhr) {
    this.dispatch("before-storage-request", {
      xhr
    });
    xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
  }
}
var inputSelector2 = "input[type=file][data-direct-upload-url]:not([disabled])";

class DirectUploadsController2 {
  constructor(form) {
    this.form = form;
    this.inputs = findElements3(form, inputSelector2).filter((input) => input.files.length);
  }
  start(callback) {
    const controllers = this.createDirectUploadControllers();
    const startNextController = () => {
      const controller = controllers.shift();
      if (controller) {
        controller.start((error2) => {
          if (error2) {
            callback(error2);
            this.dispatch("end");
          } else {
            startNextController();
          }
        });
      } else {
        callback();
        this.dispatch("end");
      }
    };
    this.dispatch("start");
    startNextController();
  }
  createDirectUploadControllers() {
    const controllers = [];
    this.inputs.forEach((input) => {
      toArray3(input.files).forEach((file) => {
        const controller = new DirectUploadController2(input, file);
        controllers.push(controller);
      });
    });
    return controllers;
  }
  dispatch(name, detail = {}) {
    return dispatchEvent3(this.form, `direct-uploads:${name}`, {
      detail
    });
  }
}
var processingAttribute2 = "data-direct-uploads-processing";
var submitButtonsByForm2 = new WeakMap;
var started2 = false;
function start3() {
  if (!started2) {
    started2 = true;
    document.addEventListener("click", didClick2, true);
    document.addEventListener("submit", didSubmitForm2, true);
    document.addEventListener("ajax:before", didSubmitRemoteElement2);
  }
}
function didClick2(event) {
  const button = event.target.closest("button, input");
  if (button && button.type === "submit" && button.form) {
    submitButtonsByForm2.set(button.form, button);
  }
}
function didSubmitForm2(event) {
  handleFormSubmissionEvent2(event);
}
function didSubmitRemoteElement2(event) {
  if (event.target.tagName == "FORM") {
    handleFormSubmissionEvent2(event);
  }
}
function handleFormSubmissionEvent2(event) {
  const form = event.target;
  if (form.hasAttribute(processingAttribute2)) {
    event.preventDefault();
    return;
  }
  const controller = new DirectUploadsController2(form);
  const { inputs } = controller;
  if (inputs.length) {
    event.preventDefault();
    form.setAttribute(processingAttribute2, "");
    inputs.forEach(disable2);
    controller.start((error2) => {
      form.removeAttribute(processingAttribute2);
      if (error2) {
        inputs.forEach(enable2);
      } else {
        submitForm2(form);
      }
    });
  }
}
function submitForm2(form) {
  let button = submitButtonsByForm2.get(form) || findElement2(form, "input[type=submit], button[type=submit]");
  if (button) {
    const { disabled } = button;
    button.disabled = false;
    button.focus();
    button.click();
    button.disabled = disabled;
  } else {
    button = document.createElement("input");
    button.type = "submit";
    button.style.display = "none";
    form.appendChild(button);
    button.click();
    form.removeChild(button);
  }
  submitButtonsByForm2.delete(form);
}
function disable2(input) {
  input.disabled = true;
}
function enable2(input) {
  input.disabled = false;
}
function autostart2() {
  if (window.ActiveStorage) {
    start3();
  }
}
setTimeout(autostart2, 1);

class AttachmentUpload {
  constructor(attachment, element) {
    this.attachment = attachment;
    this.element = element;
    this.directUpload = new DirectUpload2(attachment.file, this.directUploadUrl, this);
  }
  start() {
    this.directUpload.create(this.directUploadDidComplete.bind(this));
    this.dispatch("start");
  }
  directUploadWillStoreFileWithXHR(xhr) {
    xhr.upload.addEventListener("progress", (event) => {
      const progress = event.loaded / event.total * 100;
      this.attachment.setUploadProgress(progress);
      if (progress) {
        this.dispatch("progress", {
          progress
        });
      }
    });
  }
  directUploadDidComplete(error2, attributes) {
    if (error2) {
      this.dispatchError(error2);
    } else {
      this.attachment.setAttributes({
        sgid: attributes.attachable_sgid,
        url: this.createBlobUrl(attributes.signed_id, attributes.filename)
      });
      this.dispatch("end");
    }
  }
  createBlobUrl(signedId, filename) {
    return this.blobUrlTemplate.replace(":signed_id", signedId).replace(":filename", encodeURIComponent(filename));
  }
  dispatch(name, detail = {}) {
    detail.attachment = this.attachment;
    return dispatchEvent3(this.element, `direct-upload:${name}`, {
      detail
    });
  }
  dispatchError(error2) {
    const event = this.dispatch("error", {
      error: error2
    });
    if (!event.defaultPrevented) {
      alert(error2);
    }
  }
  get directUploadUrl() {
    return this.element.dataset.directUploadUrl;
  }
  get blobUrlTemplate() {
    return this.element.dataset.blobUrlTemplate;
  }
}
addEventListener("trix-attachment-add", (event) => {
  const { attachment, target } = event;
  if (attachment.file) {
    const upload = new AttachmentUpload(attachment, target);
    upload.start();
  }
});

// app/javascript/application.js
init_awesome();

//# debugId=986E6AE3CA53FC1864756E2164756E21
